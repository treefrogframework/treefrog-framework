.\" Man page generated from reStructuredText.
.
.TH "MONGOC_REFERENCE" "3" "Jun 07, 2022" "1.21.2" "libmongoc"
.SH NAME
mongoc_reference \- Index
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH LIBMONGOC
.sp
A Cross Platform MongoDB Client Library for C
.SS Introduction
.sp
The MongoDB C Driver, also known as "libmongoc", is a library for using MongoDB from C applications, and for writing MongoDB drivers in higher\-level languages.
.sp
It depends on \fI\%libbson\fP to generate and parse BSON documents, the native data format of MongoDB.
.SS Installing the MongoDB C Driver (libmongoc) and BSON library (libbson)
.sp
The following guide will step you through the process of downloading, building, and installing the current release of the MongoDB C Driver (libmongoc) and BSON library (libbson).
.SS Supported Platforms
.sp
The MongoDB C Driver is \fI\%continuously tested\fP on a variety of platforms including:
.INDENT 0.0
.IP \(bu 2
Archlinux
.IP \(bu 2
Debian 9.2, 10.0
.IP \(bu 2
macOS 10.14
.IP \(bu 2
Microsoft Windows Server 2008, 2016
.IP \(bu 2
RHEL 6.2, 7.0, 7.1, 8.2
.IP \(bu 2
Ubuntu 16.04, 18.04
.IP \(bu 2
Clang 3.4, 3.5, 3.7, 3.8, 6.0
.IP \(bu 2
GCC 4.8, 4.9, 5.4, 6.3, 8.2, 8.3
.IP \(bu 2
MinGW\-W64
.IP \(bu 2
Visual Studio 2013, 2015, 2017
.IP \(bu 2
x86, x86_64, ARM (aarch64), Power8 (ppc64le), zSeries (s390x)
.UNINDENT
.SS Install libmongoc with a Package Manager
.sp
Several Linux distributions provide packages for libmongoc and its dependencies. One advantage of installing libmongoc with a package manager is that its dependencies (including libbson) will be installed automatically. If you choose to install libmongoc from distribution packages, use the package manager to confirm the version being installed is sufficient for your needs.
.sp
The libmongoc package is available on recent versions of Debian and Ubuntu.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ apt\-get install libmongoc\-1.0\-0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On Fedora, a mongo\-c\-driver package is available in the default repositories and can be installed with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ dnf install mongo\-c\-driver
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On recent Red Hat systems, such as CentOS and RHEL 7, a mongo\-c\-driver package is available in the \fI\%EPEL\fP repository. To check which version is available, see \fI\%https://apps.fedoraproject.org/packages/mongo\-c\-driver\fP\&. The package can be installed with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ yum install mongo\-c\-driver
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On macOS systems with Homebrew, the mongo\-c\-driver package can be installed with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ brew install mongo\-c\-driver
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Install libbson with a Package Manager
.sp
The libbson package is available on recent versions of Debian and Ubuntu. If you have installed libmongoc, then libbson will have already been installed as a dependency. It is also possible to install libbson without libmongoc.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ apt\-get install libbson\-1.0\-0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On Fedora, a libbson package is available in the default repositories and can be installed with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ dnf install libbson
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On recent Red Hat systems, such as CentOS and RHEL 7, a libbson package
is available in the \fI\%EPEL\fP repository. To check
which version is available, see \fI\%https://apps.fedoraproject.org/packages/libbson\fP\&.
The package can be installed with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ yum install libbson
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Build environment
.SS Build environment on Unix
.SS Prerequisites for libmongoc
.sp
OpenSSL is required for authentication or for TLS connections to MongoDB. Kerberos or LDAP support requires Cyrus SASL.
.sp
To install all optional dependencies on RedHat / Fedora:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo yum install cmake openssl\-devel cyrus\-sasl\-devel
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On Debian / Ubuntu:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo apt\-get install cmake libssl\-dev libsasl2\-dev
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On FreeBSD:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ su \-c \(aqpkg install cmake openssl cyrus\-sasl\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Prerequisites for libbson
.sp
The only prerequisite for building libbson is \fBcmake\fP\&. The command lines above can be adjusted to install only \fBcmake\fP\&.
.SS Build environment on macOS
.sp
Install the XCode Command Line Tools:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ xcode\-select \-\-install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBcmake\fP utility is also required. First \fI\%install Homebrew according to its instructions\fP, then:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ brew install cmake
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Build environment on Windows with Visual Studio
.sp
Building on Windows requires Windows Vista or newer and Visual Studio 2010 or newer. Additionally, \fBcmake\fP is required to generate Visual Studio project files.  Installation of these components on Windows is beyond the scope of this document.
.SS Build environment on Windows with MinGW\-W64 and MSYS2
.sp
Install MSYS2 from \fI\%msys2.github.io\fP\&. Choose the x86_64 version, not i686.
.sp
Open the MingGW shell with \fBc:\emsys64\eming64.exe\fP (not the msys2_shell). Install dependencies:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ pacman \-\-noconfirm \-Syu
$ pacman \-\-noconfirm \-S mingw\-w64\-x86_64\-gcc mingw\-w64\-x86_64\-cmake
$ pacman \-\-noconfirm \-S mingw\-w64\-x86_64\-extra\-cmake\-modules make tar
$ pacman \-\-noconfirm \-S mingw64/mingw\-w64\-x86_64\-cyrus\-sasl
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Configuring the build
.sp
Before building libmongoc and/or libbson, it is necessary to configure, or prepare, the build.  The steps to prepare the build depend on how you obtained the source code and the build platform.
.SS Preparing a build from a release tarball
.sp
The most recent release of libmongoc and libbson, both of which are included in mongo\-c\-driver, can be \fI\%downloaded here\fP\&. The instructions in this document utilize \fBcmake\fP\(aqs out\-of\-source build feature to keep build artifacts separate from source files. While the \fB$\fP prompt is used throughout, the instructions below will work on Linux, macOS, and Windows (assuming that CMake is in the user\(aqs shell path in all cases).  See the subsequent sections for additional platform\-specific instructions.
.sp
The following snippet will download and extract the driver, and configure it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ wget \fI\%https://github.com/mongodb/mongo\-c\-driver/releases/download/\fP1.21.2/mongo\-c\-driver\-1.21.2\&.tar.gz
$ tar xzf mongo\-c\-driver\-1.21.2\&.tar.gz
$ cd mongo\-c\-driver\-1.21.2
$ mkdir cmake\-build
$ cd cmake\-build
$ cmake \-DENABLE_AUTOMATIC_INIT_AND_CLEANUP=OFF ..
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fB\-DENABLE_AUTOMATIC_INIT_AND_CLEANUP=OFF\fP option is recommended, see init\-cleanup\&. Another useful \fBcmake\fP option is \fB\-DCMAKE_BUILD_TYPE=Release\fP for a release optimized build and \fB\-DCMAKE_BUILD_TYPE=Debug\fP for a debug build. For a list of all configure options, run \fBcmake \-L ..\fP\&.
.sp
If \fBcmake\fP completed successfully, you will see a considerable amount of output describing your build configuration. The final line of output should look something like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\-\- Build files have been written to: /home/user/mongo\-c\-driver\-1.21.2/cmake\-build
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If \fBcmake\fP concludes with anything different, then it is likely an error occurred.
.sp
mongo\-c\-driver contains a copy of libbson, in case your system does not already have libbson installed. The configuration will detect if libbson is not installed and use the bundled libbson.
.sp
Additionally, it is possible to build only libbson by setting the \fB\-DENABLE_MONGOC=OFF\fP option:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cmake \-DENABLE_AUTOMATIC_INIT_AND_CLEANUP=OFF \-DENABLE_MONGOC=OFF ..
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A build configuration description similar to the one above will be displayed, though with fewer entries. Once the configuration is complete, the selected items can be built and installed with these commands:
.SS Preparing a build from a git repository clone
.sp
Clone the repository and prepare the build on the current branch or a particular release tag:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ git clone \fI\%https://github.com/mongodb/mongo\-c\-driver.git\fP
$ cd mongo\-c\-driver
$ git checkout 1.21.2  # To build a particular release
$ python build/calc_release_version.py > VERSION_CURRENT
$ mkdir cmake\-build
$ cd cmake\-build
$ cmake \-DENABLE_AUTOMATIC_INIT_AND_CLEANUP=OFF ..
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Preparing a build on Windows with Visual Studio
.sp
On the Windows platform with Visual Studio, it may be necessary to specify the CMake generator to use.  This is especially important if multiple versions of Visual Studio are installed on the system or if alternate build tools (e.g., MinGW, MSYS2, Cygwin, etc.) are present on the system.  Specifying the generator will ensure that the build configuration is known with certainty, rather than relying on the toolchain that CMake happens to find.
.sp
Start by generating Visual Studio project files. The following assumes you are compiling for 64\-bit Windows using Visual Studio 2015 Express, which can be freely downloaded from Microsoft. The sample commands utilize \fBcmake\fP\(aqs out\-of\-source build feature to keep build artifacts separate from source files.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd mongo\-c\-driver\-1.21.2
$ mkdir cmake\-build
$ cd cmake\-build
$ cmake \-G "Visual Studio 14 2015 Win64" \e
    "\-DCMAKE_INSTALL_PREFIX=C:\emongo\-c\-driver" \e
    "\-DCMAKE_PREFIX_PATH=C:\emongo\-c\-driver" \e
    ..
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
(Run \fBcmake \-LH ..\fP for a list of other options.)
.sp
To see a complete list of the CMake generators available on your specific system, use a command like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cmake \-\-help
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Executing a build
.SS Building on Unix, macOS, and Windows (MinGW\-W64 and MSYS2)
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cmake \-\-build .
$ sudo cmake \-\-build . \-\-target install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
(Note that the \fBsudo\fP command may not be applicable or available depending on the configuration of your system.)
.sp
In the above commands, the first relies on the default target which builds all configured components.  For fine grained control over what gets built, the following command can be used (for Ninja and Makefile\-based build systems) to list all available targets:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cmake \-\-build . help
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Building on Windows with Visual Studio
.sp
Once the project files are generated, the project can be opened directly in Visual Studio or compiled from the command line.
.sp
Build using the CMake build tool mode:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cmake \-\-build . \-\-config RelWithDebInfo
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Visual Studio\(aqs default build type is \fBDebug\fP, but we recommend a release build with debug info for production use. Now that libmongoc and libbson are compiled, install them. Components will be installed to the path specified by \fBCMAKE_INSTALL_PREFIX\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cmake \-\-build . \-\-config RelWithDebInfo \-\-target install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You should now see libmongoc and libbson installed in \fBC:\emongo\-c\-driver\fP
.sp
For Visual Studio 2019 (16.4 and newer), this command can be used to list all available targets:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cmake \-\-build . \-\- /targets
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Alternately, you can examine the files matching the glob \fB*.vcxproj\fP in the \fBcmake\-build\fP directory.
.sp
To use the driver libraries in your program, see visual\-studio\-guide\&.
.SS Generating the documentation
.sp
Install \fI\%Sphinx\fP, then:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cmake \-DENABLE_MAN_PAGES=ON \-DENABLE_HTML_DOCS=ON ..
$ cmake \-\-build . \-\-target mongoc\-doc
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To build only the libbson documentation:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cmake \-DENABLE_MAN_PAGES=ON \-DENABLE_HTML_DOCS=ON ..
$ cmake \-\-build . \-\-target bson\-doc
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fB\-DENABLE_MAN_PAGES=ON\fP and \fB\-DENABLE_HTML_DOCS=ON\fP can also be added as options to a normal build from a release tarball or from git so that the documentation is built at the same time as other components.
.SS Uninstalling the installed components
.sp
There are two ways to uninstall the components that have been installed.  The first is to invoke the uninstall program directly.  On Linux/Unix:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo /usr/local/share/mongo\-c\-driver/uninstall.sh
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On Windows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ C:\emongo\-c\-driver\eshare\emongo\-c\-driver\euninstall.bat
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The second way to uninstall is from within the build directory, assuming that it is in the exact same state as when the install command was invoked:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo cmake \-\-build . \-\-target uninstall
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The second approach simply invokes the uninstall program referenced in the first approach.
.SS Dealing with Build Failures
.sp
If your attempt to build the C driver fails, please see the \fIREADME <https://github.com/mongodb/mongo\-c\-driver#how\-to\-ask\-for\-help>\fP for instructions on requesting assistance.
.SS Additional Options for Integrators
.sp
In the event that you are building the BSON library and/or the C driver to embed with other components and you wish to avoid the potential for collision with components installed from a standard build or from a distribution package manager, you can make use of the \fBBSON_OUTPUT_BASENAME\fP and \fBMONGOC_OUTPUT_BASENAME\fP options to \fBcmake\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cmake \-DBSON_OUTPUT_BASENAME=custom_bson \-DMONGOC_OUTPUT_BASENAME=custom_mongoc ..
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The above command would produce libraries named \fBlibcustom_bson.so\fP and \fBlibcustom_mongoc.so\fP (or with the extension appropriate for the build platform).  Those libraries could be placed in a standard system directory or in an alternate location and could be linked to by specifying something like \fB\-lcustom_mongoc \-lcustom_bson\fP on the linker command line (possibly adjusting the specific flags to those required by your linker).
.SS Tutorial
.sp
This guide offers a brief introduction to the MongoDB C Driver.
.sp
For more information on the C API, please refer to the api\&.
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Tutorial\fP
.INDENT 2.0
.IP \(bu 2
\fI\%Installing\fP
.IP \(bu 2
\fI\%Starting MongoDB\fP
.IP \(bu 2
\fI\%Include and link libmongoc in your C program\fP
.IP \(bu 2
\fI\%Use libmongoc in a Microsoft Visual Studio Project\fP
.IP \(bu 2
\fI\%Making a Connection\fP
.IP \(bu 2
\fI\%Creating BSON Documents\fP
.IP \(bu 2
\fI\%Basic CRUD Operations\fP
.IP \(bu 2
\fI\%Executing Commands\fP
.IP \(bu 2
\fI\%Threading\fP
.IP \(bu 2
\fI\%Next Steps\fP
.UNINDENT
.UNINDENT
.SS Installing
.sp
For detailed instructions on installing the MongoDB C Driver on a particular platform, please see the installation guide\&.
.SS Starting MongoDB
.sp
To run the examples in this tutorial, MongoDB must be installed and running on \fBlocalhost\fP on the default port, 27017. To check if it is up and running, connect to it with the MongoDB shell.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongo \-\-host localhost \-\-port 27017
MongoDB shell version: 3.0.6
connecting to: localhost:27017/test
>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Include and link libmongoc in your C program
.SS Include mongoc.h
.sp
All libmongoc\(aqs functions and types are available in one header file. Simply include \fBmongoc/mongoc.h\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS CMake
.sp
The libmongoc installation includes a \fI\%CMake config\-file package\fP, so you can use CMake\(aqs \fI\%find_package\fP command to import libmongoc\(aqs CMake target and link to libmongoc (as a shared library):
.sp
CMakeLists.txt
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Specify the minimum version you require.
find_package (mongoc\-1.0 1.7 REQUIRED)

# The "hello_mongoc.c" sample program is shared among four tests.
add_executable (hello_mongoc ../../hello_mongoc.c)
target_link_libraries (hello_mongoc PRIVATE mongo::mongoc_shared)

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can also use libmongoc as a static library instead: Use the \fBmongo::mongoc_static\fP CMake target:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Specify the minimum version you require.
find_package (mongoc\-1.0 1.7 REQUIRED)

# The "hello_mongoc.c" sample program is shared among four tests.
add_executable (hello_mongoc ../../hello_mongoc.c)
target_link_libraries (hello_mongoc PRIVATE mongo::mongoc_static)

.ft P
.fi
.UNINDENT
.UNINDENT
.SS pkg\-config
.sp
If you\(aqre not using CMake, use \fI\%pkg\-config\fP on the command line to set header and library paths:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
gcc \-o hello_mongoc hello_mongoc.c $(pkg\-config \-\-libs \-\-cflags libmongoc\-1.0)

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or to statically link to libmongoc:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
gcc \-o hello_mongoc hello_mongoc.c $(pkg\-config \-\-libs \-\-cflags libmongoc\-static\-1.0)

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Specifying header and include paths manually
.sp
If you aren\(aqt using CMake or pkg\-config, paths and libraries can be managed manually.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-o hello_mongoc hello_mongoc.c \e
    \-I/usr/local/include/libbson\-1.0 \-I/usr/local/include/libmongoc\-1.0 \e
    \-lmongoc\-1.0 \-lbson\-1.0
$ ./hello_mongoc
{ "ok" : 1.000000 }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For Windows users, the code can be compiled and run with the following commands. (This assumes that the MongoDB C Driver has been installed to \fBC:\emongo\-c\-driver\fP; change the include directory as needed.)
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\e> cl.exe /IC:\emongo\-c\-driver\einclude\elibbson\-1.0 /IC:\emongo\-c\-driver\einclude\elibmongoc\-1.0 hello_mongoc.c
C:\e> hello_mongoc
{ "ok" : 1.000000 }
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Use libmongoc in a Microsoft Visual Studio Project
.sp
See the libmongoc and Visual Studio guide\&.
.SS Making a Connection
.sp
Access MongoDB with a \fBmongoc_client_t\fP\&. It transparently connects to standalone servers, replica sets and sharded clusters on demand. To perform operations on a database or collection, create a \fBmongoc_database_t\fP or \fBmongoc_collection_t\fP struct from the \fBmongoc_client_t\fP\&.
.sp
At the start of an application, call \fBmongoc_init\fP before any other libmongoc functions. At the end, call the appropriate destroy function for each collection, database, or client handle, in reverse order from how they were constructed. Call \fBmongoc_cleanup\fP before exiting.
.sp
The example below establishes a connection to a standalone server on \fBlocalhost\fP, registers the client application as "connect\-example," and performs a simple command.
.sp
More information about database operations can be found in the \fI\%CRUD Operations\fP and \fI\%Executing Commands\fP sections. Examples of connecting to replica sets and sharded clusters can be found on the Advanced Connections page.
.sp
hello_mongoc.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

int
main (int argc, char *argv[])
{
   const char *uri_string = "mongodb://localhost:27017";
   mongoc_uri_t *uri;
   mongoc_client_t *client;
   mongoc_database_t *database;
   mongoc_collection_t *collection;
   bson_t *command, reply, *insert;
   bson_error_t error;
   char *str;
   bool retval;

   /*
    * Required to initialize libmongoc\(aqs internals
    */
   mongoc_init ();

   /*
    * Optionally get MongoDB URI from command line
    */
   if (argc > 1) {
      uri_string = argv[1];
   }

   /*
    * Safely create a MongoDB URI object from the given string
    */
   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   /*
    * Create a new client instance
    */
   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   /*
    * Register the application name so we can track it in the profile logs
    * on the server. This can also be done from the URI (see other examples).
    */
   mongoc_client_set_appname (client, "connect\-example");

   /*
    * Get a handle on the database "db_name" and collection "coll_name"
    */
   database = mongoc_client_get_database (client, "db_name");
   collection = mongoc_client_get_collection (client, "db_name", "coll_name");

   /*
    * Do work. This example pings the database, prints the result as JSON and
    * performs an insert
    */
   command = BCON_NEW ("ping", BCON_INT32 (1));

   retval = mongoc_client_command_simple (
      client, "admin", command, NULL, &reply, &error);

   if (!retval) {
      fprintf (stderr, "%s\en", error.message);
      return EXIT_FAILURE;
   }

   str = bson_as_json (&reply, NULL);
   printf ("%s\en", str);

   insert = BCON_NEW ("hello", BCON_UTF8 ("world"));

   if (!mongoc_collection_insert_one (collection, insert, NULL, NULL, &error)) {
      fprintf (stderr, "%s\en", error.message);
   }

   bson_destroy (insert);
   bson_destroy (&reply);
   bson_destroy (command);
   bson_free (str);

   /*
    * Release our handles and clean up libmongoc
    */
   mongoc_collection_destroy (collection);
   mongoc_database_destroy (database);
   mongoc_uri_destroy (uri);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Creating BSON Documents
.sp
Documents are stored in MongoDB\(aqs data format, BSON. The C driver uses \fI\%libbson\fP to create BSON documents. There are several ways to construct them: appending key\-value pairs, using BCON, or parsing JSON.
.SS Appending BSON
.sp
A BSON document, represented as a \fI\%bson_t\fP in code, can be constructed one field at a time using libbson\(aqs append functions.
.sp
For example, to create a document like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
   born : ISODate("1906\-12\-09"),
   died : ISODate("1992\-01\-01"),
   name : {
      first : "Grace",
      last : "Hopper"
   },
   languages : [ "MATH\-MATIC", "FLOW\-MATIC", "COBOL" ],
   degrees: [ { degree: "BA", school: "Vassar" }, { degree: "PhD", school: "Yale" } ]
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Use the following code:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>

int
main (int   argc,
      char *argv[])
{
   struct tm   born = { 0 };
   struct tm   died = { 0 };
   const char *lang_names[] = {"MATH\-MATIC", "FLOW\-MATIC", "COBOL"};
   const char *schools[] = {"Vassar", "Yale"};
   const char *degrees[] = {"BA", "PhD"};
   uint32_t    i;
   char        buf[16];
   const       char *key;
   size_t      keylen;
   bson_t     *document;
   bson_t      child;
   bson_t      child2;
   char       *str;

   document = bson_new ();

   /*
    * Append { "born" : ISODate("1906\-12\-09") } to the document.
    * Passing \-1 for the length argument tells libbson to calculate the string length.
    */
   born.tm_year = 6;  /* years are 1900\-based */
   born.tm_mon = 11;  /* months are 0\-based */
   born.tm_mday = 9;
   bson_append_date_time (document, "born", \-1, mktime (&born) * 1000);

   /*
    * Append { "died" : ISODate("1992\-01\-01") } to the document.
    */
   died.tm_year = 92;
   died.tm_mon = 0;
   died.tm_mday = 1;

   /*
    * For convenience, this macro passes length \-1 by default.
    */
   BSON_APPEND_DATE_TIME (document, "died", mktime (&died) * 1000);

   /*
    * Append a subdocument.
    */
   BSON_APPEND_DOCUMENT_BEGIN (document, "name", &child);
   BSON_APPEND_UTF8 (&child, "first", "Grace");
   BSON_APPEND_UTF8 (&child, "last", "Hopper");
   bson_append_document_end (document, &child);

   /*
    * Append array of strings. Generate keys "0", "1", "2".
    */
   BSON_APPEND_ARRAY_BEGIN (document, "languages", &child);
   for (i = 0; i < sizeof lang_names / sizeof (char *); ++i) {
      keylen = bson_uint32_to_string (i, &key, buf, sizeof buf);
      bson_append_utf8 (&child, key, (int) keylen, lang_names[i], \-1);
   }
   bson_append_array_end (document, &child);

   /*
    * Array of subdocuments:
    *    degrees: [ { degree: "BA", school: "Vassar" }, ... ]
    */
   BSON_APPEND_ARRAY_BEGIN (document, "degrees", &child);
   for (i = 0; i < sizeof degrees / sizeof (char *); ++i) {
      keylen = bson_uint32_to_string (i, &key, buf, sizeof buf);
      bson_append_document_begin (&child, key, (int) keylen, &child2);
      BSON_APPEND_UTF8 (&child2, "degree", degrees[i]);
      BSON_APPEND_UTF8 (&child2, "school", schools[i]);
      bson_append_document_end (&child, &child2);
   }
   bson_append_array_end (document, &child);

   /*
    * Print the document as a JSON string.
    */
   str = bson_as_canonical_extended_json (document, NULL);
   printf ("%s\en", str);
   bson_free (str);

   /*
    * Clean up allocated bson documents.
    */
   bson_destroy (document);
   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
See the \fI\%libbson documentation\fP for all of the types that can be appended to a \fI\%bson_t\fP\&.
.SS Using BCON
.sp
\fIBSON C Object Notation\fP, BCON for short, is an alternative way of constructing BSON documents in a manner closer to the intended format. It has less type\-safety than BSON\(aqs append functions but results in less code.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>

int
main (int   argc,
      char *argv[])
{
   struct tm born = { 0 };
   struct tm died = { 0 };
   bson_t   *document;
   char     *str;

   born.tm_year = 6;
   born.tm_mon = 11;
   born.tm_mday = 9;

   died.tm_year = 92;
   died.tm_mon = 0;
   died.tm_mday = 1;

   document = BCON_NEW (
      "born", BCON_DATE_TIME (mktime (&born) * 1000),
      "died", BCON_DATE_TIME (mktime (&died) * 1000),
      "name", "{",
      "first", BCON_UTF8 ("Grace"),
      "last", BCON_UTF8 ("Hopper"),
      "}",
      "languages", "[",
      BCON_UTF8 ("MATH\-MATIC"),
      BCON_UTF8 ("FLOW\-MATIC"),
      BCON_UTF8 ("COBOL"),
      "]",
      "degrees", "[",
      "{", "degree", BCON_UTF8 ("BA"), "school", BCON_UTF8 ("Vassar"), "}",
      "{", "degree", BCON_UTF8 ("PhD"), "school", BCON_UTF8 ("Yale"), "}",
      "]");

   /*
    * Print the document as a JSON string.
    */
   str = bson_as_canonical_extended_json (document, NULL);
   printf ("%s\en", str);
   bson_free (str);

   /*
    * Clean up allocated bson documents.
    */
   bson_destroy (document);
   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Notice that BCON can create arrays, subdocuments and arbitrary fields.
.SS Creating BSON from JSON
.sp
For \fIsingle\fP documents, BSON can be created from JSON strings via \fI\%bson_new_from_json\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>

int
main (int   argc,
      char *argv[])
{
   bson_error_t error;
   bson_t      *bson;
   char        *string;

   const char *json = "{\e"name\e": {\e"first\e":\e"Grace\e", \e"last\e":\e"Hopper\e"}}";
   bson = bson_new_from_json ((const uint8_t *)json, \-1, &error);

   if (!bson) {
      fprintf (stderr, "%s\en", error.message);
      return EXIT_FAILURE;
   }

   string = bson_as_canonical_extended_json (bson, NULL);
   printf ("%s\en", string);
   bson_free (string);

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To initialize BSON from a sequence of JSON documents, use \fI\%bson_json_reader_t\fP\&.
.SS Basic CRUD Operations
.sp
This section demonstrates the basics of using the C Driver to interact with MongoDB.
.SS Inserting a Document
.sp
To insert documents into a collection, first obtain a handle to a \fBmongoc_collection_t\fP via a \fBmongoc_client_t\fP\&. Then, use \fBmongoc_collection_insert_one\fP to add BSON documents to the collection. This example inserts into the database "mydb" and collection "mycoll".
.sp
When finished, ensure that allocated structures are freed by using their respective destroy functions.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

int
main (int   argc,
      char *argv[])
{
    mongoc_client_t *client;
    mongoc_collection_t *collection;
    bson_error_t error;
    bson_oid_t oid;
    bson_t *doc;

    mongoc_init ();

    client = mongoc_client_new ("mongodb://localhost:27017/?appname=insert\-example");
    collection = mongoc_client_get_collection (client, "mydb", "mycoll");

    doc = bson_new ();
    bson_oid_init (&oid, NULL);
    BSON_APPEND_OID (doc, "_id", &oid);
    BSON_APPEND_UTF8 (doc, "hello", "world");

    if (!mongoc_collection_insert_one (
           collection, doc, NULL, NULL, &error)) {
        fprintf (stderr, "%s\en", error.message);
    }

    bson_destroy (doc);
    mongoc_collection_destroy (collection);
    mongoc_client_destroy (client);
    mongoc_cleanup ();

    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compile the code and run it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-o insert insert.c $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0)
$ ./insert
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On Windows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\e> cl.exe /IC:\emongo\-c\-driver\einclude\elibbson\-1.0 /IC:\emongo\-c\-driver\einclude\elibmongoc\-1.0 insert.c
C:\e> insert
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To verify that the insert succeeded, connect with the MongoDB shell.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongo
MongoDB shell version: 3.0.6
connecting to: test
> use mydb
switched to db mydb
> db.mycoll.find()
{ "_id" : ObjectId("55ef43766cb5f36a3bae6ee4"), "hello" : "world" }
>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Finding a Document
.sp
To query a MongoDB collection with the C driver, use the function mongoc_collection_find_with_opts()\&. This returns a cursor to the matching documents. The following examples iterate through the result cursors and print the matches to \fBstdout\fP as JSON strings.
.sp
Use a document as a query specifier; for example,
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "color" : "red" }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will match any document with a field named "color" with value "red". An empty document \fB{}\fP can be used to match all documents.
.sp
This first example uses an empty query specifier to find all documents in the database "mydb" and collection "mycoll".
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   mongoc_cursor_t *cursor;
   const bson_t *doc;
   bson_t *query;
   char *str;

   mongoc_init ();

   client =
      mongoc_client_new ("mongodb://localhost:27017/?appname=find\-example");
   collection = mongoc_client_get_collection (client, "mydb", "mycoll");
   query = bson_new ();
   cursor = mongoc_collection_find_with_opts (collection, query, NULL, NULL);

   while (mongoc_cursor_next (cursor, &doc)) {
      str = bson_as_canonical_extended_json (doc, NULL);
      printf ("%s\en", str);
      bson_free (str);
   }

   bson_destroy (query);
   mongoc_cursor_destroy (cursor);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compile the code and run it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-o find find.c $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0)
$ ./find
{ "_id" : { "$oid" : "55ef43766cb5f36a3bae6ee4" }, "hello" : "world" }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On Windows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\e> cl.exe /IC:\emongo\-c\-driver\einclude\elibbson\-1.0 /IC:\emongo\-c\-driver\einclude\elibmongoc\-1.0 find.c
C:\e> find
{ "_id" : { "$oid" : "55ef43766cb5f36a3bae6ee4" }, "hello" : "world" }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To look for a specific document, add a specifier to \fBquery\fP\&. This example adds a call to \fBBSON_APPEND_UTF8()\fP to look for all documents matching \fB{"hello" : "world"}\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   mongoc_cursor_t *cursor;
   const bson_t *doc;
   bson_t *query;
   char *str;

   mongoc_init ();

   client = mongoc_client_new (
      "mongodb://localhost:27017/?appname=find\-specific\-example");
   collection = mongoc_client_get_collection (client, "mydb", "mycoll");
   query = bson_new ();
   BSON_APPEND_UTF8 (query, "hello", "world");

   cursor = mongoc_collection_find_with_opts (collection, query, NULL, NULL);

   while (mongoc_cursor_next (cursor, &doc)) {
      str = bson_as_canonical_extended_json (doc, NULL);
      printf ("%s\en", str);
      bson_free (str);
   }

   bson_destroy (query);
   mongoc_cursor_destroy (cursor);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-o find\-specific find\-specific.c $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0)
$ ./find\-specific
{ "_id" : { "$oid" : "55ef43766cb5f36a3bae6ee4" }, "hello" : "world" }
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\e> cl.exe /IC:\emongo\-c\-driver\einclude\elibbson\-1.0 /IC:\emongo\-c\-driver\einclude\elibmongoc\-1.0 find\-specific.c
C:\e> find\-specific
{ "_id" : { "$oid" : "55ef43766cb5f36a3bae6ee4" }, "hello" : "world" }
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Updating a Document
.sp
This code snippet gives an example of using mongoc_collection_update_one() to update the fields of a document.
.sp
Using the "mydb" database, the following example inserts an example document into the "mycoll" collection. Then, using its \fB_id\fP field, the document is updated with different values and a new field.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

int
main (int argc, char *argv[])
{
   mongoc_collection_t *collection;
   mongoc_client_t *client;
   bson_error_t error;
   bson_oid_t oid;
   bson_t *doc = NULL;
   bson_t *update = NULL;
   bson_t *query = NULL;

   mongoc_init ();

   client =
      mongoc_client_new ("mongodb://localhost:27017/?appname=update\-example");
   collection = mongoc_client_get_collection (client, "mydb", "mycoll");

   bson_oid_init (&oid, NULL);
   doc = BCON_NEW ("_id", BCON_OID (&oid), "key", BCON_UTF8 ("old_value"));

   if (!mongoc_collection_insert_one (collection, doc, NULL, &error)) {
      fprintf (stderr, "%s\en", error.message);
      goto fail;
   }

   query = BCON_NEW ("_id", BCON_OID (&oid));
   update = BCON_NEW ("$set",
                      "{",
                      "key",
                      BCON_UTF8 ("new_value"),
                      "updated",
                      BCON_BOOL (true),
                      "}");

   if (!mongoc_collection_update_one (
          collection, query, update, NULL, NULL, &error)) {
      fprintf (stderr, "%s\en", error.message);
      goto fail;
   }

fail:
   if (doc)
      bson_destroy (doc);
   if (query)
      bson_destroy (query);
   if (update)
      bson_destroy (update);

   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compile the code and run it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-o update update.c $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0)
$ ./update
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On Windows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\e> cl.exe /IC:\emongo\-c\-driver\einclude\elibbson\-1.0 /IC:\emongo\-c\-driver\einclude\elibmongoc\-1.0 update.c
C:\e> update
{ "_id" : { "$oid" : "55ef43766cb5f36a3bae6ee4" }, "hello" : "world" }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To verify that the update succeeded, connect with the MongoDB shell.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongo
MongoDB shell version: 3.0.6
connecting to: test
> use mydb
switched to db mydb
> db.mycoll.find({"updated" : true})
{ "_id" : ObjectId("55ef549236fe322f9490e17b"), "updated" : true, "key" : "new_value" }
>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Deleting a Document
.sp
This example illustrates the use of \fBmongoc_collection_delete_one()\fP to delete a document.
.sp
The following code inserts a sample document into the database "mydb" and collection "mycoll". Then, it deletes all documents matching \fB{"hello" : "world"}\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   bson_error_t error;
   bson_oid_t oid;
   bson_t *doc;

   mongoc_init ();

   client =
      mongoc_client_new ("mongodb://localhost:27017/?appname=delete\-example");
   collection = mongoc_client_get_collection (client, "test", "test");

   doc = bson_new ();
   bson_oid_init (&oid, NULL);
   BSON_APPEND_OID (doc, "_id", &oid);
   BSON_APPEND_UTF8 (doc, "hello", "world");

   if (!mongoc_collection_insert_one (collection, doc, NULL, &error)) {
      fprintf (stderr, "Insert failed: %s\en", error.message);
   }

   bson_destroy (doc);

   doc = bson_new ();
   BSON_APPEND_OID (doc, "_id", &oid);

   if (!mongoc_collection_delete_one (
          collection, doc, NULL, NULL, &error)) {
      fprintf (stderr, "Delete failed: %s\en", error.message);
   }

   bson_destroy (doc);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compile the code and run it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-o delete delete.c $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0)
$ ./delete
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On Windows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\e> cl.exe /IC:\emongo\-c\-driver\einclude\elibbson\-1.0 /IC:\emongo\-c\-driver\einclude\elibmongoc\-1.0 delete.c
C:\e> delete
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Use the MongoDB shell to prove that the documents have been removed successfully.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongo
MongoDB shell version: 3.0.6
connecting to: test
> use mydb
switched to db mydb
> db.mycoll.count({"hello" : "world"})
0
>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Counting Documents
.sp
Counting the number of documents in a MongoDB collection is similar to performing a \fI\%find operation\fP\&. This example counts the number of documents matching \fB{"hello" : "world"}\fP in the database "mydb" and collection "mycoll".
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   bson_error_t error;
   bson_t *doc;
   int64_t count;

   mongoc_init ();

   client =
      mongoc_client_new ("mongodb://localhost:27017/?appname=count\-example");
   collection = mongoc_client_get_collection (client, "mydb", "mycoll");
   doc = bson_new_from_json (
      (const uint8_t *) "{\e"hello\e" : \e"world\e"}", \-1, &error);

   count = mongoc_collection_count (
      collection, MONGOC_QUERY_NONE, doc, 0, 0, NULL, &error);

   if (count < 0) {
      fprintf (stderr, "%s\en", error.message);
   } else {
      printf ("%" PRId64 "\en", count);
   }

   bson_destroy (doc);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compile the code and run it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-o count count.c $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0)
$ ./count
1
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On Windows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\e> cl.exe /IC:\emongo\-c\-driver\einclude\elibbson\-1.0 /IC:\emongo\-c\-driver\einclude\elibmongoc\-1.0 count.c
C:\e> count
1
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Executing Commands
.sp
The driver provides helper functions for executing MongoDB commands on client, database and collection structures. These functions return cursors; the \fB_simple\fP variants return booleans indicating success or failure.
.sp
This example executes the \fI\%collStats\fP command against the collection "mycoll" in database "mydb".
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   bson_error_t error;
   bson_t *command;
   bson_t reply;
   char *str;

   mongoc_init ();

   client = mongoc_client_new (
      "mongodb://localhost:27017/?appname=executing\-example");
   collection = mongoc_client_get_collection (client, "mydb", "mycoll");

   command = BCON_NEW ("collStats", BCON_UTF8 ("mycoll"));
   if (mongoc_collection_command_simple (
          collection, command, NULL, &reply, &error)) {
      str = bson_as_canonical_extended_json (&reply, NULL);
      printf ("%s\en", str);
      bson_free (str);
   } else {
      fprintf (stderr, "Failed to run command: %s\en", error.message);
   }

   bson_destroy (command);
   bson_destroy (&reply);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compile the code and run it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-o executing executing.c $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0)
$ ./executing
{ "ns" : "mydb.mycoll", "count" : 1, "size" : 48, "avgObjSize" : 48, "numExtents" : 1, "storageSize" : 8192,
"lastExtentSize" : 8192.000000, "paddingFactor" : 1.000000, "userFlags" : 1, "capped" : false, "nindexes" : 1,
"indexDetails" : {  }, "totalIndexSize" : 8176, "indexSizes" : { "_id_" : 8176 }, "ok" : 1.000000 }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On Windows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\e> cl.exe /IC:\emongo\-c\-driver\einclude\elibbson\-1.0 /IC:\emongo\-c\-driver\einclude\elibmongoc\-1.0 executing.c
C:\e> executing
{ "ns" : "mydb.mycoll", "count" : 1, "size" : 48, "avgObjSize" : 48, "numExtents" : 1, "storageSize" : 8192,
"lastExtentSize" : 8192.000000, "paddingFactor" : 1.000000, "userFlags" : 1, "capped" : false, "nindexes" : 1,
"indexDetails" : {  }, "totalIndexSize" : 8176, "indexSizes" : { "_id_" : 8176 }, "ok" : 1.000000 }
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Threading
.sp
The MongoDB C Driver is thread\-unaware in the vast majority of its operations. This means it is up to the programmer to guarantee thread\-safety.
.sp
However, \fBmongoc_client_pool_t\fP is thread\-safe and is used to fetch a \fBmongoc_client_t\fP in a thread\-safe manner. After retrieving a client from the pool, the client structure should be considered owned by the calling thread. When the thread is finished, the client should be placed back into the pool.
.sp
example\-pool.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* gcc example\-pool.c \-o example\-pool $(pkg\-config \-\-cflags \-\-libs
 * libmongoc\-1.0) */

/* ./example\-pool [CONNECTION_STRING] */

#include <mongoc/mongoc.h>
#include <pthread.h>
#include <stdio.h>

static pthread_mutex_t mutex;
static bool in_shutdown = false;

static void *
worker (void *data)
{
   mongoc_client_pool_t *pool = data;
   mongoc_client_t *client;
   bson_t ping = BSON_INITIALIZER;
   bson_error_t error;
   bool r;

   BSON_APPEND_INT32 (&ping, "ping", 1);

   while (true) {
      client = mongoc_client_pool_pop (pool);
      /* Do something with client. If you are writing an HTTP server, you
       * probably only want to hold onto the client for the portion of the
       * request performing database queries.
       */
      r = mongoc_client_command_simple (
         client, "admin", &ping, NULL, NULL, &error);

      if (!r) {
         fprintf (stderr, "%s\en", error.message);
      }

      mongoc_client_pool_push (pool, client);

      pthread_mutex_lock (&mutex);
      if (in_shutdown || !r) {
         pthread_mutex_unlock (&mutex);
         break;
      }

      pthread_mutex_unlock (&mutex);
   }

   bson_destroy (&ping);
   return NULL;
}

int
main (int argc, char *argv[])
{
   const char *uri_string = "mongodb://127.0.0.1/?appname=pool\-example";
   mongoc_uri_t *uri;
   bson_error_t error;
   mongoc_client_pool_t *pool;
   pthread_t threads[10];
   unsigned i;
   void *ret;

   pthread_mutex_init (&mutex, NULL);
   mongoc_init ();

   if (argc > 1) {
      uri_string = argv[1];
   }

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   pool = mongoc_client_pool_new (uri);
   mongoc_client_pool_set_error_api (pool, 2);

   for (i = 0; i < 10; i++) {
      pthread_create (&threads[i], NULL, worker, pool);
   }

   sleep (10);
   pthread_mutex_lock (&mutex);
   in_shutdown = true;
   pthread_mutex_unlock (&mutex);

   for (i = 0; i < 10; i++) {
      pthread_join (threads[i], &ret);
   }

   mongoc_client_pool_destroy (pool);
   mongoc_uri_destroy (uri);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Next Steps
.sp
To find information on advanced topics, browse the rest of the C driver guide or the \fI\%official MongoDB documentation\fP\&.
.sp
For help with common issues, consult the Troubleshooting page. To report a bug or request a new feature, follow these instructions\&.
.SS Authentication
.sp
This guide covers the use of authentication options with the MongoDB C Driver. Ensure that the MongoDB server is also properly configured for authentication before making a connection. For more information, see the \fI\%MongoDB security documentation\fP\&.
.sp
The MongoDB C driver supports several authentication mechanisms through the use of MongoDB connection URIs.
.sp
By default, if a username and password are provided as part of the connection string (and an optional authentication database), they are used to connect via the default authentication mechanism of the server.
.sp
To select a specific authentication mechanism other than the default, see the list of supported mechanism below.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client = mongoc_client_new ("mongodb://user:password@localhost/?authSource=mydb");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Currently supported values for the authMechanism connection string option are:
.INDENT 0.0
.IP \(bu 2
\fI\%SCRAM\-SHA\-1\fP
.IP \(bu 2
\fI\%MONGODB\-CR (deprecated)\fP
.IP \(bu 2
\fI\%GSSAPI\fP
.IP \(bu 2
\fI\%PLAIN\fP
.IP \(bu 2
\fI\%X509\fP
.IP \(bu 2
\fI\%MONGODB\-AWS\fP
.UNINDENT
.SS Basic Authentication (SCRAM\-SHA\-256)
.sp
MongoDB 4.0 introduces support for authenticating using the SCRAM protocol
with the more secure SHA\-256 hash described in \fI\%RFC 7677\fP\&. Using this authentication mechanism
means that the password is never actually sent over the wire when
authenticating, but rather a computed proof that the client password is the
same as the password the server knows. In MongoDB 4.0, the C driver can
determine the correct default authentication mechanism for users with stored
SCRAM\-SHA\-1 and SCRAM\-SHA\-256 credentials:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client =  mongoc_client_new ("mongodb://user:password@localhost/?authSource=mydb");
/* the correct authMechanism is negotiated between the driver and server. */
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Alternatively, SCRAM\-SHA\-256 can be explicitly specified as an authMechanism.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client =  mongoc_client_new ("mongodb://user:password@localhost/?authMechanism=SCRAM\-SHA\-256&authSource=mydb");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Passwords for SCRAM\-SHA\-256 undergo the preprocessing step known as SASLPrep
specified in \fI\%RFC 4013\fP\&. SASLPrep will
only be performed for passwords containing non\-ASCII characters.  SASLPrep
requires libicu. If libicu is not available, attempting to authenticate over
SCRAM\-SHA\-256 with non\-ASCII passwords will result in error.
.sp
Usernames \fInever\fP undergo SASLPrep.
.sp
By default, when building the C driver libicu is linked if available. This can
be changed with the \fBENABLE_ICU\fP cmake option. To specify an installation
path of libicu, specify \fBICU_ROOT\fP as a cmake option. See the
\fI\%FindICU\fP documentation
for more information.
.SS Basic Authentication (SCRAM\-SHA\-1)
.sp
The default authentication mechanism before MongoDB 4.0 is \fBSCRAM\-SHA\-1\fP (\fI\%RFC 5802\fP). Using this authentication mechanism means that the password is never actually sent over the wire when authenticating, but rather a computed proof that the client password is the same as the password the server knows.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client = mongoc_client_new ("mongodb://user:password@localhost/?authMechanism=SCRAM\-SHA\-1&authSource=mydb");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBSCRAM\-SHA\-1\fP authenticates against the \fBadmin\fP database by default. If the user is created in another database, then specifying the authSource is required.
.UNINDENT
.UNINDENT
.SS Legacy Authentication (MONGODB\-CR)
.sp
The MONGODB\-CR authMechanism is deprecated and will no longer function in MongoDB 4.0. Instead, specify no authMechanism and the driver
will use an authentication mechanism compatible with your server.
.SS GSSAPI (Kerberos) Authentication
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Kerberos support requires compiling the driver against \fBcyrus\-sasl\fP on UNIX\-like environments. On Windows, configure the driver to build against the Windows Native SSPI.
.UNINDENT
.UNINDENT
.sp
\fBGSSAPI\fP (Kerberos) authentication is available in the Enterprise Edition of MongoDB. To authenticate using \fBGSSAPI\fP, the MongoDB C driver must be installed with SASL support.
.sp
On UNIX\-like environments, run the \fBkinit\fP command before using the following authentication methods:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ kinit mongodbuser@EXAMPLE.COM
mongodbuser@EXAMPLE.COM\(aqs Password:
$ klistCredentials cache: FILE:/tmp/krb5cc_1000
        Principal: mongodbuser@EXAMPLE.COM

  Issued                Expires               Principal
Feb  9 13:48:51 2013  Feb  9 23:48:51 2013  krbtgt/EXAMPLE.COM@EXAMPLE.COM
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Now authenticate using the MongoDB URI. \fBGSSAPI\fP authenticates against the \fB$external\fP virtual database, so a database does not need to be specified in the URI. Note that the Kerberos principal \fImust\fP be URL\-encoded:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client;

client = mongoc_client_new ("mongodb://mongodbuser%40EXAMPLE.COM@mongo\-server.example.com/?authMechanism=GSSAPI");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBGSSAPI\fP authenticates against the \fB$external\fP database, so specifying the authSource database is not required.
.UNINDENT
.UNINDENT
.sp
The driver supports these GSSAPI properties:
.INDENT 0.0
.IP \(bu 2
\fBCANONICALIZE_HOST_NAME\fP: This might be required with Cyrus\-SASL when the hosts report different hostnames than what is used in the Kerberos database. The default is "false".
.IP \(bu 2
\fBSERVICE_NAME\fP: Use a different service name than the default, "mongodb".
.UNINDENT
.sp
Set properties in the URL:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client;

client = mongoc_client_new ("mongodb://mongodbuser%40EXAMPLE.COM@mongo\-server.example.com/?authMechanism=GSSAPI&"
                            "authMechanismProperties=SERVICE_NAME:other,CANONICALIZE_HOST_NAME:true");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you encounter errors such as \fBInvalid net address\fP, check if the application is behind a NAT (Network Address Translation) firewall. If so, create a ticket that uses \fBforwardable\fP and \fBaddressless\fP Kerberos tickets. This can be done by passing \fB\-f \-A\fP to \fBkinit\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ kinit \-f \-A mongodbuser@EXAMPLE.COM
.ft P
.fi
.UNINDENT
.UNINDENT
.SS SASL Plain Authentication
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The MongoDB C Driver must be compiled with SASL support in order to use \fBSASL PLAIN\fP authentication.
.UNINDENT
.UNINDENT
.sp
MongoDB Enterprise Edition supports the \fBSASL PLAIN\fP authentication mechanism, initially intended for delegating authentication to an LDAP server. Using the \fBSASL PLAIN\fP mechanism is very similar to the challenge response mechanism with usernames and passwords. This authentication mechanism uses the \fB$external\fP virtual database for \fBLDAP\fP support:
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBSASL PLAIN\fP is a clear\-text authentication mechanism. It is strongly recommended to connect to MongoDB using TLS with certificate validation when using the \fBPLAIN\fP mechanism.
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client;

client = mongoc_client_new ("mongodb://user:password@example.com/?authMechanism=PLAIN");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBPLAIN\fP authenticates against the \fB$external\fP database, so specifying the authSource database is not required.
.SS X.509 Certificate Authentication
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The MongoDB C Driver must be compiled with TLS support for X.509 authentication support. Once this is done, start a server with the following options:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongod \-\-tlsMode requireTLS \-\-tlsCertificateKeyFile server.pem \-\-tlsCAFile ca.pem
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The \fBMONGODB\-X509\fP mechanism authenticates a username derived from the distinguished subject name of the X.509 certificate presented by the driver during TLS negotiation. This authentication method requires the use of TLS connections with certificate validation.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client;
mongoc_ssl_opt_t ssl_opts = { 0 };

ssl_opts.pem_file = "mycert.pem";
ssl_opts.pem_pwd = "mycertpassword";
ssl_opts.ca_file = "myca.pem";
ssl_opts.ca_dir = "trust_dir";
ssl_opts.weak_cert_validation = false;

client = mongoc_client_new ("mongodb://x509_derived_username@localhost/?authMechanism=MONGODB\-X509");
mongoc_client_set_ssl_opts (client, &ssl_opts);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBMONGODB\-X509\fP authenticates against the \fB$external\fP database, so specifying the authSource database is not required. For more information on the x509_derived_username, see the MongoDB server \fI\%x.509 tutorial\fP\&.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The MongoDB C Driver will attempt to determine the x509 derived username when none is provided, and as of MongoDB 3.4 providing the username is not required at all.
.UNINDENT
.UNINDENT
.SS Authentication via AWS IAM
.sp
The \fBMONGODB\-AWS\fP mechanism authenticates to MongoDB servers with credentials provided by AWS Identity and Access Management (IAM).
.sp
To authenticate, create a user with an associated Amazon Resource Name (ARN) on the \fB$external\fP database, and specify the \fBMONGODB\-AWS\fP \fBauthMechanism\fP in the URI.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_uri_t *uri = mongoc_uri_new ("mongodb://localhost/?authMechanism=MONGODB\-AWS");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Since \fBMONGODB\-AWS\fP always authenticates against the \fB$external\fP database, so specifying the authSource database is not required.
.sp
Credentials include the \fBaccess key id\fP, \fBsecret access key\fP, and optional \fBsession token\fP\&. They may be obtained from the following ways.
.SS AWS credentials via URI
.sp
Credentials may be passed directly in the URI as username/password.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_uri_t *uri = mongoc_uri_new ("mongodb://<access key id>:<secret access key>localhost/?authMechanism=MONGODB\-AWS");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This may include a \fBsession token\fP passed with \fBauthMechanismProperties\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_uri_t *uri = mongoc_uri_new ("mongodb://<access key id>:<secret access key>localhost/?authMechanism=MONGODB\-AWS&authMechanismProperties=AWS_SESSION_TOKEN:<token>");
.ft P
.fi
.UNINDENT
.UNINDENT
.SS AWS credentials via environment
.sp
If credentials are not passed through the URI, libmongoc will check for the following environment variables.
.INDENT 0.0
.IP \(bu 2
AWS_ACCESS_KEY_ID
.IP \(bu 2
AWS_SECRET_ACCESS_KEY
.IP \(bu 2
AWS_SESSION_TOKEN (optional)
.UNINDENT
.SS AWS Credentials via ECS
.sp
If credentials are not passed in the URI or with environment variables, libmongoc will check if the environment variable \fBAWS_CONTAINER_CREDENTIALS_RELATIVE_URI\fP is set, and if so, attempt to retrieve temporary credentials from the ECS task metadata by querying a link local address.
.SS AWS Credentials via EC2
.sp
If credentials are not passed in the URI or with environment variables, and the environment variable \fBAWS_CONTAINER_CREDENTIALS_RELATIVE_URI\fP is not set, libmongoc will attempt to retrieve temporary credentials from the EC2 machine metadata by querying link local addresses.
.SS Basic Troubleshooting
.SS Troubleshooting Checklist
.sp
The following is a short list of things to check when you have a problem.
.INDENT 0.0
.IP \(bu 2
Did you call \fBmongoc_init()\fP in \fBmain()\fP? If not, you will likely see a segfault.
.IP \(bu 2
Have you leaked any clients or cursors as can be found with \fBmongoc\-stat <PID>\fP?
.IP \(bu 2
Have packets been delivered to the server? See egress bytes from \fBmongoc\-stat <PID>\fP\&.
.IP \(bu 2
Does \fBvalgrind\fP show any leaks? Ensure you call \fBmongoc_cleanup()\fP at the end of your process to cleanup lingering allocations from the MongoDB C driver.
.IP \(bu 2
If compiling your own copy of MongoDB C Driver, consider using the cmake option \fB\-DENABLE_TRACING=ON\fP to enable function tracing and hex dumps of network packets to \fBSTDERR\fP and \fBSTDOUT\fP\&.
.UNINDENT
.SS Performance Counters
.sp
The MongoDB C driver comes with an optional unique feature to help developers and sysadmins troubleshoot problems in production.
Performance counters are available for each process using the driver.
If available, the counters can be accessed outside of the application process via a shared memory segment.
This means that you can graph statistics about your application process easily from tools like Munin or Nagios.
Your author often uses \fBwatch \-\-interval=0.5 \-d mongoc\-stat $PID\fP to monitor an application.
.sp
Performance counters are only available on Linux platforms and macOS arm64 platforms supporting shared memory segments.
On supported platforms they are enabled by default.
Applications can be built without the counters by specifying the cmake option \fB\-DENABLE_SHM_COUNTERS=OFF\fP\&. Additionally, if
performance counters are already compiled, they can be disabled at runtime by specifying the environment variable \fBMONGOC_DISABLE_SHM\fP\&.
.sp
Performance counters keep track of the following:
.INDENT 0.0
.IP \(bu 2
Active and Disposed Cursors
.IP \(bu 2
Active and Disposed Clients, Client Pools, and Socket Streams.
.IP \(bu 2
Number of operations sent and received, by type.
.IP \(bu 2
Bytes transferred and received.
.IP \(bu 2
Authentication successes and failures.
.IP \(bu 2
Number of wire protocol errors.
.UNINDENT
.sp
To access counters for a given process, simply provide the process id to the \fBmongoc\-stat\fP program installed with the MongoDB C Driver.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongoc\-stat 22203
   Operations : Egress Total        : The number of sent operations.                    : 13247
   Operations : Ingress Total       : The number of received operations.                : 13246
   Operations : Egress Queries      : The number of sent Query operations.              : 13247
   Operations : Ingress Queries     : The number of received Query operations.          : 0
   Operations : Egress GetMore      : The number of sent GetMore operations.            : 0
   Operations : Ingress GetMore     : The number of received GetMore operations.        : 0
   Operations : Egress Insert       : The number of sent Insert operations.             : 0
   Operations : Ingress Insert      : The number of received Insert operations.         : 0
   Operations : Egress Delete       : The number of sent Delete operations.             : 0
   Operations : Ingress Delete      : The number of received Delete operations.         : 0
   Operations : Egress Update       : The number of sent Update operations.             : 0
   Operations : Ingress Update      : The number of received Update operations.         : 0
   Operations : Egress KillCursors  : The number of sent KillCursors operations.        : 0
   Operations : Ingress KillCursors : The number of received KillCursors operations.    : 0
   Operations : Egress Msg          : The number of sent Msg operations.                : 0
   Operations : Ingress Msg         : The number of received Msg operations.            : 0
   Operations : Egress Reply        : The number of sent Reply operations.              : 0
   Operations : Ingress Reply       : The number of received Reply operations.          : 13246
      Cursors : Active              : The number of active cursors.                     : 1
      Cursors : Disposed            : The number of disposed cursors.                   : 13246
      Clients : Active              : The number of active clients.                     : 1
      Clients : Disposed            : The number of disposed clients.                   : 0
      Streams : Active              : The number of active streams.                     : 1
      Streams : Disposed            : The number of disposed streams.                   : 0
      Streams : Egress Bytes        : The number of bytes sent.                         : 794931
      Streams : Ingress Bytes       : The number of bytes received.                     : 589694
      Streams : N Socket Timeouts   : The number of socket timeouts.                    : 0
 Client Pools : Active              : The number of active client pools.                : 1
 Client Pools : Disposed            : The number of disposed client pools.              : 0
     Protocol : Ingress Errors      : The number of protocol errors on ingress.         : 0
         Auth : Failures            : The number of failed authentication requests.     : 0
         Auth : Success             : The number of successful authentication requests. : 0
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Submitting a Bug Report
.sp
Think you\(aqve found a bug? Want to see a new feature in the MongoDB C driver? Please open a case in our issue management tool, JIRA:
.INDENT 0.0
.IP \(bu 2
\fI\%Create an account and login\fP\&.
.IP \(bu 2
Navigate to \fI\%the CDRIVER project\fP\&.
.IP \(bu 2
Click \fICreate Issue\fP \- Please provide as much information as possible about the issue type and how to reproduce it.
.UNINDENT
.sp
Bug reports in JIRA for all driver projects (i.e. CDRIVER, CSHARP, JAVA) and the Core Server (i.e. SERVER) project are \fIpublic\fP\&.
.SS Guides
.SS Configuring TLS
.SS Configuration with URI options
.sp
Enable TLS by including \fBtls=true\fP in the URI.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_uri_t *uri = mongoc_uri_new ("mongodb://localhost:27017/");
mongoc_uri_set_option_as_bool (uri, MONGOC_URI_TLS, true);

mongoc_client_t *client = mongoc_client_new_from_uri (uri);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The following URI options may be used to further configure TLS:
.TS
center;
|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Description
T}
_
T{
MONGOC_URI_TLS
T}	T{
tls
T}	T{
{true|false}, indicating if TLS must be used.
T}
_
T{
MONGOC_URI_TLSCERTIFICATEKEYFILE
T}	T{
tlscertificatekeyfile
T}	T{
Path to PEM formatted Private Key, with its Public Certificate concatenated at the end.
T}
_
T{
MONGOC_URI_TLSCERTIFICATEKEYFILEPASSWORD
T}	T{
tlscertificatekeypassword
T}	T{
The password, if any, to use to unlock encrypted Private Key.
T}
_
T{
MONGOC_URI_TLSCAFILE
T}	T{
tlscafile
T}	T{
One, or a bundle of, Certificate Authorities whom should be considered to be trusted.
T}
_
T{
MONGOC_URI_TLSALLOWINVALIDCERTIFICATES
T}	T{
tlsallowinvalidcertificates
T}	T{
Accept and ignore certificate verification errors (e.g. untrusted issuer, expired, etc.)
T}
_
T{
MONGOC_URI_TLSALLOWINVALIDHOSTNAMES
T}	T{
tlsallowinvalidhostnames
T}	T{
Ignore hostname verification of the certificate (e.g. Man In The Middle, using valid certificate, but issued for another hostname)
T}
_
T{
MONGOC_URI_TLSINSECURE
T}	T{
tlsinsecure
T}	T{
{true|false}, indicating if insecure TLS options should be used. Currently this implies MONGOC_URI_TLSALLOWINVALIDCERTIFICATES and MONGOC_URI_TLSALLOWINVALIDHOSTNAMES.
T}
_
T{
MONGOC_URI_TLSDISABLECERTIFICATEREVOCATIONCHECK
T}	T{
tlsdisablecertificaterevocationcheck
T}	T{
{true|false}, indicates if revocation checking (CRL / OCSP) should be disabled.
T}
_
T{
MONGOC_URI_TLSDISABLEOCSPENDPOINTCHECK
T}	T{
tlsdisableocspendpointcheck
T}	T{
{true|false}, indicates if OCSP responder endpoints should not be requested when an OCSP response is not stapled.
T}
_
.TE
.SS Configuration with mongoc_ssl_opt_t
.sp
Alternatively, the \fBmongoc_ssl_opt_t\fP struct may be used to configure TLS with \fBmongoc_client_set_ssl_opts()\fP or \fBmongoc_client_pool_set_ssl_opts()\fP\&. Most of the configurable options can be set using the \fI\%Connection String URI\fP\&.
.TS
center;
|l|l|.
_
T{
\fBmongoc_ssl_opt_t key\fP
T}	T{
\fBURI key\fP
T}
_
T{
pem_file
T}	T{
tlsClientCertificateKeyFile
T}
_
T{
pem_pwd
T}	T{
tlsClientCertificateKeyPassword
T}
_
T{
ca_file
T}	T{
tlsCAFile
T}
_
T{
weak_cert_validation
T}	T{
tlsAllowInvalidCertificates
T}
_
T{
allow_invalid_hostname
T}	T{
tlsAllowInvalidHostnames
T}
_
.TE
.sp
The only exclusions are \fBcrl_file\fP and \fBca_dir\fP\&. Those may only be set with \fBmongoc_ssl_opt_t\fP\&.
.SS Client Authentication
.sp
When MongoDB is started with TLS enabled, it will by default require the client to provide a client certificate issued by a certificate authority specified by \fB\-\-tlsCAFile\fP, or an authority trusted by the native certificate store in use on the server.
.sp
To provide the client certificate, set the \fBtlsCertificateKeyFile\fP in the URI to a PEM armored certificate file.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_uri_t *uri = mongoc_uri_new ("mongodb://localhost:27017/");
mongoc_uri_set_option_as_bool (uri, MONGOC_URI_TLS, true);
mongoc_uri_set_option_as_utf8 (uri, MONGOC_URI_TLSCERTIFICATEKEYFILE, "/path/to/client\-certificate.pem");

mongoc_client_t *client = mongoc_client_new_from_uri (uri);
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Server Certificate Verification
.sp
The MongoDB C Driver will automatically verify the validity of the server certificate, such as issued by configured Certificate Authority, hostname validation, and expiration.
.sp
To overwrite this behavior, it is possible to disable hostname validation, OCSP endpoint revocation checking, revocation checking entirely, and allow invalid certificates.
.sp
This behavior is controlled using the \fBtlsAllowInvalidHostnames\fP, \fBtlsDisableOCSPEndpointCheck\fP, \fBtlsDisableCertificateRevocationCheck\fP, and \fBtlsAllowInvalidCertificates\fP options respectively. By default, all are set to \fBfalse\fP\&.
.sp
It is not recommended to change these defaults as it exposes the client to \fIMan In The Middle\fP attacks (when \fBtlsAllowInvalidHostnames\fP is set), invalid certificates (when \fBtlsAllowInvalidCertificates\fP is set), or potentially revoked certificates (when \fBtlsDisableOCSPEndpointCheck\fP or \fBtlsDisableCertificateRevocationCheck\fP are set).
.SS Supported Libraries
.sp
By default, libmongoc will attempt to find a supported TLS library and enable TLS support. This is controlled by the cmake flag \fBENABLE_SSL\fP, which is set to \fBAUTO\fP by default. Valid values are:
.INDENT 0.0
.IP \(bu 2
\fBAUTO\fP the default behavior. Link to the system\(aqs native TLS library, or attempt to find OpenSSL.
.IP \(bu 2
\fBDARWIN\fP link to Secure Transport, the native TLS library on macOS.
.IP \(bu 2
\fBWINDOWS\fP link to Secure Channel, the native TLS library on Windows.
.IP \(bu 2
\fBOPENSSL\fP link to OpenSSL (libssl). An optional install path may be specified with \fBOPENSSL_ROOT\fP\&.
.IP \(bu 2
\fBLIBRESSL\fP link to LibreSSL\(aqs libtls. (LibreSSL\(aqs compatible libssl may be linked to by setting \fBOPENSSL\fP).
.IP \(bu 2
\fBOFF\fP disable TLS support.
.UNINDENT
.SS OpenSSL
.sp
The MongoDB C Driver uses OpenSSL, if available, on Linux and Unix platforms (besides macOS). Industry best practices and some regulations require the use of TLS 1.1 or newer, which requires at least OpenSSL 1.0.1. Check your OpenSSL version like so:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ openssl version
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Ensure your system\(aqs OpenSSL is a recent version (at least 1.0.1), or install a recent version in a non\-system path and build against it with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cmake \-DOPENSSL_ROOT_DIR=/absolute/path/to/openssl
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When compiled against OpenSSL, the driver will attempt to load the system default certificate store, as configured by the distribution. That can be overridden by setting the \fBtlsCAFile\fP URI option or with the fields \fBca_file\fP and \fBca_dir\fP in the \fBmongoc_ssl_opt_t\fP\&.
.sp
The Online Certificate Status Protocol (OCSP) (see \fI\%RFC 6960\fP) is fully supported when using OpenSSL 1.0.1+ with the following notes:
.INDENT 0.0
.IP \(bu 2
When a \fBcrl_file\fP is set with \fBmongoc_ssl_opt_t\fP, and the \fBcrl_file\fP revokes the server\(aqs certificate, the certificate is considered revoked (even if the certificate has a valid stapled OCSP response)
.UNINDENT
.SS LibreSSL / libtls
.sp
The MongoDB C Driver supports LibreSSL through the use of OpenSSL compatibility checks when configured to compile against \fBopenssl\fP\&. It also supports the new \fBlibtls\fP library when configured to build against \fBlibressl\fP\&.
.sp
When compiled against the Windows native libraries, the \fBcrl_file\fP option of a \fBmongoc_ssl_opt_t\fP is not supported, and will issue an error if used.
.sp
Setting \fBtlsDisableOCSPEndpointCheck\fP and \fBtlsDisableCertificateRevocationCheck\fP has no effect.
.sp
The Online Certificate Status Protocol (OCSP) (see \fI\%RFC 6960\fP) is partially supported with the following notes:
.INDENT 0.0
.IP \(bu 2
The Must\-Staple extension (see \fI\%RFC 7633\fP) is ignored. Connection may continue if a Must\-Staple certificate is presented with no stapled response (unless the client receives a revoked response from an OCSP responder).
.IP \(bu 2
Connection will continue if a Must\-Staple certificate is presented without a stapled response and the OCSP responder is down.
.UNINDENT
.SS Native TLS Support on Windows (Secure Channel)
.sp
The MongoDB C Driver supports the Windows native TLS library (Secure Channel, or SChannel), and its native crypto library (Cryptography API: Next Generation, or CNG).
.sp
When compiled against the Windows native libraries, the \fBca_dir\fP option of a \fBmongoc_ssl_opt_t\fP is not supported, and will issue an error if used.
.sp
Encrypted PEM files (e.g., setting \fBtlsCertificateKeyPassword\fP) are also not supported, and will result in error when attempting to load them.
.sp
When \fBtlsCAFile\fP is set, the driver will only allow server certificates issued by the authority (or authorities) provided. When no \fBtlsCAFile\fP is set, the driver will look up the Certificate Authority using the \fBSystem Local Machine Root\fP certificate store to confirm the provided certificate.
.sp
When \fBcrl_file\fP is set with \fBmongoc_ssl_opt_t\fP, the driver will import the revocation list to the \fBSystem Local Machine Root\fP certificate store.
.sp
Setting \fBtlsDisableOCSPEndpointCheck\fP has no effect.
.sp
The Online Certificate Status Protocol (OCSP) (see \fI\%RFC 6960\fP) is partially supported with the following notes:
.INDENT 0.0
.IP \(bu 2
The Must\-Staple extension (see \fI\%RFC 7633\fP) is ignored. Connection may continue if a Must\-Staple certificate is presented with no stapled response (unless the client receives a revoked response from an OCSP responder).
.IP \(bu 2
When a \fBcrl_file\fP is set with \fBmongoc_ssl_opt_t\fP, and the \fBcrl_file\fP revokes the server\(aqs certificate, the OCSP response takes precedence. E.g. if the server presents a certificate with a valid stapled OCSP response, the certificate is considered valid even if the \fBcrl_file\fP marks it as revoked.
.IP \(bu 2
Connection will continue if a Must\-Staple certificate is presented without a stapled response and the OCSP responder is down.
.UNINDENT
.SS Native TLS Support on macOS / Darwin (Secure Transport)
.sp
The MongoDB C Driver supports the Darwin (OS X, macOS, iOS, etc.) native TLS library (Secure Transport), and its native crypto library (Common Crypto, or CC).
.sp
When compiled against Secure Transport, the \fBca_dir\fP and \fBcrl_file\fP options of a \fBmongoc_ssl_opt_t\fP are not supported. An error is issued if either are used.
.sp
When \fBtlsCAFile\fP is set, the driver will only allow server certificates issued by the authority (or authorities) provided. When no \fBtlsCAFile\fP is set, the driver will use the Certificate Authorities in the currently unlocked keychains.
.sp
Setting \fBtlsDisableOCSPEndpointCheck\fP and \fBtlsDisableCertificateRevocationCheck\fP has no effect.
.sp
The Online Certificate Status Protocol (OCSP) (see \fI\%RFC 6960\fP) is partially supported with the following notes.
.INDENT 0.0
.IP \(bu 2
The Must\-Staple extension (see \fI\%RFC 7633\fP) is ignored. Connection may continue if a Must\-Staple certificate is presented with no stapled response (unless the client receives a revoked response from an OCSP responder).
.IP \(bu 2
Connection will continue if a Must\-Staple certificate is presented without a stapled response and the OCSP responder is down.
.UNINDENT
.SS Common Tasks
.sp
Drivers for some other languages provide helper functions to perform certain common tasks. In the C Driver we must explicitly build commands to send to the server.
.SS Setup
.sp
First we\(aqll write some code to insert sample data:
.sp
doc\-common\-insert.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* Don\(aqt try to compile this file on its own. It\(aqs meant to be #included
   by example code */

/* Insert some sample data */
bool
insert_data (mongoc_collection_t *collection)
{
   mongoc_bulk_operation_t *bulk;
   enum N { ndocs = 4 };
   bson_t *docs[ndocs];
   bson_error_t error;
   int i = 0;
   bool ret;

   bulk = mongoc_collection_create_bulk_operation_with_opts (collection, NULL);

   docs[0] = BCON_NEW ("x", BCON_DOUBLE (1.0), "tags", "[", "dog", "cat", "]");
   docs[1] = BCON_NEW ("x", BCON_DOUBLE (2.0), "tags", "[", "cat", "]");
   docs[2] = BCON_NEW (
      "x", BCON_DOUBLE (2.0), "tags", "[", "mouse", "cat", "dog", "]");
   docs[3] = BCON_NEW ("x", BCON_DOUBLE (3.0), "tags", "[", "]");

   for (i = 0; i < ndocs; i++) {
      mongoc_bulk_operation_insert (bulk, docs[i]);
      bson_destroy (docs[i]);
      docs[i] = NULL;
   }

   ret = mongoc_bulk_operation_execute (bulk, NULL, &error);

   if (!ret) {
      fprintf (stderr, "Error inserting data: %s\en", error.message);
   }

   mongoc_bulk_operation_destroy (bulk);
   return ret;
}

/* A helper which we\(aqll use a lot later on */
void
print_res (const bson_t *reply)
{
   char *str;
   BSON_ASSERT (reply);
   str = bson_as_canonical_extended_json (reply, NULL);
   printf ("%s\en", str);
   bson_free (str);
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS "explain" Command
.sp
This is how to use the \fBexplain\fP command in MongoDB 3.2+:
.sp
explain.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bool
explain (mongoc_collection_t *collection)
{
   bson_t *command;
   bson_t reply;
   bson_error_t error;
   bool res;

   command = BCON_NEW ("explain",
                       "{",
                       "find",
                       BCON_UTF8 (COLLECTION_NAME),
                       "filter",
                       "{",
                       "x",
                       BCON_INT32 (1),
                       "}",
                       "}");
   res = mongoc_collection_command_simple (
      collection, command, NULL, &reply, &error);
   if (!res) {
      fprintf (stderr, "Error with explain: %s\en", error.message);
      goto cleanup;
   }

   /* Do something with the reply */
   print_res (&reply);

cleanup:
   bson_destroy (&reply);
   bson_destroy (command);
   return res;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Running the Examples
.sp
common\-operations.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/*
 * Copyright 2016 MongoDB, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE\-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include <mongoc/mongoc.h>
#include <stdio.h>


const char *COLLECTION_NAME = "things";

#include "../doc\-common\-insert.c"
#include "explain.c"


int
main (int argc, char *argv[])
{
   mongoc_database_t *database = NULL;
   mongoc_client_t *client = NULL;
   mongoc_collection_t *collection = NULL;
   mongoc_uri_t *uri = NULL;
   bson_error_t error;
   char *host_and_port;
   int res = 0;

   if (argc < 2 || argc > 3) {
      fprintf (stderr,
               "usage: %s MONGOD\-1\-CONNECTION\-STRING "
               "[MONGOD\-2\-HOST\-NAME:MONGOD\-2\-PORT]\en",
               argv[0]);
      fprintf (stderr,
               "MONGOD\-1\-CONNECTION\-STRING can be "
               "of the following forms:\en");
      fprintf (stderr, "localhost\et\et\et\etlocal machine\en");
      fprintf (stderr, "localhost:27018\et\et\et\etlocal machine on port 27018\en");
      fprintf (stderr,
               "mongodb://user:pass@localhost:27017\et"
               "local machine on port 27017, and authenticate with username "
               "user and password pass\en");
      return EXIT_FAILURE;
   }

   mongoc_init ();

   if (strncmp (argv[1], "mongodb://", 10) == 0) {
      host_and_port = bson_strdup (argv[1]);
   } else {
      host_and_port = bson_strdup_printf ("mongodb://%s", argv[1]);
   }

   uri = mongoc_uri_new_with_error (host_and_port, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               host_and_port,
               error.message);
      res = EXIT_FAILURE;
      goto cleanup;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      res = EXIT_FAILURE;
      goto cleanup;
   }

   mongoc_client_set_error_api (client, 2);
   database = mongoc_client_get_database (client, "test");
   collection = mongoc_database_get_collection (database, COLLECTION_NAME);

   printf ("Inserting data\en");
   if (!insert_data (collection)) {
      res = EXIT_FAILURE;
      goto cleanup;
   }

   printf ("explain\en");
   if (!explain (collection)) {
      res = EXIT_FAILURE;
      goto cleanup;
   }

cleanup:
   if (collection) {
      mongoc_collection_destroy (collection);
   }

   if (database) {
      mongoc_database_destroy (database);
   }

   if (client) {
      mongoc_client_destroy (client);
   }

   if (uri) {
      mongoc_uri_destroy (uri);
   }

   bson_free (host_and_port);
   mongoc_cleanup ();
   return res;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
First launch two separate instances of mongod (must be done from separate shells):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongod
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mkdir /tmp/db2
$ mongod \-\-dbpath /tmp/db2 \-\-port 27018 # second instance
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Now compile and run the example program:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd examples/common_operations/$ gcc \-Wall \-o example common\-operations.c $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0)$ ./example localhost:27017 localhost:27018
Inserting data
explain
{
   "executionStats" : {
      "allPlansExecution" : [],
      "executionStages" : {
         "advanced" : 19,
         "direction" : "forward" ,
         "docsExamined" : 76,
         "executionTimeMillisEstimate" : 0,
         "filter" : {
            "x" : {
               "$eq" : 1
            }
         },
         "invalidates" : 0,
         "isEOF" : 1,
         "nReturned" : 19,
         "needTime" : 58,
         "needYield" : 0,
         "restoreState" : 0,
         "saveState" : 0,
         "stage" : "COLLSCAN" ,
         "works" : 78
      },
      "executionSuccess" : true,
      "executionTimeMillis" : 0,
      "nReturned" : 19,
      "totalDocsExamined" : 76,
      "totalKeysExamined" : 0
   },
   "ok" : 1,
   "queryPlanner" : {
      "indexFilterSet" : false,
      "namespace" : "test.things",
      "parsedQuery" : {
         "x" : {
            "$eq" : 1
         }
      },
      "plannerVersion" : 1,
      "rejectedPlans" : [],
      "winningPlan" : {
         "direction" : "forward" ,
         "filter" : {
            "x" : {
               "$eq" : 1
            }
         },
         "stage" : "COLLSCAN"
      }
   },
   "serverInfo" : {
      "gitVersion" : "05552b562c7a0b3143a729aaa0838e558dc49b25" ,
      "host" : "MacBook\-Pro\-57.local",
      "port" : 27017,
      "version" : "3.2.6"
   }
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Advanced Connections
.sp
The following guide contains information specific to certain types of MongoDB configurations.
.sp
For an example of connecting to a simple standalone server, see the Tutorial\&. To establish a connection with authentication options enabled, see the Authentication page.
.SS Connecting to a Replica Set
.sp
Connecting to a \fI\%replica set\fP is much like connecting to a standalone MongoDB server. Simply specify the replica set name using the \fB?replicaSet=myreplset\fP URI option.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;

   mongoc_init ();

   /* Create our MongoDB Client */
   client = mongoc_client_new (
      "mongodb://host01:27017,host02:27017,host03:27017/?replicaSet=myreplset");

   /* Do some work */
   /* TODO */

   /* Clean up */
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBTIP:\fP
.INDENT 0.0
.INDENT 3.5
Multiple hostnames can be specified in the MongoDB connection string URI, with a comma separating hosts in the seed list.
.sp
It is recommended to use a seed list of members of the replica set to allow the driver to connect to any node.
.UNINDENT
.UNINDENT
.SS Connecting to a Sharded Cluster
.sp
To connect to a \fI\%sharded cluster\fP, specify the \fBmongos\fP nodes the client should connect to. The C Driver will automatically detect that it has connected to a \fBmongos\fP sharding server.
.sp
If more than one hostname is specified, a seed list will be created to attempt failover between the \fBmongos\fP instances.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
Specifying the \fBreplicaSet\fP parameter when connecting to a \fBmongos\fP sharding server is invalid.
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;

   mongoc_init ();

   /* Create our MongoDB Client */
   client = mongoc_client_new ("mongodb://myshard01:27017/");

   /* Do something with client ... */

   /* Free the client */
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Connecting to an IPv6 Address
.sp
The MongoDB C Driver will automatically resolve IPv6 addresses from host names. However, to specify an IPv6 address directly, wrap the address in \fB[]\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_uri_t *uri = mongoc_uri_new ("mongodb://[::1]:27017");
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Connecting with IPv4 and IPv6
.sp
If connecting to a hostname that has both IPv4 and IPv6 DNS records, the behavior follows \fI\%RFC\-6555\fP\&. A connection to the IPv6 address is attempted first. If IPv6 fails, then a connection is attempted to the IPv4 address. If the connection attempt to IPv6 does not complete within 250ms, then IPv4 is tried in parallel. Whichever succeeds connection first cancels the other. The successful DNS result is cached for 10 minutes.
.sp
As a consequence, attempts to connect to a mongod only listening on IPv4 may be delayed if there are both A (IPv4) and AAAA (IPv6) DNS records associated with the host.
.sp
To avoid a delay, configure hostnames to match the MongoDB configuration. That is, only create an A record if the mongod is only listening on IPv4.
.SS Connecting to a UNIX Domain Socket
.sp
On UNIX\-like systems, the C Driver can connect directly to a MongoDB server using a UNIX domain socket. Pass the URL\-encoded path to the socket, which \fImust\fP be suffixed with \fB\&.sock\fP\&. For example, to connect to a domain socket at \fB/tmp/mongodb\-27017.sock\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_uri_t *uri = mongoc_uri_new ("mongodb://%2Ftmp%2Fmongodb\-27017.sock");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Include username and password like so:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_uri_t *uri = mongoc_uri_new ("mongodb://user:pass@%2Ftmp%2Fmongodb\-27017.sock");
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Connecting to a server over TLS
.sp
These are instructions for configuring TLS/SSL connections.
.sp
To run a server locally (on port 27017, for example):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongod \-\-port 27017 \-\-tlsMode requireTLS \-\-tlsCertificateKeyFile server.pem \-\-tlsCAFile ca.pem
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Add \fB/?tls=true\fP to the end of a client URI.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client = NULL;
client = mongoc_client_new ("mongodb://localhost:27017/?tls=true");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
MongoDB requires client certificates by default, unless the \fB\-\-tlsAllowConnectionsWithoutCertificates\fP is provided. The C Driver can be configured to present a client certificate using the URI option \fBtlsCertificateKeyFile\fP, which may be referenced through the constant \fBMONGOC_URI_TLSCERTIFICATEKEYFILE\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client = NULL;
mongoc_uri_t *uri = mongoc_uri_new ("mongodb://localhost:27017/?tls=true");
mongoc_uri_set_option_as_utf8 (uri, MONGOC_URI_TLSCERTIFICATEKEYFILE, "client.pem");

client = mongoc_client_new_from_uri (uri);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The client certificate provided by \fBtlsCertificateKeyFile\fP must be issued by one of the server trusted Certificate Authorities listed in \fB\-\-tlsCAFile\fP, or issued by a CA in the native certificate store on the server when omitted.
.sp
See configuring_tls for more information on the various TLS related options.
.SS Compressing data to and from MongoDB
.sp
MongoDB 3.4 added Snappy compression support, zlib compression in 3.6, and zstd compression in 4.2.
To enable compression support the client must be configured with which compressors to use:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client = NULL;
client = mongoc_client_new ("mongodb://localhost:27017/?compressors=snappy,zlib,zstd");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBcompressors\fP option specifies the priority order of compressors the
client wants to use. Messages are compressed if the client and server share any
compressors in common.
.sp
Note that the compressor used by the server might not be the same compressor as
the client used.  For example, if the client uses the connection string
\fBcompressors=zlib,snappy\fP the client will use \fBzlib\fP compression to send
data (if possible), but the server might still reply using \fBsnappy\fP,
depending on how the server was configured.
.sp
The driver must be built with zlib and/or snappy and/or zstd support to enable compression
support, any unknown (or not compiled in) compressor value will be ignored. Note: to build with zstd requires cmake 3.12 or higher.
.SS Additional Connection Options
.sp
The full list of connection options can be found in the \fBmongoc_uri_t\fP docs.
.sp
Certain socket/connection related options are not configurable:
.TS
center;
|l|l|l|.
_
T{
Option
T}	T{
Description
T}	T{
Value
T}
_
T{
SO_KEEPALIVE
T}	T{
TCP Keep Alive
T}	T{
Enabled
T}
_
T{
TCP_KEEPIDLE
T}	T{
How long a connection needs to remain idle before TCP
starts sending keepalive probes
T}	T{
120 seconds
T}
_
T{
TCP_KEEPINTVL
T}	T{
The time in seconds between TCP probes
T}	T{
10 seconds
T}
_
T{
TCP_KEEPCNT
T}	T{
How many probes to send, without acknowledgement,
before dropping the connection
T}	T{
9 probes
T}
_
T{
TCP_NODELAY
T}	T{
Send packets as soon as possible or buffer small
packets (Nagle algorithm)
T}	T{
Enabled (no buffering)
T}
_
.TE
.SS Connection Pooling
.sp
The MongoDB C driver has two connection modes: single\-threaded and pooled. Single\-threaded mode is optimized for embedding the driver within languages like PHP. Multi\-threaded programs should use pooled mode: this mode minimizes the total connection count, and in pooled mode background threads monitor the MongoDB server topology, so the program need not block to scan it.
.SS Single Mode
.sp
In single mode, your program creates a \fBmongoc_client_t\fP directly:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client = mongoc_client_new (
   "mongodb://hostA,hostB/?replicaSet=my_rs");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The client connects on demand when your program first uses it for a MongoDB operation. Using a non\-blocking socket per server, it begins a check on each server concurrently, and uses the asynchronous \fBpoll\fP or \fBselect\fP function to receive events from the sockets, until all have responded or timed out. Put another way, in single\-threaded mode the C Driver fans out to begin all checks concurrently, then fans in once all checks have completed or timed out. Once the scan completes, the client executes your program\(aqs operation and returns.
.sp
In single mode, the client re\-scans the server topology roughly once per minute. If more than a minute has elapsed since the previous scan, the next operation on the client will block while the client completes its scan. This interval is configurable with \fBheartbeatFrequencyMS\fP in the connection string. (See \fBmongoc_uri_t\fP\&.)
.sp
A single client opens one connection per server in your topology: these connections are used both for scanning the topology and performing normal operations.
.SS Pooled Mode
.sp
To activate pooled mode, create a \fBmongoc_client_pool_t\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_uri_t *uri = mongoc_uri_new (
   "mongodb://hostA,hostB/?replicaSet=my_rs");

mongoc_client_pool_t *pool = mongoc_client_pool_new (uri);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When your program first calls \fBmongoc_client_pool_pop\fP, the pool launches monitoring threads in the background. Monitoring threads independently connect to all servers in the connection string. As monitoring threads receive hello responses from the servers, they update the shared view of the server topology. Additional monitoring threads and connections are created as new servers are discovered. Monitoring threads are terminated when servers are removed from the shared view of the server topology.
.sp
Each thread that executes MongoDB operations must check out a client from the pool:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_client_t *client = mongoc_client_pool_pop (pool);

/* use the client for operations ... */

mongoc_client_pool_push (pool, client);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBmongoc_client_t\fP object is not thread\-safe, only the \fBmongoc_client_pool_t\fP is.
.sp
When the driver is in pooled mode, your program\(aqs operations are unblocked as soon as monitoring discovers a usable server. For example, if a thread in your program is waiting to execute an "insert" on the primary, it is unblocked as soon as the primary is discovered, rather than waiting for all secondaries to be checked as well.
.sp
The pool opens one connection per server for monitoring, and each client opens its own connection to each server it uses for application operations. Background monitoring threads re\-scan servers independently roughly every 10 seconds. This interval is configurable with \fBheartbeatFrequencyMS\fP in the connection string. (See \fBmongoc_uri_t\fP\&.)
.sp
The connection string can also specify \fBwaitQueueTimeoutMS\fP to limit the time that \fBmongoc_client_pool_pop\fP will wait for a client from the pool.  (See \fBmongoc_uri_t\fP\&.)  If \fBwaitQueueTimeoutMS\fP is specified, then it is necessary to confirm that a client was actually returned:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_uri_t *uri = mongoc_uri_new (
   "mongodb://hostA,hostB/?replicaSet=my_rs&waitQueueTimeoutMS=1000");

mongoc_client_pool_t *pool = mongoc_client_pool_new (uri);

mongoc_client_t *client = mongoc_client_pool_pop (pool);

if (client) {
   /* use the client for operations ... */

   mongoc_client_pool_push (pool, client);
} else {
   /* take appropriate action for a timeout */
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
See connection_pool_options to configure pool size and behavior, and see \fBmongoc_client_pool_t\fP for an extended example of a multi\-threaded program that uses the driver in pooled mode.
.SS Cursors
.SS Handling Cursor Failures
.sp
Cursors exist on a MongoDB server. However, the \fBmongoc_cursor_t\fP structure gives the local process a handle to the cursor. It is possible for errors to occur on the server while iterating a cursor on the client. Even a network partition may occur. This means that applications should be robust in handling cursor failures.
.sp
While iterating cursors, you should check to see if an error has occurred. See the following example for how to robustly check for errors.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
static void
print_all_documents (mongoc_collection_t *collection)
{
   mongoc_cursor_t *cursor;
   const bson_t *doc;
   bson_error_t error;
   bson_t query = BSON_INITIALIZER;
   char *str;

   cursor = mongoc_collection_find_with_opts (collection, query, NULL, NULL);

   while (mongoc_cursor_next (cursor, &doc)) {
      str = bson_as_canonical_extended_json (doc, NULL);
      printf ("%s\en", str);
      bson_free (str);
   }

   if (mongoc_cursor_error (cursor, &error)) {
      fprintf (stderr, "Failed to iterate all documents: %s\en", error.message);
   }

   mongoc_cursor_destroy (cursor);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Destroying Server\-Side Cursors
.sp
The MongoDB C driver will automatically destroy a server\-side cursor when \fBmongoc_cursor_destroy()\fP is called. Failure to call this function when done with a cursor will leak memory client side as well as consume extra memory server side. If the cursor was configured to never timeout, it will become a memory leak on the server.
.SS Tailable Cursors
.sp
Tailable cursors are cursors that remain open even after they\(aqve returned a final result. This way, if more documents are added to a collection (i.e., to the cursor\(aqs result set), then you can continue to call \fBmongoc_cursor_next()\fP to retrieve those additional results.
.sp
Here\(aqs a complete test case that demonstrates the use of tailable cursors.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Tailable cursors are for capped collections only.
.UNINDENT
.UNINDENT
.sp
An example to tail the oplog from a replica set.
.sp
mongoc\-tail.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef _WIN32
#define sleep(_n) Sleep ((_n) *1000)
#endif


static void
print_bson (const bson_t *b)
{
   char *str;

   str = bson_as_canonical_extended_json (b, NULL);
   fprintf (stdout, "%s\en", str);
   bson_free (str);
}


static mongoc_cursor_t *
query_collection (mongoc_collection_t *collection, uint32_t last_time)
{
   mongoc_cursor_t *cursor;
   bson_t query;
   bson_t gt;
   bson_t opts;

   BSON_ASSERT (collection);

   bson_init (&query);
   BSON_APPEND_DOCUMENT_BEGIN (&query, "ts", &gt);
   BSON_APPEND_TIMESTAMP (&gt, "$gt", last_time, 0);
   bson_append_document_end (&query, &gt);

   bson_init (&opts);
   BSON_APPEND_BOOL (&opts, "tailable", true);
   BSON_APPEND_BOOL (&opts, "awaitData", true);

   cursor = mongoc_collection_find_with_opts (collection, &query, &opts, NULL);

   bson_destroy (&query);
   bson_destroy (&opts);

   return cursor;
}


static void
tail_collection (mongoc_collection_t *collection)
{
   mongoc_cursor_t *cursor;
   uint32_t last_time;
   const bson_t *doc;
   bson_error_t error;
   bson_iter_t iter;

   BSON_ASSERT (collection);

   last_time = (uint32_t) time (NULL);

   while (true) {
      cursor = query_collection (collection, last_time);
      while (!mongoc_cursor_error (cursor, &error) &&
             mongoc_cursor_more (cursor)) {
         if (mongoc_cursor_next (cursor, &doc)) {
            if (bson_iter_init_find (&iter, doc, "ts") &&
                BSON_ITER_HOLDS_TIMESTAMP (&iter)) {
               bson_iter_timestamp (&iter, &last_time, NULL);
            }
            print_bson (doc);
         }
      }
      if (mongoc_cursor_error (cursor, &error)) {
         if (error.domain == MONGOC_ERROR_SERVER) {
            fprintf (stderr, "%s\en", error.message);
            exit (1);
         }
      }

      mongoc_cursor_destroy (cursor);
      sleep (1);
   }
}


int
main (int argc, char *argv[])
{
   mongoc_collection_t *collection;
   mongoc_client_t *client;
   mongoc_uri_t *uri;
   bson_error_t error;

   if (argc != 2) {
      fprintf (stderr, "usage: %s MONGO_URI\en", argv[0]);
      return EXIT_FAILURE;
   }

   mongoc_init ();

   uri = mongoc_uri_new_with_error (argv[1], &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               argv[1],
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);

   collection = mongoc_client_get_collection (client, "local", "oplog.rs");

   tail_collection (collection);

   mongoc_collection_destroy (collection);
   mongoc_uri_destroy (uri);
   mongoc_client_destroy (client);

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Let\(aqs compile and run this example against a replica set to see updates as they are made.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-Wall \-o mongoc\-tail mongoc\-tail.c $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0)
$ ./mongoc\-tail mongodb://example.com/?replicaSet=myReplSet
{
    "h" : \-8458503739429355503,
    "ns" : "test.test",
    "o" : {
        "_id" : {
            "$oid" : "5372ab0a25164be923d10d50"
        }
    },
    "op" : "i",
    "ts" : {
        "$timestamp" : {
            "i" : 1,
            "t" : 1400023818
        }
    },
    "v" : 2
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The line of output is a sample from performing \fBdb.test.insert({})\fP from the mongo shell on the replica set.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fBmongoc_cursor_set_max_await_time_ms\fP\&.
.fi
.sp
.UNINDENT
.UNINDENT
.SS Bulk Write Operations
.sp
This tutorial explains how to take advantage of MongoDB C driver bulk write operation features. Executing write operations in batches reduces the number of network round trips, increasing write throughput.
.SS Bulk Insert
.sp
First we need to fetch a bulk operation handle from the \fBmongoc_collection_t\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_bulk_operation_t *bulk =
   mongoc_collection_create_bulk_operation_with_opts (collection, NULL);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
We can now start inserting documents to the bulk operation. These will be buffered until we execute the operation.
.sp
The bulk operation will coalesce insertions as a single batch for each consecutive call to \fBmongoc_bulk_operation_insert()\fP\&. This creates a pipelined effect when possible.
.sp
To execute the bulk operation and receive the result we call \fBmongoc_bulk_operation_execute()\fP\&.
.sp
bulk1.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <assert.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

static void
bulk1 (mongoc_collection_t *collection)
{
   mongoc_bulk_operation_t *bulk;
   bson_error_t error;
   bson_t *doc;
   bson_t reply;
   char *str;
   bool ret;
   int i;

   bulk = mongoc_collection_create_bulk_operation_with_opts (collection, NULL);

   for (i = 0; i < 10000; i++) {
      doc = BCON_NEW ("i", BCON_INT32 (i));
      mongoc_bulk_operation_insert (bulk, doc);
      bson_destroy (doc);
   }

   ret = mongoc_bulk_operation_execute (bulk, &reply, &error);

   str = bson_as_canonical_extended_json (&reply, NULL);
   printf ("%s\en", str);
   bson_free (str);

   if (!ret) {
      fprintf (stderr, "Error: %s\en", error.message);
   }

   bson_destroy (&reply);
   mongoc_bulk_operation_destroy (bulk);
}

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   const char *uri_string = "mongodb://localhost/?appname=bulk1\-example";
   mongoc_uri_t *uri;
   bson_error_t error;

   mongoc_init ();

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   collection = mongoc_client_get_collection (client, "test", "test");

   bulk1 (collection);

   mongoc_uri_destroy (uri);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Example \fBreply\fP document:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{"nInserted"   : 10000,
 "nMatched"    : 0,
 "nModified"   : 0,
 "nRemoved"    : 0,
 "nUpserted"   : 0,
 "writeErrors" : []
 "writeConcernErrors" : [] }
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Mixed Bulk Write Operations
.sp
MongoDB C driver also supports executing mixed bulk write operations. A batch of insert, update, and remove operations can be executed together using the bulk write operations API.
.SS Ordered Bulk Write Operations
.sp
Ordered bulk write operations are batched and sent to the server in the order provided for serial execution. The \fBreply\fP document describes the type and count of operations performed.
.sp
bulk2.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <assert.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

static void
bulk2 (mongoc_collection_t *collection)
{
   mongoc_bulk_operation_t *bulk;
   bson_error_t error;
   bson_t *query;
   bson_t *doc;
   bson_t *opts;
   bson_t reply;
   char *str;
   bool ret;
   int i;

   bulk = mongoc_collection_create_bulk_operation_with_opts (collection, NULL);

   /* Remove everything */
   query = bson_new ();
   mongoc_bulk_operation_remove (bulk, query);
   bson_destroy (query);

   /* Add a few documents */
   for (i = 1; i < 4; i++) {
      doc = BCON_NEW ("_id", BCON_INT32 (i));
      mongoc_bulk_operation_insert (bulk, doc);
      bson_destroy (doc);
   }

   /* {_id: 1} => {$set: {foo: "bar"}} */
   query = BCON_NEW ("_id", BCON_INT32 (1));
   doc = BCON_NEW ("$set", "{", "foo", BCON_UTF8 ("bar"), "}");
   mongoc_bulk_operation_update_many_with_opts (bulk, query, doc, NULL, &error);
   bson_destroy (query);
   bson_destroy (doc);

   /* {_id: 4} => {\(aq$inc\(aq: {\(aqj\(aq: 1}} (upsert) */
   opts = BCON_NEW ("upsert", BCON_BOOL (true));
   query = BCON_NEW ("_id", BCON_INT32 (4));
   doc = BCON_NEW ("$inc", "{", "j", BCON_INT32 (1), "}");
   mongoc_bulk_operation_update_many_with_opts (bulk, query, doc, opts, &error);
   bson_destroy (query);
   bson_destroy (doc);
   bson_destroy (opts);

   /* replace {j:1} with {j:2} */
   query = BCON_NEW ("j", BCON_INT32 (1));
   doc = BCON_NEW ("j", BCON_INT32 (2));
   mongoc_bulk_operation_replace_one_with_opts (bulk, query, doc, NULL, &error);
   bson_destroy (query);
   bson_destroy (doc);

   ret = mongoc_bulk_operation_execute (bulk, &reply, &error);

   str = bson_as_canonical_extended_json (&reply, NULL);
   printf ("%s\en", str);
   bson_free (str);

   if (!ret) {
      printf ("Error: %s\en", error.message);
   }

   bson_destroy (&reply);
   mongoc_bulk_operation_destroy (bulk);
}

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   const char *uri_string = "mongodb://localhost/?appname=bulk2\-example";
   mongoc_uri_t *uri;
   bson_error_t error;

   mongoc_init ();

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   collection = mongoc_client_get_collection (client, "test", "test");

   bulk2 (collection);

   mongoc_uri_destroy (uri);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Example \fBreply\fP document:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "nInserted"   : 3,
  "nMatched"    : 2,
  "nModified"   : 2,
  "nRemoved"    : 10000,
  "nUpserted"   : 1,
  "upserted"    : [{"index" : 5, "_id" : 4}],
  "writeErrors" : []
  "writeConcernErrors" : [] }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBindex\fP field in the \fBupserted\fP array is the 0\-based index of the upsert operation; in this example, the sixth operation of the overall bulk operation was an upsert, so its index is 5.
.SS Unordered Bulk Write Operations
.sp
Unordered bulk write operations are batched and sent to the server in \fIarbitrary order\fP where they may be executed in parallel. Any errors that occur are reported after all operations are attempted.
.sp
In the next example the first and third operations fail due to the unique constraint on \fB_id\fP\&. Since we are doing unordered execution the second and fourth operations succeed.
.sp
bulk3.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <assert.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

static void
bulk3 (mongoc_collection_t *collection)
{
   bson_t opts = BSON_INITIALIZER;
   mongoc_bulk_operation_t *bulk;
   bson_error_t error;
   bson_t *query;
   bson_t *doc;
   bson_t reply;
   char *str;
   bool ret;

   /* false indicates unordered */
   BSON_APPEND_BOOL (&opts, "ordered", false);
   bulk = mongoc_collection_create_bulk_operation_with_opts (collection, &opts);
   bson_destroy (&opts);

   /* Add a document */
   doc = BCON_NEW ("_id", BCON_INT32 (1));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   /* remove {_id: 2} */
   query = BCON_NEW ("_id", BCON_INT32 (2));
   mongoc_bulk_operation_remove_one (bulk, query);
   bson_destroy (query);

   /* insert {_id: 3} */
   doc = BCON_NEW ("_id", BCON_INT32 (3));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   /* replace {_id:4} {\(aqi\(aq: 1} */
   query = BCON_NEW ("_id", BCON_INT32 (4));
   doc = BCON_NEW ("i", BCON_INT32 (1));
   mongoc_bulk_operation_replace_one (bulk, query, doc, false);
   bson_destroy (query);
   bson_destroy (doc);

   ret = mongoc_bulk_operation_execute (bulk, &reply, &error);

   str = bson_as_canonical_extended_json (&reply, NULL);
   printf ("%s\en", str);
   bson_free (str);

   if (!ret) {
      printf ("Error: %s\en", error.message);
   }

   bson_destroy (&reply);
   mongoc_bulk_operation_destroy (bulk);
   bson_destroy (&opts);
}

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   const char *uri_string = "mongodb://localhost/?appname=bulk3\-example";
   mongoc_uri_t *uri;
   bson_error_t error;

   mongoc_init ();

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   collection = mongoc_client_get_collection (client, "test", "test");

   bulk3 (collection);

   mongoc_uri_destroy (uri);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Example \fBreply\fP document:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "nInserted"    : 0,
  "nMatched"     : 1,
  "nModified"    : 1,
  "nRemoved"     : 1,
  "nUpserted"    : 0,
  "writeErrors"  : [
    { "index"  : 0,
      "code"   : 11000,
      "errmsg" : "E11000 duplicate key error index: test.test.$_id_ dup key: { : 1 }" },
    { "index"  : 2,
      "code"   : 11000,
      "errmsg" : "E11000 duplicate key error index: test.test.$_id_ dup key: { : 3 }" } ],
  "writeConcernErrors" : [] }

Error: E11000 duplicate key error index: test.test.$_id_ dup key: { : 1 }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBbson_error_t\fP domain is \fBMONGOC_ERROR_COMMAND\fP and its code is 11000.
.SS Bulk Operation Bypassing Document Validation
.sp
This feature is only available when using MongoDB 3.2 and later.
.sp
By default bulk operations are validated against the schema, if any is defined. In certain cases however it may be necessary to bypass the document validation.
.sp
bulk5.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <assert.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

static void
bulk5_fail (mongoc_collection_t *collection)
{
   mongoc_bulk_operation_t *bulk;
   bson_error_t error;
   bson_t *doc;
   bson_t reply;
   char *str;
   bool ret;

   bulk = mongoc_collection_create_bulk_operation_with_opts (collection, NULL);

   /* Two inserts */
   doc = BCON_NEW ("_id", BCON_INT32 (31));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   doc = BCON_NEW ("_id", BCON_INT32 (32));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   /* The above documents do not comply to the schema validation rules
    * we created previously, so this will result in an error */
   ret = mongoc_bulk_operation_execute (bulk, &reply, &error);

   str = bson_as_canonical_extended_json (&reply, NULL);
   printf ("%s\en", str);
   bson_free (str);

   if (!ret) {
      printf ("Error: %s\en", error.message);
   }

   bson_destroy (&reply);
   mongoc_bulk_operation_destroy (bulk);
}

static void
bulk5_success (mongoc_collection_t *collection)
{
   mongoc_bulk_operation_t *bulk;
   bson_error_t error;
   bson_t *doc;
   bson_t reply;
   char *str;
   bool ret;

   bulk = mongoc_collection_create_bulk_operation_with_opts (collection, NULL);

   /* Allow this document to bypass document validation.
    * NOTE: When authentication is enabled, the authenticated user must have
    * either the "dbadmin" or "restore" roles to bypass document validation */
   mongoc_bulk_operation_set_bypass_document_validation (bulk, true);

   /* Two inserts */
   doc = BCON_NEW ("_id", BCON_INT32 (31));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   doc = BCON_NEW ("_id", BCON_INT32 (32));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   ret = mongoc_bulk_operation_execute (bulk, &reply, &error);

   str = bson_as_canonical_extended_json (&reply, NULL);
   printf ("%s\en", str);
   bson_free (str);

   if (!ret) {
      printf ("Error: %s\en", error.message);
   }

   bson_destroy (&reply);
   mongoc_bulk_operation_destroy (bulk);
}

int
main (int argc, char *argv[])
{
   bson_t *options;
   bson_error_t error;
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   mongoc_database_t *database;
   const char *uri_string = "mongodb://localhost/?appname=bulk5\-example";
   mongoc_uri_t *uri;

   mongoc_init ();

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   database = mongoc_client_get_database (client, "testasdf");

   /* Create schema validator */
   options = BCON_NEW (
      "validator", "{", "number", "{", "$gte", BCON_INT32 (5), "}", "}");
   collection =
      mongoc_database_create_collection (database, "collname", options, &error);

   if (collection) {
      bulk5_fail (collection);
      bulk5_success (collection);
      mongoc_collection_destroy (collection);
   } else {
      fprintf (stderr, "Couldn\(aqt create collection: \(aq%s\(aq\en", error.message);
   }

   bson_free (options);
   mongoc_uri_destroy (uri);
   mongoc_database_destroy (database);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Running the above example will result in:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "nInserted" : 0,
  "nMatched" : 0,
  "nModified" : 0,
  "nRemoved" : 0,
  "nUpserted" : 0,
  "writeErrors" : [
    { "index" : 0,
      "code" : 121,
      "errmsg" : "Document failed validation" } ] }

Error: Document failed validation

{ "nInserted" : 2,
  "nMatched" : 0,
  "nModified" : 0,
  "nRemoved" : 0,
  "nUpserted" : 0,
  "writeErrors" : [] }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBbson_error_t\fP domain is \fBMONGOC_ERROR_COMMAND\fP\&.
.SS Bulk Operation Write Concerns
.sp
By default bulk operations are executed with the \fBwrite_concern\fP of the collection they are executed against. A custom write concern can be passed to the \fBmongoc_collection_create_bulk_operation_with_opts()\fP method. Write concern errors (e.g. wtimeout) will be reported after all operations are attempted, regardless of execution order.
.sp
bulk4.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <assert.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

static void
bulk4 (mongoc_collection_t *collection)
{
   bson_t opts = BSON_INITIALIZER;
   mongoc_write_concern_t *wc;
   mongoc_bulk_operation_t *bulk;
   bson_error_t error;
   bson_t *doc;
   bson_t reply;
   char *str;
   bool ret;

   wc = mongoc_write_concern_new ();
   mongoc_write_concern_set_w (wc, 4);
   mongoc_write_concern_set_wtimeout_int64 (wc, 100); /* milliseconds */
   mongoc_write_concern_append (wc, &opts);

   bulk = mongoc_collection_create_bulk_operation_with_opts (collection, &opts);

   /* Two inserts */
   doc = BCON_NEW ("_id", BCON_INT32 (10));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   doc = BCON_NEW ("_id", BCON_INT32 (11));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   ret = mongoc_bulk_operation_execute (bulk, &reply, &error);

   str = bson_as_canonical_extended_json (&reply, NULL);
   printf ("%s\en", str);
   bson_free (str);

   if (!ret) {
      printf ("Error: %s\en", error.message);
   }

   bson_destroy (&reply);
   mongoc_bulk_operation_destroy (bulk);
   mongoc_write_concern_destroy (wc);
   bson_destroy (&opts);
}

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   const char *uri_string = "mongodb://localhost/?appname=bulk4\-example";
   mongoc_uri_t *uri;
   bson_error_t error;

   mongoc_init ();

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   collection = mongoc_client_get_collection (client, "test", "test");

   bulk4 (collection);

   mongoc_uri_destroy (uri);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Example \fBreply\fP document and error message:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "nInserted"    : 2,
  "nMatched"     : 0,
  "nModified"    : 0,
  "nRemoved"     : 0,
  "nUpserted"    : 0,
  "writeErrors"  : [],
  "writeConcernErrors" : [
    { "code"   : 64,
      "errmsg" : "waiting for replication timed out" }
] }

Error: waiting for replication timed out
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBbson_error_t\fP domain is \fBMONGOC_ERROR_WRITE_CONCERN\fP if there are write concern errors and no write errors. Write errors indicate failed operations, so they take precedence over write concern errors, which mean merely that the write concern is not satisfied \fIyet\fP\&.
.SS Setting Collation Order
.sp
This feature is only available when using MongoDB 3.4 and later.
.sp
bulk\-collation.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>
#include <stdio.h>

static void
bulk_collation (mongoc_collection_t *collection)
{
   mongoc_bulk_operation_t *bulk;
   bson_t *opts;
   bson_t *doc;
   bson_t *selector;
   bson_t *update;
   bson_error_t error;
   bson_t reply;
   char *str;
   uint32_t ret;

   /* insert {_id: "one"} and {_id: "One"} */
   bulk = mongoc_collection_create_bulk_operation_with_opts (
      collection, NULL);
   doc = BCON_NEW ("_id", BCON_UTF8 ("one"));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   doc = BCON_NEW ("_id", BCON_UTF8 ("One"));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   /* "One" normally sorts before "one"; make "one" come first */
   opts = BCON_NEW ("collation",
                    "{",
                    "locale",
                    BCON_UTF8 ("en_US"),
                    "caseFirst",
                    BCON_UTF8 ("lower"),
                    "}");

   /* set x=1 on the document with _id "One", which now sorts after "one" */
   update = BCON_NEW ("$set", "{", "x", BCON_INT64 (1), "}");
   selector = BCON_NEW ("_id", "{", "$gt", BCON_UTF8 ("one"), "}");
   mongoc_bulk_operation_update_one_with_opts (
      bulk, selector, update, opts, &error);

   ret = mongoc_bulk_operation_execute (bulk, &reply, &error);

   str = bson_as_canonical_extended_json (&reply, NULL);
   printf ("%s\en", str);
   bson_free (str);

   if (!ret) {
      printf ("Error: %s\en", error.message);
   }

   bson_destroy (&reply);
   bson_destroy (update);
   bson_destroy (selector);
   bson_destroy (opts);
   mongoc_bulk_operation_destroy (bulk);
}

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   const char *uri_string = "mongodb://localhost/?appname=bulk\-collation";
   mongoc_uri_t *uri;
   bson_error_t error;

   mongoc_init ();

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   collection = mongoc_client_get_collection (client, "db", "collection");
   bulk_collation (collection);

   mongoc_uri_destroy (uri);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Running the above example will result in:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "nInserted" : 2,
   "nMatched" : 1,
   "nModified" : 1,
   "nRemoved" : 0,
   "nUpserted" : 0,
   "writeErrors" : [  ]
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Unacknowledged Bulk Writes
.sp
Set "w" to zero for an unacknowledged write. The driver sends unacknowledged writes using the legacy opcodes \fBOP_INSERT\fP, \fBOP_UPDATE\fP, and \fBOP_DELETE\fP\&.
.sp
bulk6.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>
#include <stdio.h>

static void
bulk6 (mongoc_collection_t *collection)
{
   bson_t opts = BSON_INITIALIZER;
   mongoc_write_concern_t *wc;
   mongoc_bulk_operation_t *bulk;
   bson_error_t error;
   bson_t *doc;
   bson_t *selector;
   bson_t reply;
   char *str;
   bool ret;

   wc = mongoc_write_concern_new ();
   mongoc_write_concern_set_w (wc, 0);
   mongoc_write_concern_append (wc, &opts);

   bulk = mongoc_collection_create_bulk_operation_with_opts (collection, &opts);

   doc = BCON_NEW ("_id", BCON_INT32 (10));
   mongoc_bulk_operation_insert (bulk, doc);
   bson_destroy (doc);

   selector = BCON_NEW ("_id", BCON_INT32 (11));
   mongoc_bulk_operation_remove_one (bulk, selector);
   bson_destroy (selector);

   ret = mongoc_bulk_operation_execute (bulk, &reply, &error);

   str = bson_as_canonical_extended_json (&reply, NULL);
   printf ("%s\en", str);
   bson_free (str);

   if (!ret) {
      printf ("Error: %s\en", error.message);
   }

   bson_destroy (&reply);
   mongoc_bulk_operation_destroy (bulk);
   mongoc_write_concern_destroy (wc);
   bson_destroy (&opts);
}

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   const char *uri_string = "mongodb://localhost/?appname=bulk6\-example";
   mongoc_uri_t *uri;
   bson_error_t error;

   mongoc_init ();

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   collection = mongoc_client_get_collection (client, "test", "test");

   bulk6 (collection);

   mongoc_uri_destroy (uri);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBreply\fP document is empty:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ }
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Further Reading
.sp
See the \fI\%Driver Bulk API Spec\fP, which describes bulk write operations for all MongoDB drivers.
.SS Aggregation Framework Examples
.sp
This document provides a number of practical examples that display the capabilities of the aggregation framework.
.sp
The \fI\%Aggregations using the Zip Codes Data Set\fP examples uses a publicly available data set of all zipcodes and populations in the United States. These data are available at: \fI\%zips.json\fP\&.
.SS Requirements
.sp
Let\(aqs check if everything is installed.
.sp
Use the following command to load zips.json data set into mongod instance:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongoimport \-\-drop \-d test \-c zipcodes zips.json
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Let\(aqs use the MongoDB shell to verify that everything was imported successfully.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongo test
connecting to: test
> db.zipcodes.count()
29467
> db.zipcodes.findOne()
{
      "_id" : "35004",
      "city" : "ACMAR",
      "loc" : [
              \-86.51557,
              33.584132
      ],
      "pop" : 6055,
      "state" : "AL"
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Aggregations using the Zip Codes Data Set
.sp
Each document in this collection has the following form:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
  "_id" : "35004",
  "city" : "Acmar",
  "state" : "AL",
  "pop" : 6055,
  "loc" : [\-86.51557, 33.584132]
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In these documents:
.INDENT 0.0
.IP \(bu 2
The \fB_id\fP field holds the zipcode as a string.
.IP \(bu 2
The \fBcity\fP field holds the city name.
.IP \(bu 2
The \fBstate\fP field holds the two letter state abbreviation.
.IP \(bu 2
The \fBpop\fP field holds the population.
.IP \(bu 2
The \fBloc\fP field holds the location as a \fB[latitude, longitude]\fP array.
.UNINDENT
.SS States with Populations Over 10 Million
.sp
To get all states with a population greater than 10 million, use the following aggregation pipeline:
.sp
aggregation1.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>
#include <stdio.h>

static void
print_pipeline (mongoc_collection_t *collection)
{
   mongoc_cursor_t *cursor;
   bson_error_t error;
   const bson_t *doc;
   bson_t *pipeline;
   char *str;

   pipeline = BCON_NEW ("pipeline",
                        "[",
                        "{",
                        "$group",
                        "{",
                        "_id",
                        "$state",
                        "total_pop",
                        "{",
                        "$sum",
                        "$pop",
                        "}",
                        "}",
                        "}",
                        "{",
                        "$match",
                        "{",
                        "total_pop",
                        "{",
                        "$gte",
                        BCON_INT32 (10000000),
                        "}",
                        "}",
                        "}",
                        "]");

   cursor = mongoc_collection_aggregate (
      collection, MONGOC_QUERY_NONE, pipeline, NULL, NULL);

   while (mongoc_cursor_next (cursor, &doc)) {
      str = bson_as_canonical_extended_json (doc, NULL);
      printf ("%s\en", str);
      bson_free (str);
   }

   if (mongoc_cursor_error (cursor, &error)) {
      fprintf (stderr, "Cursor Failure: %s\en", error.message);
   }

   mongoc_cursor_destroy (cursor);
   bson_destroy (pipeline);
}

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   const char *uri_string =
      "mongodb://localhost:27017/?appname=aggregation\-example";
   mongoc_uri_t *uri;
   bson_error_t error;

   mongoc_init ();

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   collection = mongoc_client_get_collection (client, "test", "zipcodes");

   print_pipeline (collection);

   mongoc_uri_destroy (uri);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You should see a result like the following:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "_id" : "PA", "total_pop" : 11881643 }
{ "_id" : "OH", "total_pop" : 10847115 }
{ "_id" : "NY", "total_pop" : 17990455 }
{ "_id" : "FL", "total_pop" : 12937284 }
{ "_id" : "TX", "total_pop" : 16986510 }
{ "_id" : "IL", "total_pop" : 11430472 }
{ "_id" : "CA", "total_pop" : 29760021 }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The above aggregation pipeline is build from two pipeline operators: \fB$group\fP and \fB$match\fP\&.
.sp
The \fB$group\fP pipeline operator requires _id field where we specify grouping; remaining fields specify how to generate composite value and must use one of the group aggregation functions: \fB$addToSet\fP, \fB$first\fP, \fB$last\fP, \fB$max\fP, \fB$min\fP, \fB$avg\fP, \fB$push\fP, \fB$sum\fP\&. The \fB$match\fP pipeline operator syntax is the same as the read operation query syntax.
.sp
The \fB$group\fP process reads all documents and for each state it creates a separate document, for example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "_id" : "WA", "total_pop" : 4866692 }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBtotal_pop\fP field uses the $sum aggregation function to sum the values of all pop fields in the source documents.
.sp
Documents created by \fB$group\fP are piped to the \fB$match\fP pipeline operator. It returns the documents with the value of \fBtotal_pop\fP field greater than or equal to 10 million.
.SS Average City Population by State
.sp
To get the first three states with the greatest average population per city, use the following aggregation:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pipeline = BCON_NEW ("pipeline", "[",
   "{", "$group", "{", "_id", "{", "state", "$state", "city", "$city", "}", "pop", "{", "$sum", "$pop", "}", "}", "}",
   "{", "$group", "{", "_id", "$_id.state", "avg_city_pop", "{", "$avg", "$pop", "}", "}", "}",
   "{", "$sort", "{", "avg_city_pop", BCON_INT32 (\-1), "}", "}",
   "{", "$limit", BCON_INT32 (3) "}",
"]");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This aggregate pipeline produces:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "_id" : "DC", "avg_city_pop" : 303450.0 }
{ "_id" : "FL", "avg_city_pop" : 27942.29805615551 }
{ "_id" : "CA", "avg_city_pop" : 27735.341099720412 }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The above aggregation pipeline is build from three pipeline operators: \fB$group\fP, \fB$sort\fP and \fB$limit\fP\&.
.sp
The first \fB$group\fP operator creates the following documents:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "_id" : { "state" : "WY", "city" : "Smoot" }, "pop" : 414 }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note, that the \fB$group\fP operator can\(aqt use nested documents except the \fB_id\fP field.
.sp
The second \fB$group\fP uses these documents to create the following documents:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "_id" : "FL", "avg_city_pop" : 27942.29805615551 }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
These documents are sorted by the \fBavg_city_pop\fP field in descending order. Finally, the \fB$limit\fP pipeline operator returns the first 3 documents from the sorted set.
.SS "distinct" and "mapReduce"
.sp
This document provides some practical, simple, examples to demonstrate the \fBdistinct\fP and \fBmapReduce\fP commands.
.SS Setup
.sp
First we\(aqll write some code to insert sample data:
.sp
doc\-common\-insert.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* Don\(aqt try to compile this file on its own. It\(aqs meant to be #included
   by example code */

/* Insert some sample data */
bool
insert_data (mongoc_collection_t *collection)
{
   mongoc_bulk_operation_t *bulk;
   enum N { ndocs = 4 };
   bson_t *docs[ndocs];
   bson_error_t error;
   int i = 0;
   bool ret;

   bulk = mongoc_collection_create_bulk_operation_with_opts (collection, NULL);

   docs[0] = BCON_NEW ("x", BCON_DOUBLE (1.0), "tags", "[", "dog", "cat", "]");
   docs[1] = BCON_NEW ("x", BCON_DOUBLE (2.0), "tags", "[", "cat", "]");
   docs[2] = BCON_NEW (
      "x", BCON_DOUBLE (2.0), "tags", "[", "mouse", "cat", "dog", "]");
   docs[3] = BCON_NEW ("x", BCON_DOUBLE (3.0), "tags", "[", "]");

   for (i = 0; i < ndocs; i++) {
      mongoc_bulk_operation_insert (bulk, docs[i]);
      bson_destroy (docs[i]);
      docs[i] = NULL;
   }

   ret = mongoc_bulk_operation_execute (bulk, NULL, &error);

   if (!ret) {
      fprintf (stderr, "Error inserting data: %s\en", error.message);
   }

   mongoc_bulk_operation_destroy (bulk);
   return ret;
}

/* A helper which we\(aqll use a lot later on */
void
print_res (const bson_t *reply)
{
   char *str;
   BSON_ASSERT (reply);
   str = bson_as_canonical_extended_json (reply, NULL);
   printf ("%s\en", str);
   bson_free (str);
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS "distinct" command
.sp
This is how to use the \fBdistinct\fP command to get the distinct values of \fBx\fP which are greater than \fB1\fP:
.sp
distinct.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bool
distinct (mongoc_database_t *database)
{
   bson_t *command;
   bson_t reply;
   bson_error_t error;
   bool res;
   bson_iter_t iter;
   bson_iter_t array_iter;
   double val;

   command = BCON_NEW ("distinct",
                       BCON_UTF8 (COLLECTION_NAME),
                       "key",
                       BCON_UTF8 ("x"),
                       "query",
                       "{",
                       "x",
                       "{",
                       "$gt",
                       BCON_DOUBLE (1.0),
                       "}",
                       "}");
   res =
      mongoc_database_command_simple (database, command, NULL, &reply, &error);
   if (!res) {
      fprintf (stderr, "Error with distinct: %s\en", error.message);
      goto cleanup;
   }

   /* Do something with reply (in this case iterate through the values) */
   if (!(bson_iter_init_find (&iter, &reply, "values") &&
         BSON_ITER_HOLDS_ARRAY (&iter) &&
         bson_iter_recurse (&iter, &array_iter))) {
      fprintf (stderr, "Couldn\(aqt extract \e"values\e" field from response\en");
      goto cleanup;
   }

   while (bson_iter_next (&array_iter)) {
      if (BSON_ITER_HOLDS_DOUBLE (&array_iter)) {
         val = bson_iter_double (&array_iter);
         printf ("Next double: %f\en", val);
      }
   }

cleanup:
   /* cleanup */
   bson_destroy (command);
   bson_destroy (&reply);
   return res;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS "mapReduce" \- basic example
.sp
A simple example using the map reduce framework. It simply adds up the number of occurrences of each "tag".
.sp
First define the \fBmap\fP and \fBreduce\fP functions:
.sp
constants.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
const char *const COLLECTION_NAME = "things";

/* Our map function just emits a single (key, 1) pair for each tag
   in the array: */
const char *const MAPPER = "function () {"
                           "this.tags.forEach(function(z) {"
                           "emit(z, 1);"
                           "});"
                           "}";

/* The reduce function sums over all of the emitted values for a
   given key: */
const char *const REDUCER = "function (key, values) {"
                            "var total = 0;"
                            "for (var i = 0; i < values.length; i++) {"
                            "total += values[i];"
                            "}"
                            "return total;"
                            "}";
/* Note We can\(aqt just return values.length as the reduce function
   might be called iteratively on the results of other reduce
   steps. */

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Run the \fBmapReduce\fP command. Use the generic command helpers (e.g. \fBmongoc_database_command_simple()\fP).
Do not the read command helpers (e.g. \fBmongoc_database_read_command_with_opts()\fP) because they are considered
retryable read operations. If retryable reads are enabled, those operations will retry once on a retryable error,
giving undesirable behavior for \fBmapReduce\fP\&.
.sp
map\-reduce\-basic.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bool
map_reduce_basic (mongoc_database_t *database)
{
   bson_t reply;
   bson_t *command;
   bool res;
   bson_error_t error;
   mongoc_cursor_t *cursor;
   const bson_t *doc;

   bool query_done = false;

   const char *out_collection_name = "outCollection";
   mongoc_collection_t *out_collection;

   /* Empty find query */
   bson_t find_query = BSON_INITIALIZER;

   /* Construct the mapReduce command */

   /* Other arguments can also be specified here, like "query" or
      "limit" and so on */
   command = BCON_NEW ("mapReduce",
                       BCON_UTF8 (COLLECTION_NAME),
                       "map",
                       BCON_CODE (MAPPER),
                       "reduce",
                       BCON_CODE (REDUCER),
                       "out",
                       BCON_UTF8 (out_collection_name));
   res =
      mongoc_database_command_simple (database, command, NULL, &reply, &error);

   if (!res) {
      fprintf (stderr, "MapReduce failed: %s\en", error.message);
      goto cleanup;
   }

   /* Do something with the reply (it doesn\(aqt contain the mapReduce results) */
   print_res (&reply);

   /* Now we\(aqll query outCollection to see what the results are */
   out_collection =
      mongoc_database_get_collection (database, out_collection_name);
   cursor = mongoc_collection_find_with_opts (
      out_collection, &find_query, NULL, NULL);
   query_done = true;

   /* Do something with the results */
   while (mongoc_cursor_next (cursor, &doc)) {
      print_res (doc);
   }

   if (mongoc_cursor_error (cursor, &error)) {
      fprintf (stderr, "ERROR: %s\en", error.message);
      res = false;
      goto cleanup;
   }

cleanup:
   /* cleanup */
   if (query_done) {
      mongoc_cursor_destroy (cursor);
      mongoc_collection_destroy (out_collection);
   }

   bson_destroy (&reply);
   bson_destroy (command);

   return res;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS "mapReduce" \- more complicated example
.sp
You must have replica set running for this.
.sp
In this example we contact a secondary in the replica set and do an "inline" map reduce, so the results are returned immediately:
.sp
map\-reduce\-advanced.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bool
map_reduce_advanced (mongoc_database_t *database)
{
   bson_t *command;
   bson_error_t error;
   bool res = true;
   mongoc_cursor_t *cursor;
   mongoc_read_prefs_t *read_pref;
   const bson_t *doc;

   /* Construct the mapReduce command */
   /* Other arguments can also be specified here, like "query" or "limit"
      and so on */

   /* Read the results inline from a secondary replica */
   command = BCON_NEW ("mapReduce",
                       BCON_UTF8 (COLLECTION_NAME),
                       "map",
                       BCON_CODE (MAPPER),
                       "reduce",
                       BCON_CODE (REDUCER),
                       "out",
                       "{",
                       "inline",
                       "1",
                       "}");

   read_pref = mongoc_read_prefs_new (MONGOC_READ_SECONDARY);
   cursor = mongoc_database_command (
      database, MONGOC_QUERY_NONE, 0, 0, 0, command, NULL, read_pref);

   /* Do something with the results */
   while (mongoc_cursor_next (cursor, &doc)) {
      print_res (doc);
   }

   if (mongoc_cursor_error (cursor, &error)) {
      fprintf (stderr, "ERROR: %s\en", error.message);
      res = false;
   }

   mongoc_cursor_destroy (cursor);
   mongoc_read_prefs_destroy (read_pref);
   bson_destroy (command);

   return res;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Running the Examples
.sp
Here\(aqs how to run the example code
.sp
basic\-aggregation.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/*
 * Copyright 2016 MongoDB, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE\-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include <mongoc/mongoc.h>
#include <stdio.h>


#include "constants.c"

#include "../doc\-common\-insert.c"
#include "distinct.c"
#include "map\-reduce\-basic.c"
#include "map\-reduce\-advanced.c"


int
main (int argc, char *argv[])
{
   mongoc_database_t *database = NULL;
   mongoc_client_t *client = NULL;
   mongoc_collection_t *collection = NULL;
   mongoc_uri_t *uri = NULL;
   bson_error_t error;
   char *host_and_port = NULL;
   int exit_code = EXIT_FAILURE;

   if (argc != 2) {
      fprintf (stderr, "usage: %s CONNECTION\-STRING\en", argv[0]);
      fprintf (stderr,
               "the connection string can be of the following forms:\en");
      fprintf (stderr, "localhost\et\et\et\etlocal machine\en");
      fprintf (stderr, "localhost:27018\et\et\et\etlocal machine on port 27018\en");
      fprintf (stderr,
               "mongodb://user:pass@localhost:27017\et"
               "local machine on port 27017, and authenticate with username "
               "user and password pass\en");
      return exit_code;
   }

   mongoc_init ();

   if (strncmp (argv[1], "mongodb://", 10) == 0) {
      host_and_port = bson_strdup (argv[1]);
   } else {
      host_and_port = bson_strdup_printf ("mongodb://%s", argv[1]);
   }

   uri = mongoc_uri_new_with_error (host_and_port, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               host_and_port,
               error.message);
      goto cleanup;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      goto cleanup;
   }

   mongoc_client_set_error_api (client, 2);
   database = mongoc_client_get_database (client, "test");
   collection = mongoc_database_get_collection (database, COLLECTION_NAME);

   printf ("Inserting data\en");
   if (!insert_data (collection)) {
      goto cleanup;
   }

   printf ("distinct\en");
   if (!distinct (database)) {
      goto cleanup;
   }

   printf ("map reduce\en");
   if (!map_reduce_basic (database)) {
      goto cleanup;
   }

   printf ("more complicated map reduce\en");
   if (!map_reduce_advanced (database)) {
      goto cleanup;
   }
   
   exit_code = EXIT_SUCCESS;

cleanup:
   if (collection) {
      mongoc_collection_destroy (collection);
   }

   if (database) {
      mongoc_database_destroy (database);
   }

   if (client) {
      mongoc_client_destroy (client);
   }

   if (uri) {
      mongoc_uri_destroy (uri);
   }

   if (host_and_port) {
      bson_free (host_and_port);
   }

   mongoc_cleanup ();
   return exit_code;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you want to try the advanced map reduce example with a secondary, start a replica set (instructions for how to do this can be found \fI\%here\fP).
.sp
Otherwise, just start an instance of MongoDB:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mongod
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Now compile and run the example program:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd examples/basic_aggregation/
$ gcc \-Wall \-o agg\-example basic\-aggregation.c $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0)
$ ./agg\-example localhost

Inserting data
distinct
Next double: 2.000000
Next double: 3.000000
map reduce
{ "result" : "outCollection", "timeMillis" : 155, "counts" : { "input" : 84, "emit" : 126, "reduce" : 3, "output" : 3 }, "ok" : 1 }
{ "_id" : "cat", "value" : 63 }
{ "_id" : "dog", "value" : 42 }
{ "_id" : "mouse", "value" : 21 }
more complicated map reduce
{ "results" : [ { "_id" : "cat", "value" : 63 }, { "_id" : "dog", "value" : 42 }, { "_id" : "mouse", "value" : 21 } ], "timeMillis" : 14, "counts" : { "input" : 84, "emit" : 126, "reduce" : 3, "output" : 3 }, "ok" : 1 }
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Using libmongoc in a Microsoft Visual Studio project
.sp
Download and install libmongoc on your system, then open Visual Studio, select "FileNewProject...", and create a new Win32 Console Application.
[image]
.sp
Remember to switch the platform from 32\-bit to 64\-bit:
[image]
.sp
Right\-click on your console application in the Solution Explorer and select "Properties". Choose to edit properties for "All Configurations", expand the "C/C++" options and choose "General". Add to the "Additional Include Directories" these paths:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\emongo\-c\-driver\einclude\elibbson\-1.0
C:\emongo\-c\-driver\einclude\elibmongoc\-1.0
.ft P
.fi
.UNINDENT
.UNINDENT
[image]
.sp
(If you chose a different \fBCMAKE_INSTALL_PREFIX\fP when you ran CMake, your include paths will be different.)
.sp
Also in the Properties dialog, expand the "Linker" options and choose "Input", and add to the "Additional Dependencies" these libraries:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\emongo\-c\-driver\elib\ebson\-1.0.lib
C:\emongo\-c\-driver\elib\emongoc\-1.0.lib
.ft P
.fi
.UNINDENT
.UNINDENT
[image]
.sp
Adding these libraries as dependencies provides linker symbols to build your application, but to actually run it, libbson\(aqs and libmongoc\(aqs DLLs must be in your executable path. Select "Debugging" in the Properties dialog, and set the "Environment" option to:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
PATH=c:/mongo\-c\-driver/bin
.ft P
.fi
.UNINDENT
.UNINDENT
[image]
.sp
Finally, include "mongoc/mongoc.h" in your project\(aqs "stdafx.h":
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Static linking
.sp
Following the instructions above, you have dynamically linked your application to the libbson and libmongoc DLLs. This is usually the right choice. If you want to link statically instead, update your "Additional Dependencies" list by removing \fBbson\-1.0.lib\fP and \fBmongoc\-1.0.lib\fP and replacing them with these libraries:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C:\emongo\-c\-driver\elib\ebson\-static\-1.0.lib
C:\emongo\-c\-driver\elib\emongoc\-static\-1.0.lib
ws2_32.lib
Secur32.lib
Crypt32.lib
BCrypt.lib
.ft P
.fi
.UNINDENT
.UNINDENT
[image]
.sp
(To explain the purpose of each library: \fBbson\-static\-1.0.lib\fP and \fBmongoc\-static\-1.0.lib\fP are static archives of the driver code. The socket library \fBws2_32\fP is required by libbson, which uses the socket routine \fBgethostname\fP to help guarantee ObjectId uniqueness. The \fBBCrypt\fP library is used by libmongoc for TLS connections to MongoDB, and \fBSecur32\fP and \fBCrypt32\fP are required for enterprise authentication methods like Kerberos.)
.sp
Finally, define two preprocessor symbols before including \fBmongoc/mongoc.h\fP in your \fBstdafx.h\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#define BSON_STATIC
#define MONGOC_STATIC
#include <mongoc/mongoc.h>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Making these changes to your project is only required for static linking; for most people, the dynamic\-linking instructions above are preferred.
.SS Next Steps
.sp
Now you can build and debug applications in Visual Studio that use libbson and libmongoc. Proceed to making\-a\-connection in the tutorial to learn how connect to MongoDB and perform operations.
.SS Creating Indexes
.sp
To create indexes on a MongoDB collection, execute the \fBcreateIndexes\fP command
with a command function like \fBmongoc_database_write_command_with_opts\fP or
\fBmongoc_collection_write_command_with_opts\fP\&. See \fI\%the MongoDB
Manual entry for the createIndexes command\fP for details.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
The \fBcommitQuorum\fP option to the \fBcreateIndexes\fP command is only
supported in MongoDB 4.4+ servers, but it is not validated in the command
functions. Do not pass \fBcommitQuorum\fP if connected to server versions less
than 4.4. Using the \fBcommitQuorum\fP option on server versions less than 4.4
may have adverse effects on index builds.
.UNINDENT
.UNINDENT
.SS Example
.sp
example\-create\-indexes.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* gcc example\-create\-indexes.c \-o example\-create\-indexes $(pkg\-config \-\-cflags
 * \-\-libs libmongoc\-1.0) */

/* ./example\-create\-indexes [CONNECTION_STRING [COLLECTION_NAME]] */

#include <mongoc/mongoc.h>
#include <stdio.h>
#include <stdlib.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   const char *uri_string =
      "mongodb://127.0.0.1/?appname=create\-indexes\-example";
   mongoc_uri_t *uri;
   mongoc_database_t *db;
   const char *collection_name = "test";
   bson_t keys;
   char *index_name;
   bson_t *create_indexes;
   bson_t reply;
   char *reply_str;
   bson_error_t error;
   bool r;

   mongoc_init ();

   if (argc > 1) {
      uri_string = argv[1];
   }

   if (argc > 2) {
      collection_name = argv[2];
   }

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   db = mongoc_client_get_database (client, "test");

   /* ascending index on field "x" */
   bson_init (&keys);
   BSON_APPEND_INT32 (&keys, "x", 1);
   index_name = mongoc_collection_keys_to_index_string (&keys);
   create_indexes = BCON_NEW ("createIndexes",
                              BCON_UTF8 (collection_name),
                              "indexes",
                              "[",
                              "{",
                              "key",
                              BCON_DOCUMENT (&keys),
                              "name",
                              BCON_UTF8 (index_name),
                              "}",
                              "]");

   r = mongoc_database_write_command_with_opts (
      db, create_indexes, NULL /* opts */, &reply, &error);

   reply_str = bson_as_json (&reply, NULL);
   printf ("%s\en", reply_str);

   if (!r) {
      fprintf (stderr, "Error in createIndexes: %s\en", error.message);
   }

   bson_free (index_name);
   bson_free (reply_str);
   bson_destroy (&reply);
   bson_destroy (create_indexes);
   mongoc_database_destroy (db);
   mongoc_uri_destroy (uri);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return r ? EXIT_SUCCESS : EXIT_FAILURE;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Aids for Debugging
.SS GDB
.sp
This repository contains a \fB\&.gdbinit\fP file that contains helper functions to
aid debugging of data structures. GDB will load this file
\fI\%automatically\fP if you have added the directory which contains the \fI\&.gdbinit\fP file to GDB\(aqs
\fI\%auto\-load safe\-path\fP, \fIand\fP you start GDB from the directory which holds the \fI\&.gdbinit\fP file.
.sp
You can see the safe\-path with \fBshow auto\-load safe\-path\fP on a GDB prompt. You
can configure it by setting it in \fB~/.gdbinit\fP with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
add\-auto\-load\-safe\-path /path/to/mongo\-c\-driver
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you haven\(aqt added the path to your auto\-load safe\-path, or start GDB in
another directory, load the file with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
source path/to/mongo\-c\-driver/.gdbinit
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fB\&.gdbinit\fP file defines the \fBprintbson\fP function, which shows the contents of a \fBbson_t *\fP variable.
If you have a local \fBbson_t\fP, then you must prefix the variable with a \fI&\fP\&.
.sp
An example GDB session looks like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(gdb) printbson bson
ALLOC [0x555556cd7310 + 0] (len=475)
{
    \(aqbool\(aq : true,
    \(aqint32\(aq : NumberInt("42"),
    \(aqint64\(aq : NumberLong("3000000042"),
    \(aqstring\(aq : "Stg",
    \(aqobjectId\(aq : ObjectID("5A1442F3122D331C3C6757E1"),
    \(aqutcDateTime\(aq : UTCDateTime(1511277299031),
    \(aqarrayOfInts\(aq : [
        \(aq0\(aq : NumberInt("1"),
        \(aq1\(aq : NumberInt("2")
    ],
    \(aqembeddedDocument\(aq : {
        \(aqarrayOfStrings\(aq : [
            \(aq0\(aq : "one",
            \(aq1\(aq : "two"
        ],
        \(aqdouble\(aq : 2.718280,
        \(aqnotherDoc\(aq : {
            \(aqtrue\(aq : NumberInt("1"),
            \(aqfalse\(aq : false
        }
    },
    \(aqbinary\(aq : Binary("02", "3031343532333637"),
    \(aqregex\(aq : Regex("@[a\-z]+@", "im"),
    \(aqnull\(aq : null,
    \(aqjs\(aq : JavaScript("print foo"),
    \(aqjsws\(aq : JavaScript("print foo") with scope: {
        \(aqf\(aq : NumberInt("42"),
        \(aqa\(aq : [
            \(aq0\(aq : 3.141593,
            \(aq1\(aq : 2.718282
        ]
    },
    \(aqtimestamp\(aq : Timestamp(4294967295, 4294967295),
    \(aqdouble\(aq : 3.141593
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS LLDB
.sp
This repository also includes a script that customizes LLDB\(aqs standard \fBprint\fP command to print a \fBbson_t\fP or \fBbson_t *\fP as JSON:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(lldb) print b
(bson_t) $0 = {"x": 1, "y": 2}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The custom \fBbson\fP command provides more options:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(lldb) bson \-\-verbose b
len=19
flags=INLINE|STATIC
{
  "x": 1,
  "y": 2
}
(lldb) bson \-\-raw b
\(aq\ex13\ex00\ex00\ex00\ex10x\ex00\ex01\ex00\ex00\ex00\ex10y\ex00\ex02\ex00\ex00\ex00\ex00\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Type \fBhelp bson\fP for a list of options.
.sp
The script requires a build of libbson with debug symbols, and an installation of \fI\%PyMongo\fP\&. Install PyMongo with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
python \-m pip install pymongo
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you see "No module named pip" then you must \fI\%install pip\fP, then run the previous command again.
.sp
Create a file \fB~/.lldbinit\fP containing:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
command script import /path/to/mongo\-c\-driver/lldb_bson.py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you see "bson command installed by lldb_bson" at the beginning of your LLDB session, you\(aqve installed the script correctly.
.SS Debug assertions
.sp
To enable runtime debug assertions, configure with \fB\-DENABLE_DEBUG_ASSERTIONS=ON\fP\&.
.SS Using Client\-Side Field Level Encryption
.sp
New in MongoDB 4.2, Client\-Side Field Level Encryption (also referred to as Client\-Side Encryption) allows administrators and developers to encrypt specific data fields in addition to other MongoDB encryption features.
.sp
With Client\-Side Encryption, developers can encrypt fields client side without any server\-side configuration or directives. Client\-Side Encryption supports workloads where applications must guarantee that unauthorized parties, including server administrators, cannot read the encrypted data.
.sp
Automatic encryption, where sensitive fields in commands are encrypted automatically, requires an Enterprise\-only process to do query analysis.
.SS Installation
.SS libmongocrypt
.sp
There is a separate library, \fI\%libmongocrypt\fP, that must be installed prior to configuring libmongoc to enable Client\-Side Encryption.
.sp
libmongocrypt depends on libbson. To build libmongoc with Client\-Side Encryption support you must:
.INDENT 0.0
.IP 1. 3
Install libbson
.IP 2. 3
Build and install libmongocrypt
.IP 3. 3
Build libmongoc
.UNINDENT
.sp
To install libbson, follow the instructions to install with a package manager: Install libbson with a Package Manager or build from source with cmake (disable building libmongoc with \fB\-DENABLE_MONGOC=OFF\fP):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd mongo\-c\-driver
$ mkdir cmake\-build && cd cmake\-build
$ cmake \-DENABLE_AUTOMATIC_INIT_AND_CLEANUP=OFF \-DENABLE_MONGOC=OFF ..
$ cmake \-\-build . \-\-target install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To build and install libmongocrypt, clone \fI\%the repository\fP and configure as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd libmongocrypt
$ mkdir cmake\-build && cd cmake\-build
$ cmake \-DENABLE_SHARED_BSON=ON ..
$ cmake \-\-build . \-\-target install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Then, you should be able to build libmongoc with Client\-Side Encryption.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd mongo\-c\-driver
$ mkdir cmake\-build && cd cmake\-build
$ cmake \-DENABLE_AUTOMATIC_INIT_AND_CLEANUP=OFF \-DENABLE_MONGOC=ON \-DENABLE_CLIENT_SIDE_ENCRYPTION=ON ..
$ cmake \-\-build . \-\-target install
.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongocryptd
.sp
The \fBmongocryptd\fP binary is required for automatic Client\-Side Encryption and is included as a component in the \fI\%MongoDB Enterprise Server package\fP\&. For detailed installation instructions see the \fI\%MongoDB documentation on mongocryptd\fP\&.
.sp
\fBmongocryptd\fP performs the following:
.INDENT 0.0
.IP \(bu 2
Parses the automatic encryption rules specified to the database connection. If the JSON schema contains invalid automatic encryption syntax or any document validation syntax, \fBmongocryptd\fP returns an error.
.IP \(bu 2
Uses the specified automatic encryption rules to mark fields in read and write operations for encryption.
.IP \(bu 2
Rejects read/write operations that may return unexpected or incorrect results when applied to an encrypted field. For supported and unsupported operations, see \fI\%Read/Write Support with Automatic Field Level Encryption\fP\&.
.UNINDENT
.sp
A \fBmongoc_client_t\fP configured with auto encryption will automatically spawn the \fBmongocryptd\fP process from the application\(aqs \fBPATH\fP\&. Applications can control the spawning behavior as part of the automatic encryption options. For example, to set a custom path to the \fBmongocryptd\fP process, set the \fBmongocryptdSpawnPath\fP with \fBmongoc_auto_encryption_opts_set_extra()\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bson_t *extra = BCON_NEW ("mongocryptdSpawnPath", "/path/to/mongocryptd");
mongoc_auto_encryption_opts_set_extra (opts, extra);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To control the logging output of \fBmongocryptd\fP pass \fBmongocryptdSpawnArgs\fP to \fBmongoc_auto_encryption_opts_set_extra()\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bson_t *extra = BCON_NEW ("mongocryptdSpawnArgs",
   "[", "\-\-logpath=/path/to/mongocryptd.log", "\-\-logappend", "]");
mongoc_auto_encryption_opts_set_extra (opts, extra);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If your application wishes to manage the \fBmongocryptd\fP process manually, it is possible to disable spawning \fBmongocryptd\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
bson_t *extra = BCON_NEW ("mongocryptdBypassSpawn",
   BCON_BOOL(true), "mongocryptdURI", "mongodb://localhost:27020");
mongoc_auto_encryption_opts_set_extra (opts, extra);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongocryptd\fP is only responsible for supporting automatic Client\-Side Encryption in the driver and does not itself perform any encryption or decryption.
.SS Automatic Client\-Side Field Level Encryption
.sp
Automatic Client\-Side Encryption is enabled by calling \fBmongoc_client_enable_auto_encryption()\fP on a \fBmongoc_client_t\fP\&. The following examples show how to set up automatic client\-side field level encryption using \fBmongoc_client_encryption_t\fP to create a new encryption data key.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Automatic client\-side field level encryption requires MongoDB 4.2 enterprise or a MongoDB 4.2 Atlas cluster. The community version of the server supports automatic decryption as well as \fI\%Explicit Encryption\fP\&.
.UNINDENT
.UNINDENT
.SS Providing Local Automatic Encryption Rules
.sp
The following example shows how to specify automatic encryption rules using a schema map set with \fBmongoc_auto_encryption_opts_set_schema_map()\fP\&. The automatic encryption rules are expressed using a strict subset of the JSON Schema syntax.
.sp
Supplying a schema map provides more security than relying on JSON Schemas obtained from the server. It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.
.sp
JSON Schemas supplied in the schema map only apply to configuring automatic client\-side field level encryption. Other validation rules in the JSON schema will not be enforced by the driver and will result in an error:
.sp
client\-side\-encryption\-schema\-map.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>
#include <stdio.h>
#include <stdlib.h>

#include "client\-side\-encryption\-helpers.h"

/* Helper method to create a new data key in the key vault, a schema to use that
 * key, and writes the schema to a file for later use. */
static bool
create_schema_file (bson_t *kms_providers,
                    const char *keyvault_db,
                    const char *keyvault_coll,
                    mongoc_client_t *keyvault_client,
                    bson_error_t *error)
{
   mongoc_client_encryption_t *client_encryption = NULL;
   mongoc_client_encryption_opts_t *client_encryption_opts = NULL;
   mongoc_client_encryption_datakey_opts_t *datakey_opts = NULL;
   bson_value_t datakey_id = {0};
   char *keyaltnames[] = {"mongoc_encryption_example_1"};
   bson_t *schema = NULL;
   char *schema_string = NULL;
   size_t schema_string_len;
   FILE *outfile = NULL;
   bool ret = false;

   client_encryption_opts = mongoc_client_encryption_opts_new ();
   mongoc_client_encryption_opts_set_kms_providers (client_encryption_opts,
                                                    kms_providers);
   mongoc_client_encryption_opts_set_keyvault_namespace (
      client_encryption_opts, keyvault_db, keyvault_coll);
   mongoc_client_encryption_opts_set_keyvault_client (client_encryption_opts,
                                                      keyvault_client);

   client_encryption =
      mongoc_client_encryption_new (client_encryption_opts, error);
   if (!client_encryption) {
      goto fail;
   }

   /* Create a new data key and json schema for the encryptedField.
    * https://dochub.mongodb.org/core/client\-side\-field\-level\-encryption\-automatic\-encryption\-rules
    */
   datakey_opts = mongoc_client_encryption_datakey_opts_new ();
   mongoc_client_encryption_datakey_opts_set_keyaltnames (
      datakey_opts, keyaltnames, 1);
   if (!mongoc_client_encryption_create_datakey (
          client_encryption, "local", datakey_opts, &datakey_id, error)) {
      goto fail;
   }

   /* Create a schema describing that "encryptedField" is a string encrypted
    * with the newly created data key using deterministic encryption. */
   schema = BCON_NEW ("properties",
                      "{",
                      "encryptedField",
                      "{",
                      "encrypt",
                      "{",
                      "keyId",
                      "[",
                      BCON_BIN (datakey_id.value.v_binary.subtype,
                                datakey_id.value.v_binary.data,
                                datakey_id.value.v_binary.data_len),
                      "]",
                      "bsonType",
                      "string",
                      "algorithm",
                      MONGOC_AEAD_AES_256_CBC_HMAC_SHA_512_DETERMINISTIC,
                      "}",
                      "}",
                      "}",
                      "bsonType",
                      "object");

   /* Use canonical JSON so that other drivers and tools will be
    * able to parse the MongoDB extended JSON file. */
   schema_string = bson_as_canonical_extended_json (schema, &schema_string_len);
   outfile = fopen ("jsonSchema.json", "w");
   if (0 == fwrite (schema_string, sizeof (char), schema_string_len, outfile)) {
      fprintf (stderr, "failed to write to file\en");
      goto fail;
   }

   ret = true;
fail:
   mongoc_client_encryption_destroy (client_encryption);
   mongoc_client_encryption_datakey_opts_destroy (datakey_opts);
   mongoc_client_encryption_opts_destroy (client_encryption_opts);
   bson_free (schema_string);
   bson_destroy (schema);
   bson_value_destroy (&datakey_id);
   if (outfile) {
      fclose (outfile);
   }
   return true;
}

/* This example demonstrates how to use automatic encryption with a client\-side
 * schema map using the enterprise version of MongoDB */
int
main (int argc, char **argv)
{
/* The collection used to store the encryption data keys. */
#define KEYVAULT_DB "encryption"
#define KEYVAULT_COLL "__libmongocTestKeyVault"
/* The collection used to store the encrypted documents in this example. */
#define ENCRYPTED_DB "test"
#define ENCRYPTED_COLL "coll"

   int exit_status = EXIT_FAILURE;
   bool ret;
   uint8_t *local_masterkey = NULL;
   uint32_t local_masterkey_len;
   bson_t *kms_providers = NULL;
   bson_error_t error = {0};
   bson_t *index_keys = NULL;
   char *index_name = NULL;
   bson_t *create_index_cmd = NULL;
   bson_json_reader_t *reader = NULL;
   bson_t schema = BSON_INITIALIZER;
   bson_t *schema_map = NULL;

   /* The MongoClient used to access the key vault (keyvault_namespace). */
   mongoc_client_t *keyvault_client = NULL;
   mongoc_collection_t *keyvault_coll = NULL;
   mongoc_auto_encryption_opts_t *auto_encryption_opts = NULL;
   mongoc_client_t *client = NULL;
   mongoc_collection_t *coll = NULL;
   bson_t *to_insert = NULL;
   mongoc_client_t *unencrypted_client = NULL;
   mongoc_collection_t *unencrypted_coll = NULL;

   mongoc_init ();

   /* Configure the master key. This must be the same master key that was used
    * to create the encryption key. */
   local_masterkey =
      hex_to_bin (getenv ("LOCAL_MASTERKEY"), &local_masterkey_len);
   if (!local_masterkey || local_masterkey_len != 96) {
      fprintf (stderr,
               "Specify LOCAL_MASTERKEY environment variable as a "
               "secure random 96 byte hex value.\en");
      goto fail;
   }

   kms_providers = BCON_NEW ("local",
                             "{",
                             "key",
                             BCON_BIN (0, local_masterkey, local_masterkey_len),
                             "}");

   /* Set up the key vault for this example. */
   keyvault_client = mongoc_client_new (
      "mongodb://localhost/?appname=client\-side\-encryption\-keyvault");
   keyvault_coll = mongoc_client_get_collection (
      keyvault_client, KEYVAULT_DB, KEYVAULT_COLL);
   mongoc_collection_drop (keyvault_coll, NULL);

   /* Create a unique index to ensure that two data keys cannot share the same
    * keyAltName. This is recommended practice for the key vault. */
   index_keys = BCON_NEW ("keyAltNames", BCON_INT32 (1));
   index_name = mongoc_collection_keys_to_index_string (index_keys);
   create_index_cmd = BCON_NEW ("createIndexes",
                                KEYVAULT_COLL,
                                "indexes",
                                "[",
                                "{",
                                "key",
                                BCON_DOCUMENT (index_keys),
                                "name",
                                index_name,
                                "unique",
                                BCON_BOOL (true),
                                "partialFilterExpression",
                                "{",
                                "keyAltNames",
                                "{",
                                "$exists",
                                BCON_BOOL (true),
                                "}",
                                "}",
                                "}",
                                "]");
   ret = mongoc_client_command_simple (keyvault_client,
                                       KEYVAULT_DB,
                                       create_index_cmd,
                                       NULL /* read prefs */,
                                       NULL /* reply */,
                                       &error);

   if (!ret) {
      goto fail;
   }

   /* Create a new data key and a schema using it for encryption. Save the
    * schema to the file jsonSchema.json */
   ret = create_schema_file (
      kms_providers, KEYVAULT_DB, KEYVAULT_COLL, keyvault_client, &error);

   if (!ret) {
      goto fail;
   }

   /* Load the JSON Schema and construct the local schema_map option. */
   reader = bson_json_reader_new_from_file ("jsonSchema.json", &error);
   if (!reader) {
      goto fail;
   }

   bson_json_reader_read (reader, &schema, &error);

   /* Construct the schema map, mapping the namespace of the collection to the
    * schema describing encryption. */
   schema_map =
      BCON_NEW (ENCRYPTED_DB "." ENCRYPTED_COLL, BCON_DOCUMENT (&schema));

   auto_encryption_opts = mongoc_auto_encryption_opts_new ();
   mongoc_auto_encryption_opts_set_keyvault_client (auto_encryption_opts,
                                                    keyvault_client);
   mongoc_auto_encryption_opts_set_keyvault_namespace (
      auto_encryption_opts, KEYVAULT_DB, KEYVAULT_COLL);
   mongoc_auto_encryption_opts_set_kms_providers (auto_encryption_opts,
                                                  kms_providers);
   mongoc_auto_encryption_opts_set_schema_map (auto_encryption_opts,
                                               schema_map);

   client =
      mongoc_client_new ("mongodb://localhost/?appname=client\-side\-encryption");

   /* Enable automatic encryption. It will determine that encryption is
    * necessary from the schema map instead of relying on the server to provide
    * a schema. */
   ret = mongoc_client_enable_auto_encryption (
      client, auto_encryption_opts, &error);
   if (!ret) {
      goto fail;
   }

   coll = mongoc_client_get_collection (client, ENCRYPTED_DB, ENCRYPTED_COLL);

   /* Clear old data */
   mongoc_collection_drop (coll, NULL);

   to_insert = BCON_NEW ("encryptedField", "123456789");
   ret = mongoc_collection_insert_one (
      coll, to_insert, NULL /* opts */, NULL /* reply */, &error);
   if (!ret) {
      goto fail;
   }
   printf ("decrypted document: ");
   if (!print_one_document (coll, &error)) {
      goto fail;
   }
   printf ("\en");

   unencrypted_client = mongoc_client_new (
      "mongodb://localhost/?appname=client\-side\-encryption\-unencrypted");
   unencrypted_coll = mongoc_client_get_collection (
      unencrypted_client, ENCRYPTED_DB, ENCRYPTED_COLL);
   printf ("encrypted document: ");
   if (!print_one_document (unencrypted_coll, &error)) {
      goto fail;
   }
   printf ("\en");

   exit_status = EXIT_SUCCESS;
fail:
   if (error.code) {
      fprintf (stderr, "error: %s\en", error.message);
   }

   bson_free (local_masterkey);
   bson_destroy (kms_providers);
   mongoc_collection_destroy (keyvault_coll);
   bson_destroy (index_keys);
   bson_free (index_name);
   bson_destroy (create_index_cmd);
   bson_json_reader_destroy (reader);
   mongoc_auto_encryption_opts_destroy (auto_encryption_opts);
   mongoc_collection_destroy (coll);
   mongoc_client_destroy (client);
   bson_destroy (to_insert);
   mongoc_collection_destroy (unencrypted_coll);
   mongoc_client_destroy (unencrypted_client);
   mongoc_client_destroy (keyvault_client);
   bson_destroy (&schema);
   bson_destroy (schema_map);
   mongoc_cleanup ();
   return exit_status;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Server\-Side Field Level Encryption Enforcement
.sp
The MongoDB 4.2 server supports using schema validation to enforce encryption of specific fields in a collection. This schema validation will prevent an application from inserting unencrypted values for any fields marked with the "encrypt" JSON schema keyword.
.sp
The following example shows how to set up automatic client\-side field level encryption using \fBmongoc_client_encryption_t\fP to create a new encryption data key and create a collection with the Automatic Encryption JSON Schema Syntax:
.sp
client\-side\-encryption\-server\-schema.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>
#include <stdio.h>
#include <stdlib.h>

#include "client\-side\-encryption\-helpers.h"

/* Helper method to create and return a JSON schema to use for encryption.
The caller will use the returned schema for server\-side encryption validation.
*/
static bson_t *
create_schema (bson_t *kms_providers,
               const char *keyvault_db,
               const char *keyvault_coll,
               mongoc_client_t *keyvault_client,
               bson_error_t *error)
{
   mongoc_client_encryption_t *client_encryption = NULL;
   mongoc_client_encryption_opts_t *client_encryption_opts = NULL;
   mongoc_client_encryption_datakey_opts_t *datakey_opts = NULL;
   bson_value_t datakey_id = {0};
   char *keyaltnames[] = {"mongoc_encryption_example_2"};
   bson_t *schema = NULL;

   client_encryption_opts = mongoc_client_encryption_opts_new ();
   mongoc_client_encryption_opts_set_kms_providers (client_encryption_opts,
                                                    kms_providers);
   mongoc_client_encryption_opts_set_keyvault_namespace (
      client_encryption_opts, keyvault_db, keyvault_coll);
   mongoc_client_encryption_opts_set_keyvault_client (client_encryption_opts,
                                                      keyvault_client);

   client_encryption =
      mongoc_client_encryption_new (client_encryption_opts, error);
   if (!client_encryption) {
      goto fail;
   }

   /* Create a new data key and json schema for the encryptedField.
    * https://dochub.mongodb.org/core/client\-side\-field\-level\-encryption\-automatic\-encryption\-rules
    */
   datakey_opts = mongoc_client_encryption_datakey_opts_new ();
   mongoc_client_encryption_datakey_opts_set_keyaltnames (
      datakey_opts, keyaltnames, 1);
   if (!mongoc_client_encryption_create_datakey (
          client_encryption, "local", datakey_opts, &datakey_id, error)) {
      goto fail;
   }

   /* Create a schema describing that "encryptedField" is a string encrypted
    * with the newly created data key using deterministic encryption. */
   schema = BCON_NEW ("properties",
                      "{",
                      "encryptedField",
                      "{",
                      "encrypt",
                      "{",
                      "keyId",
                      "[",
                      BCON_BIN (datakey_id.value.v_binary.subtype,
                                datakey_id.value.v_binary.data,
                                datakey_id.value.v_binary.data_len),
                      "]",
                      "bsonType",
                      "string",
                      "algorithm",
                      MONGOC_AEAD_AES_256_CBC_HMAC_SHA_512_DETERMINISTIC,
                      "}",
                      "}",
                      "}",
                      "bsonType",
                      "object");

fail:
   mongoc_client_encryption_destroy (client_encryption);
   mongoc_client_encryption_datakey_opts_destroy (datakey_opts);
   mongoc_client_encryption_opts_destroy (client_encryption_opts);
   bson_value_destroy (&datakey_id);
   return schema;
}

/* This example demonstrates how to use automatic encryption with a server\-side
 * schema using the enterprise version of MongoDB */
int
main (int argc, char **argv)
{
/* The collection used to store the encryption data keys. */
#define KEYVAULT_DB "encryption"
#define KEYVAULT_COLL "__libmongocTestKeyVault"
/* The collection used to store the encrypted documents in this example. */
#define ENCRYPTED_DB "test"
#define ENCRYPTED_COLL "coll"

   int exit_status = EXIT_FAILURE;
   bool ret;
   uint8_t *local_masterkey = NULL;
   uint32_t local_masterkey_len;
   bson_t *kms_providers = NULL;
   bson_error_t error = {0};
   bson_t *index_keys = NULL;
   char *index_name = NULL;
   bson_t *create_index_cmd = NULL;
   bson_json_reader_t *reader = NULL;
   bson_t *schema = NULL;

   /* The MongoClient used to access the key vault (keyvault_namespace). */
   mongoc_client_t *keyvault_client = NULL;
   mongoc_collection_t *keyvault_coll = NULL;
   mongoc_auto_encryption_opts_t *auto_encryption_opts = NULL;
   mongoc_client_t *client = NULL;
   mongoc_collection_t *coll = NULL;
   bson_t *to_insert = NULL;
   mongoc_client_t *unencrypted_client = NULL;
   mongoc_collection_t *unencrypted_coll = NULL;
   bson_t *create_cmd = NULL;
   bson_t *create_cmd_opts = NULL;
   mongoc_write_concern_t *wc = NULL;

   mongoc_init ();

   /* Configure the master key. This must be the same master key that was used
    * to create
    * the encryption key. */
   local_masterkey =
      hex_to_bin (getenv ("LOCAL_MASTERKEY"), &local_masterkey_len);
   if (!local_masterkey || local_masterkey_len != 96) {
      fprintf (stderr,
               "Specify LOCAL_MASTERKEY environment variable as a "
               "secure random 96 byte hex value.\en");
      goto fail;
   }

   kms_providers = BCON_NEW ("local",
                             "{",
                             "key",
                             BCON_BIN (0, local_masterkey, local_masterkey_len),
                             "}");

   /* Set up the key vault for this example. */
   keyvault_client = mongoc_client_new (
      "mongodb://localhost/?appname=client\-side\-encryption\-keyvault");
   keyvault_coll = mongoc_client_get_collection (
      keyvault_client, KEYVAULT_DB, KEYVAULT_COLL);
   mongoc_collection_drop (keyvault_coll, NULL);

   /* Create a unique index to ensure that two data keys cannot share the same
    * keyAltName. This is recommended practice for the key vault. */
   index_keys = BCON_NEW ("keyAltNames", BCON_INT32 (1));
   index_name = mongoc_collection_keys_to_index_string (index_keys);
   create_index_cmd = BCON_NEW ("createIndexes",
                                KEYVAULT_COLL,
                                "indexes",
                                "[",
                                "{",
                                "key",
                                BCON_DOCUMENT (index_keys),
                                "name",
                                index_name,
                                "unique",
                                BCON_BOOL (true),
                                "partialFilterExpression",
                                "{",
                                "keyAltNames",
                                "{",
                                "$exists",
                                BCON_BOOL (true),
                                "}",
                                "}",
                                "}",
                                "]");
   ret = mongoc_client_command_simple (keyvault_client,
                                       KEYVAULT_DB,
                                       create_index_cmd,
                                       NULL /* read prefs */,
                                       NULL /* reply */,
                                       &error);

   if (!ret) {
      goto fail;
   }

   auto_encryption_opts = mongoc_auto_encryption_opts_new ();
   mongoc_auto_encryption_opts_set_keyvault_client (auto_encryption_opts,
                                                    keyvault_client);
   mongoc_auto_encryption_opts_set_keyvault_namespace (
      auto_encryption_opts, KEYVAULT_DB, KEYVAULT_COLL);
   mongoc_auto_encryption_opts_set_kms_providers (auto_encryption_opts,
                                                  kms_providers);
   schema = create_schema (
      kms_providers, KEYVAULT_DB, KEYVAULT_COLL, keyvault_client, &error);

   if (!schema) {
      goto fail;
   }

   client =
      mongoc_client_new ("mongodb://localhost/?appname=client\-side\-encryption");
   ret = mongoc_client_enable_auto_encryption (
      client, auto_encryption_opts, &error);
   if (!ret) {
      goto fail;
   }

   coll = mongoc_client_get_collection (client, ENCRYPTED_DB, ENCRYPTED_COLL);

   /* Clear old data */
   mongoc_collection_drop (coll, NULL);

   /* Create the collection with the encryption JSON Schema. */
   create_cmd = BCON_NEW ("create",
                          ENCRYPTED_COLL,
                          "validator",
                          "{",
                          "$jsonSchema",
                          BCON_DOCUMENT (schema),
                          "}");
   wc = mongoc_write_concern_new ();
   mongoc_write_concern_set_wmajority (wc, 0);
   create_cmd_opts = bson_new ();
   mongoc_write_concern_append (wc, create_cmd_opts);
   ret = mongoc_client_command_with_opts (client,
                                          ENCRYPTED_DB,
                                          create_cmd,
                                          NULL /* read prefs */,
                                          create_cmd_opts,
                                          NULL /* reply */,
                                          &error);
   if (!ret) {
      goto fail;
   }

   to_insert = BCON_NEW ("encryptedField", "123456789");
   ret = mongoc_collection_insert_one (
      coll, to_insert, NULL /* opts */, NULL /* reply */, &error);
   if (!ret) {
      goto fail;
   }
   printf ("decrypted document: ");
   if (!print_one_document (coll, &error)) {
      goto fail;
   }
   printf ("\en");

   unencrypted_client = mongoc_client_new (
      "mongodb://localhost/?appname=client\-side\-encryption\-unencrypted");
   unencrypted_coll = mongoc_client_get_collection (
      unencrypted_client, ENCRYPTED_DB, ENCRYPTED_COLL);
   printf ("encrypted document: ");
   if (!print_one_document (unencrypted_coll, &error)) {
      goto fail;
   }
   printf ("\en");

   /* Expect a server\-side error if inserting with the unencrypted collection.
    */
   ret = mongoc_collection_insert_one (
      unencrypted_coll, to_insert, NULL /* opts */, NULL /* reply */, &error);
   if (!ret) {
      printf ("insert with unencrypted collection failed: %s\en", error.message);
      memset (&error, 0, sizeof (error));
   }

   exit_status = EXIT_SUCCESS;
fail:
   if (error.code) {
      fprintf (stderr, "error: %s\en", error.message);
   }

   bson_free (local_masterkey);
   bson_destroy (kms_providers);
   mongoc_collection_destroy (keyvault_coll);
   bson_destroy (index_keys);
   bson_free (index_name);
   bson_destroy (create_index_cmd);
   bson_json_reader_destroy (reader);
   mongoc_auto_encryption_opts_destroy (auto_encryption_opts);
   mongoc_collection_destroy (coll);
   mongoc_client_destroy (client);
   bson_destroy (to_insert);
   mongoc_collection_destroy (unencrypted_coll);
   mongoc_client_destroy (unencrypted_client);
   mongoc_client_destroy (keyvault_client);
   bson_destroy (schema);
   bson_destroy (create_cmd);
   bson_destroy (create_cmd_opts);
   mongoc_write_concern_destroy (wc);

   mongoc_cleanup ();
   return exit_status;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Explicit Encryption
.sp
Explicit encryption is a MongoDB community feature and does not use the mongocryptd process. Explicit encryption is provided by the \fBmongoc_client_encryption_t\fP class, for example:
.sp
client\-side\-encryption\-explicit.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>
#include <stdio.h>
#include <stdlib.h>

#include "client\-side\-encryption\-helpers.h"

/* This example demonstrates how to use explicit encryption and decryption using
 * the community version of MongoDB */
int
main (int argc, char **argv)
{
/* The collection used to store the encryption data keys. */
#define KEYVAULT_DB "encryption"
#define KEYVAULT_COLL "__libmongocTestKeyVault"
/* The collection used to store the encrypted documents in this example. */
#define ENCRYPTED_DB "test"
#define ENCRYPTED_COLL "coll"

   int exit_status = EXIT_FAILURE;
   bool ret;
   uint8_t *local_masterkey = NULL;
   uint32_t local_masterkey_len;
   bson_t *kms_providers = NULL;
   bson_error_t error = {0};
   bson_t *index_keys = NULL;
   char *index_name = NULL;
   bson_t *create_index_cmd = NULL;
   bson_t *schema = NULL;
   mongoc_client_t *client = NULL;
   mongoc_collection_t *coll = NULL;
   mongoc_collection_t *keyvault_coll = NULL;
   bson_t *to_insert = NULL;
   bson_t *create_cmd = NULL;
   bson_t *create_cmd_opts = NULL;
   mongoc_write_concern_t *wc = NULL;
   mongoc_client_encryption_t *client_encryption = NULL;
   mongoc_client_encryption_opts_t *client_encryption_opts = NULL;
   mongoc_client_encryption_datakey_opts_t *datakey_opts = NULL;
   char *keyaltnames[] = {"mongoc_encryption_example_3"};
   bson_value_t datakey_id = {0};
   bson_value_t encrypted_field = {0};
   bson_value_t to_encrypt = {0};
   mongoc_client_encryption_encrypt_opts_t *encrypt_opts = NULL;
   bson_value_t decrypted = {0};

   mongoc_init ();

   /* Configure the master key. This must be the same master key that was used
    * to create the encryption key. */
   local_masterkey =
      hex_to_bin (getenv ("LOCAL_MASTERKEY"), &local_masterkey_len);
   if (!local_masterkey || local_masterkey_len != 96) {
      fprintf (stderr,
               "Specify LOCAL_MASTERKEY environment variable as a "
               "secure random 96 byte hex value.\en");
      goto fail;
   }

   kms_providers = BCON_NEW ("local",
                             "{",
                             "key",
                             BCON_BIN (0, local_masterkey, local_masterkey_len),
                             "}");

   /* The mongoc_client_t used to read/write application data. */
   client =
      mongoc_client_new ("mongodb://localhost/?appname=client\-side\-encryption");
   coll = mongoc_client_get_collection (client, ENCRYPTED_DB, ENCRYPTED_COLL);

   /* Clear old data */
   mongoc_collection_drop (coll, NULL);

   /* Set up the key vault for this example. */
   keyvault_coll =
      mongoc_client_get_collection (client, KEYVAULT_DB, KEYVAULT_COLL);
   mongoc_collection_drop (keyvault_coll, NULL);

   /* Create a unique index to ensure that two data keys cannot share the same
    * keyAltName. This is recommended practice for the key vault. */
   index_keys = BCON_NEW ("keyAltNames", BCON_INT32 (1));
   index_name = mongoc_collection_keys_to_index_string (index_keys);
   create_index_cmd = BCON_NEW ("createIndexes",
                                KEYVAULT_COLL,
                                "indexes",
                                "[",
                                "{",
                                "key",
                                BCON_DOCUMENT (index_keys),
                                "name",
                                index_name,
                                "unique",
                                BCON_BOOL (true),
                                "partialFilterExpression",
                                "{",
                                "keyAltNames",
                                "{",
                                "$exists",
                                BCON_BOOL (true),
                                "}",
                                "}",
                                "}",
                                "]");
   ret = mongoc_client_command_simple (client,
                                       KEYVAULT_DB,
                                       create_index_cmd,
                                       NULL /* read prefs */,
                                       NULL /* reply */,
                                       &error);

   if (!ret) {
      goto fail;
   }

   client_encryption_opts = mongoc_client_encryption_opts_new ();
   mongoc_client_encryption_opts_set_kms_providers (client_encryption_opts,
                                                    kms_providers);
   mongoc_client_encryption_opts_set_keyvault_namespace (
      client_encryption_opts, KEYVAULT_DB, KEYVAULT_COLL);

   /* Set a mongoc_client_t to use for reading/writing to the key vault. This
    * can be the same mongoc_client_t used by the main application. */
   mongoc_client_encryption_opts_set_keyvault_client (client_encryption_opts,
                                                      client);
   client_encryption =
      mongoc_client_encryption_new (client_encryption_opts, &error);
   if (!client_encryption) {
      goto fail;
   }

   /* Create a new data key for the encryptedField.
    * https://dochub.mongodb.org/core/client\-side\-field\-level\-encryption\-automatic\-encryption\-rules
    */
   datakey_opts = mongoc_client_encryption_datakey_opts_new ();
   mongoc_client_encryption_datakey_opts_set_keyaltnames (
      datakey_opts, keyaltnames, 1);
   if (!mongoc_client_encryption_create_datakey (
          client_encryption, "local", datakey_opts, &datakey_id, &error)) {
      goto fail;
   }

   /* Explicitly encrypt a field */
   encrypt_opts = mongoc_client_encryption_encrypt_opts_new ();
   mongoc_client_encryption_encrypt_opts_set_algorithm (
      encrypt_opts, MONGOC_AEAD_AES_256_CBC_HMAC_SHA_512_DETERMINISTIC);
   mongoc_client_encryption_encrypt_opts_set_keyid (encrypt_opts, &datakey_id);
   to_encrypt.value_type = BSON_TYPE_UTF8;
   to_encrypt.value.v_utf8.str = "123456789";
   to_encrypt.value.v_utf8.len = strlen (to_encrypt.value.v_utf8.str);

   ret = mongoc_client_encryption_encrypt (
      client_encryption, &to_encrypt, encrypt_opts, &encrypted_field, &error);
   if (!ret) {
      goto fail;
   }

   to_insert = bson_new ();
   BSON_APPEND_VALUE (to_insert, "encryptedField", &encrypted_field);
   ret = mongoc_collection_insert_one (
      coll, to_insert, NULL /* opts */, NULL /* reply */, &error);
   if (!ret) {
      goto fail;
   }

   printf ("encrypted document: ");
   if (!print_one_document (coll, &error)) {
      goto fail;
   }
   printf ("\en");

   /* Explicitly decrypt a field */
   ret = mongoc_client_encryption_decrypt (
      client_encryption, &encrypted_field, &decrypted, &error);
   if (!ret) {
      goto fail;
   }
   printf ("decrypted value: %s\en", decrypted.value.v_utf8.str);

   exit_status = EXIT_SUCCESS;
fail:
   if (error.code) {
      fprintf (stderr, "error: %s\en", error.message);
   }

   bson_free (local_masterkey);
   bson_destroy (kms_providers);
   mongoc_collection_destroy (keyvault_coll);
   bson_destroy (index_keys);
   bson_free (index_name);
   bson_destroy (create_index_cmd);
   mongoc_collection_destroy (coll);
   mongoc_client_destroy (client);
   bson_destroy (to_insert);
   bson_destroy (schema);
   bson_destroy (create_cmd);
   bson_destroy (create_cmd_opts);
   mongoc_write_concern_destroy (wc);
   mongoc_client_encryption_destroy (client_encryption);
   mongoc_client_encryption_datakey_opts_destroy (datakey_opts);
   mongoc_client_encryption_opts_destroy (client_encryption_opts);
   bson_value_destroy (&encrypted_field);
   mongoc_client_encryption_encrypt_opts_destroy (encrypt_opts);
   bson_value_destroy (&decrypted);
   bson_value_destroy (&datakey_id);

   mongoc_cleanup ();
   return exit_status;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Explicit Encryption with Automatic Decryption
.sp
Although automatic encryption requires MongoDB 4.2 enterprise or a MongoDB 4.2 Atlas cluster, automatic decryption is supported for all users. To configure automatic decryption without automatic encryption set bypass_auto_encryption=True in \fBmongoc_auto_encryption_opts_t\fP:
.sp
client\-side\-encryption\-auto\-decryption.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>
#include <stdio.h>
#include <stdlib.h>

#include "client\-side\-encryption\-helpers.h"

/* This example demonstrates how to set up automatic decryption without
 * automatic encryption using the community version of MongoDB */
int
main (int argc, char **argv)
{
/* The collection used to store the encryption data keys. */
#define KEYVAULT_DB "encryption"
#define KEYVAULT_COLL "__libmongocTestKeyVault"
/* The collection used to store the encrypted documents in this example. */
#define ENCRYPTED_DB "test"
#define ENCRYPTED_COLL "coll"

   int exit_status = EXIT_FAILURE;
   bool ret;
   uint8_t *local_masterkey = NULL;
   uint32_t local_masterkey_len;
   bson_t *kms_providers = NULL;
   bson_error_t error = {0};
   bson_t *index_keys = NULL;
   char *index_name = NULL;
   bson_t *create_index_cmd = NULL;
   bson_t *schema = NULL;
   mongoc_client_t *client = NULL;
   mongoc_collection_t *coll = NULL;
   mongoc_collection_t *keyvault_coll = NULL;
   bson_t *to_insert = NULL;
   bson_t *create_cmd = NULL;
   bson_t *create_cmd_opts = NULL;
   mongoc_write_concern_t *wc = NULL;
   mongoc_client_encryption_t *client_encryption = NULL;
   mongoc_client_encryption_opts_t *client_encryption_opts = NULL;
   mongoc_client_encryption_datakey_opts_t *datakey_opts = NULL;
   char *keyaltnames[] = {"mongoc_encryption_example_4"};
   bson_value_t datakey_id = {0};
   bson_value_t encrypted_field = {0};
   bson_value_t to_encrypt = {0};
   mongoc_client_encryption_encrypt_opts_t *encrypt_opts = NULL;
   bson_value_t decrypted = {0};
   mongoc_auto_encryption_opts_t *auto_encryption_opts = NULL;
   mongoc_client_t *unencrypted_client = NULL;
   mongoc_collection_t *unencrypted_coll = NULL;

   mongoc_init ();

   /* Configure the master key. This must be the same master key that was used
    * to create the encryption key. */
   local_masterkey =
      hex_to_bin (getenv ("LOCAL_MASTERKEY"), &local_masterkey_len);
   if (!local_masterkey || local_masterkey_len != 96) {
      fprintf (stderr,
               "Specify LOCAL_MASTERKEY environment variable as a "
               "secure random 96 byte hex value.\en");
      goto fail;
   }

   kms_providers = BCON_NEW ("local",
                             "{",
                             "key",
                             BCON_BIN (0, local_masterkey, local_masterkey_len),
                             "}");

   client =
      mongoc_client_new ("mongodb://localhost/?appname=client\-side\-encryption");
   auto_encryption_opts = mongoc_auto_encryption_opts_new ();
   mongoc_auto_encryption_opts_set_keyvault_namespace (
      auto_encryption_opts, KEYVAULT_DB, KEYVAULT_COLL);
   mongoc_auto_encryption_opts_set_kms_providers (auto_encryption_opts,
                                                  kms_providers);

   /* Setting bypass_auto_encryption to true disables automatic encryption but
    * keeps the automatic decryption behavior. bypass_auto_encryption will also
    * disable spawning mongocryptd */
   mongoc_auto_encryption_opts_set_bypass_auto_encryption (auto_encryption_opts,
                                                           true);

   /* Once bypass_auto_encryption is set, community users can enable auto
    * encryption on the client. This will, in fact, only perform automatic
    * decryption. */
   ret = mongoc_client_enable_auto_encryption (
      client, auto_encryption_opts, &error);
   if (!ret) {
      goto fail;
   }

   /* Now that automatic decryption is on, we can test it by inserting a
    * document with an explicitly encrypted value into the collection. When we
    * look up the document later, it should be automatically decrypted for us.
    */
   coll = mongoc_client_get_collection (client, ENCRYPTED_DB, ENCRYPTED_COLL);

   /* Clear old data */
   mongoc_collection_drop (coll, NULL);

   /* Set up the key vault for this example. */
   keyvault_coll =
      mongoc_client_get_collection (client, KEYVAULT_DB, KEYVAULT_COLL);
   mongoc_collection_drop (keyvault_coll, NULL);

   /* Create a unique index to ensure that two data keys cannot share the same
    * keyAltName. This is recommended practice for the key vault. */
   index_keys = BCON_NEW ("keyAltNames", BCON_INT32 (1));
   index_name = mongoc_collection_keys_to_index_string (index_keys);
   create_index_cmd = BCON_NEW ("createIndexes",
                                KEYVAULT_COLL,
                                "indexes",
                                "[",
                                "{",
                                "key",
                                BCON_DOCUMENT (index_keys),
                                "name",
                                index_name,
                                "unique",
                                BCON_BOOL (true),
                                "partialFilterExpression",
                                "{",
                                "keyAltNames",
                                "{",
                                "$exists",
                                BCON_BOOL (true),
                                "}",
                                "}",
                                "}",
                                "]");
   ret = mongoc_client_command_simple (client,
                                       KEYVAULT_DB,
                                       create_index_cmd,
                                       NULL /* read prefs */,
                                       NULL /* reply */,
                                       &error);

   if (!ret) {
      goto fail;
   }

   client_encryption_opts = mongoc_client_encryption_opts_new ();
   mongoc_client_encryption_opts_set_kms_providers (client_encryption_opts,
                                                    kms_providers);
   mongoc_client_encryption_opts_set_keyvault_namespace (
      client_encryption_opts, KEYVAULT_DB, KEYVAULT_COLL);

   /* The key vault client is used for reading to/from the key vault. This can
    * be the same mongoc_client_t used by the application. */
   mongoc_client_encryption_opts_set_keyvault_client (client_encryption_opts,
                                                      client);
   client_encryption =
      mongoc_client_encryption_new (client_encryption_opts, &error);
   if (!client_encryption) {
      goto fail;
   }

   /* Create a new data key for the encryptedField.
    * https://dochub.mongodb.org/core/client\-side\-field\-level\-encryption\-automatic\-encryption\-rules
    */
   datakey_opts = mongoc_client_encryption_datakey_opts_new ();
   mongoc_client_encryption_datakey_opts_set_keyaltnames (
      datakey_opts, keyaltnames, 1);
   ret = mongoc_client_encryption_create_datakey (
      client_encryption, "local", datakey_opts, &datakey_id, &error);
   if (!ret) {
      goto fail;
   }

   /* Explicitly encrypt a field. */
   encrypt_opts = mongoc_client_encryption_encrypt_opts_new ();
   mongoc_client_encryption_encrypt_opts_set_algorithm (
      encrypt_opts, MONGOC_AEAD_AES_256_CBC_HMAC_SHA_512_DETERMINISTIC);
   mongoc_client_encryption_encrypt_opts_set_keyaltname (
      encrypt_opts, "mongoc_encryption_example_4");
   to_encrypt.value_type = BSON_TYPE_UTF8;
   to_encrypt.value.v_utf8.str = "123456789";
   to_encrypt.value.v_utf8.len = strlen (to_encrypt.value.v_utf8.str);

   ret = mongoc_client_encryption_encrypt (
      client_encryption, &to_encrypt, encrypt_opts, &encrypted_field, &error);
   if (!ret) {
      goto fail;
   }

   to_insert = bson_new ();
   BSON_APPEND_VALUE (to_insert, "encryptedField", &encrypted_field);
   ret = mongoc_collection_insert_one (
      coll, to_insert, NULL /* opts */, NULL /* reply */, &error);
   if (!ret) {
      goto fail;
   }

   /* When we retrieve the document, any encrypted fields will get automatically
    * decrypted by the driver. */
   printf ("decrypted document: ");
   if (!print_one_document (coll, &error)) {
      goto fail;
   }
   printf ("\en");

   unencrypted_client =
      mongoc_client_new ("mongodb://localhost/?appname=client\-side\-encryption");
   unencrypted_coll = mongoc_client_get_collection (
      unencrypted_client, ENCRYPTED_DB, ENCRYPTED_COLL);

   printf ("encrypted document: ");
   if (!print_one_document (unencrypted_coll, &error)) {
      goto fail;
   }
   printf ("\en");

   exit_status = EXIT_SUCCESS;
fail:
   if (error.code) {
      fprintf (stderr, "error: %s\en", error.message);
   }

   bson_free (local_masterkey);
   bson_destroy (kms_providers);
   mongoc_collection_destroy (keyvault_coll);
   bson_destroy (index_keys);
   bson_free (index_name);
   bson_destroy (create_index_cmd);
   mongoc_collection_destroy (coll);
   mongoc_client_destroy (client);
   bson_destroy (to_insert);
   bson_destroy (schema);
   bson_destroy (create_cmd);
   bson_destroy (create_cmd_opts);
   mongoc_write_concern_destroy (wc);
   mongoc_client_encryption_destroy (client_encryption);
   mongoc_client_encryption_datakey_opts_destroy (datakey_opts);
   mongoc_client_encryption_opts_destroy (client_encryption_opts);
   bson_value_destroy (&encrypted_field);
   mongoc_client_encryption_encrypt_opts_destroy (encrypt_opts);
   bson_value_destroy (&decrypted);
   bson_value_destroy (&datakey_id);
   mongoc_collection_destroy (unencrypted_coll);
   mongoc_client_destroy (unencrypted_client);
   mongoc_auto_encryption_opts_destroy (auto_encryption_opts);

   mongoc_cleanup ();
   return exit_status;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS API Reference
.SS Initialization and cleanup
.SS Synopsis
.sp
Initialize the MongoDB C Driver by calling \fBmongoc_init\fP exactly once at the beginning of your program. It is responsible for initializing global state such as process counters, SSL, and threading primitives.
.sp
Exception to this is \fBmongoc_log_set_handler()\fP, which should be called before \fBmongoc_init()\fP or some log traces would not use your log handling function. See Custom Log Handlers for a detailed example.
.sp
Call \fBmongoc_cleanup\fP exactly once at the end of your program to release all memory and other resources allocated by the driver. You must not call any other MongoDB C Driver functions after \fBmongoc_cleanup\fP\&. Note that \fBmongoc_init\fP does \fBnot\fP reinitialize the driver after \fBmongoc_cleanup\fP\&.
.SS Deprecated feature: automatic initialization and cleanup
.sp
On some platforms the driver can automatically call \fBmongoc_init\fP before \fBmain\fP, and call \fBmongoc_cleanup\fP as the process exits. This is problematic in situations where related libraries also execute cleanup code on shutdown, and it creates inconsistent rules across platforms. Therefore the automatic initialization and cleanup feature is deprecated, and will be dropped in version 2.0. Meanwhile, for backward compatibility, the feature is \fIenabled\fP by default on platforms where it is available.
.sp
For portable, future\-proof code, always call \fBmongoc_init\fP and \fBmongoc_cleanup\fP yourself, and configure the driver like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cmake \-DENABLE_AUTOMATIC_INIT_AND_CLEANUP=OFF
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Logging
.sp
MongoDB C driver Logging Abstraction
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef enum {
   MONGOC_LOG_LEVEL_ERROR,
   MONGOC_LOG_LEVEL_CRITICAL,
   MONGOC_LOG_LEVEL_WARNING,
   MONGOC_LOG_LEVEL_MESSAGE,
   MONGOC_LOG_LEVEL_INFO,
   MONGOC_LOG_LEVEL_DEBUG,
   MONGOC_LOG_LEVEL_TRACE,
} mongoc_log_level_t;

#define MONGOC_ERROR(...)
#define MONGOC_CRITICAL(...)
#define MONGOC_WARNING(...)
#define MONGOC_MESSAGE(...)
#define MONGOC_INFO(...)
#define MONGOC_DEBUG(...)

typedef void (*mongoc_log_func_t) (mongoc_log_level_t log_level,
                                   const char *log_domain,
                                   const char *message,
                                   void *user_data);

void
mongoc_log_set_handler (mongoc_log_func_t log_func, void *user_data);
void
mongoc_log (mongoc_log_level_t log_level,
            const char *log_domain,
            const char *format,
            ...) BSON_GNUC_PRINTF (3, 4);
const char *
mongoc_log_level_str (mongoc_log_level_t log_level);
void
mongoc_log_default_handler (mongoc_log_level_t log_level,
                            const char *log_domain,
                            const char *message,
                            void *user_data);
void
mongoc_log_trace_enable (void);
void
mongoc_log_trace_disable (void);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The MongoDB C driver comes with an abstraction for logging that you can use in your application, or integrate with an existing logging system.
.SS Macros
.sp
To make logging a little less painful, various helper macros are provided. See the following example.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#undef MONGOC_LOG_DOMAIN
#define MONGOC_LOG_DOMAIN "my\-custom\-domain"

MONGOC_WARNING ("An error occurred: %s", strerror (errno));
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Custom Log Handlers
.INDENT 0.0
.TP
.B The default log handler prints a timestamp and the log message to \fBstdout\fP, or to \fBstderr\fP for warnings, critical messages, and errors.
You can override the handler with \fBmongoc_log_set_handler()\fP\&.
Your handler function is called in a mutex for thread safety.
.UNINDENT
.sp
For example, you could register a custom handler to suppress messages at INFO level and below:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void
my_logger (mongoc_log_level_t log_level,
           const char *log_domain,
           const char *message,
           void *user_data)
{
   /* smaller values are more important */
   if (log_level < MONGOC_LOG_LEVEL_INFO) {
      mongoc_log_default_handler (log_level, log_domain, message, user_data);
   }
}

int
main (int argc, char *argv[])
{
   mongoc_log_set_handler (my_logger, NULL);
   mongoc_init ();

   /* ... your code ...  */

   mongoc_cleanup ();
   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that in the example above \fBmongoc_log_set_handler()\fP is called before \fBmongoc_init()\fP\&.
Otherwise, some log traces could not be processed by the log handler.
.sp
To restore the default handler:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_log_set_handler (mongoc_log_default_handler, NULL);
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Disable logging
.sp
To disable all logging, including warnings, critical messages and errors, provide an empty log handler:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_log_set_handler (NULL, NULL);
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Tracing
.sp
If compiling your own copy of the MongoDB C driver, consider configuring with \fB\-DENABLE_TRACING=ON\fP to enable function tracing and hex dumps of network packets to \fBSTDERR\fP and \fBSTDOUT\fP during development and debugging.
.sp
This is especially useful when debugging what may be going on internally in the driver.
.sp
Trace messages can be enabled and disabled by calling \fBmongoc_log_trace_enable()\fP and \fBmongoc_log_trace_disable()\fP
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Compiling the driver with \fB\-DENABLE_TRACING=ON\fP will affect its performance. Disabling tracing with \fBmongoc_log_trace_disable()\fP significantly reduces the overhead, but cannot remove it completely.
.UNINDENT
.UNINDENT
 index
.SS Error Reporting
.SS Description
.sp
Many C Driver functions report errors by returning \fBfalse\fP or \-1 and filling out a \fI\%bson_error_t\fP structure with an error domain, error code, and message. Use \fBdomain\fP to determine which subsystem generated the error, and \fBcode\fP for the specific error. \fBmessage\fP is a human\-readable error description.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fI\%Handling Errors in libbson\fP\&.
.fi
.sp
.UNINDENT
.UNINDENT
.TS
center;
|l|l|l|.
_
T{
Domain
T}	T{
Code
T}	T{
Description
T}
_
T{
\fBMONGOC_ERROR_CLIENT\fP
T}	T{
\fBMONGOC_ERROR_CLIENT_TOO_BIG\fP
T}	T{
You tried to send a message larger than the server\(aqs max message size.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_CLIENT_AUTHENTICATE\fP
T}	T{
Wrong credentials, or failure sending or receiving authentication messages.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_CLIENT_NO_ACCEPTABLE_PEER\fP
T}	T{
You tried an TLS connection but the driver was not built with TLS.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_CLIENT_IN_EXHAUST\fP
T}	T{
You began iterating an exhaust cursor, then tried to begin another operation with the same \fBmongoc_client_t\fP\&.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_CLIENT_SESSION_FAILURE\fP
T}	T{
Failure related to creating or using a logical session.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_CLIENT_INVALID_ENCRYPTION_ARG\fP
T}	T{
Failure related to arguments passed when initializing Client\-Side Field Level Encryption.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_CLIENT_INVALID_ENCRYPTION_STATE\fP
T}	T{
Failure related to Client\-Side Field Level Encryption.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_CLIENT_INVALID_LOAD_BALANCER\fP
T}	T{
You attempted to connect to a MongoDB server behind a load balancer, but the server does not advertize load balanced support.
T}
_
T{
\fBMONGOC_ERROR_STREAM\fP
T}	T{
\fBMONGOC_ERROR_STREAM_NAME_RESOLUTION\fP
T}	T{
DNS failure.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_STREAM_SOCKET\fP
T}	T{
Timeout communicating with server, or connection closed.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_STREAM_CONNECT\fP
T}	T{
Failed to connect to server.
T}
_
T{
\fBMONGOC_ERROR_PROTOCOL\fP
T}	T{
\fBMONGOC_ERROR_PROTOCOL_INVALID_REPLY\fP
T}	T{
Corrupt response from server.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_PROTOCOL_BAD_WIRE_VERSION\fP
T}	T{
The server version is too old or too new to communicate with the driver.
T}
_
T{
\fBMONGOC_ERROR_CURSOR\fP
T}	T{
\fBMONGOC_ERROR_CURSOR_INVALID_CURSOR\fP
T}	T{
You passed bad arguments to \fBmongoc_collection_find_with_opts\fP, or you called \fBmongoc_cursor_next\fP on a completed or failed cursor, or the cursor timed out on the server.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_CHANGE_STREAM_NO_RESUME_TOKEN\fP
T}	T{
A resume token was not returned in a document found with \fBmongoc_change_stream_next\fP
T}
_
T{
\fBMONGOC_ERROR_QUERY\fP
T}	T{
\fBMONGOC_ERROR_QUERY_FAILURE\fP
T}	T{
\fI\%Error API Version 1\fP: Server error from command or query. The server error message is in \fBmessage\fP\&.
T}
_
T{
\fBMONGOC_ERROR_SERVER\fP
T}	T{
\fBMONGOC_ERROR_QUERY_FAILURE\fP
T}	T{
\fI\%Error API Version 2\fP: Server error from command or query. The server error message is in \fBmessage\fP\&.
T}
_
T{
\fBMONGOC_ERROR_SASL\fP
T}	T{
A SASL error code.
T}	T{
\fBman sasl_errors\fP for a list of codes.
T}
_
T{
\fBMONGOC_ERROR_BSON\fP
T}	T{
\fBMONGOC_ERROR_BSON_INVALID\fP
T}	T{
You passed an invalid or oversized BSON document as a parameter, or called \fBmongoc_collection_create_index\fP with invalid keys, or the server reply was corrupt.
T}
_
T{
\fBMONGOC_ERROR_NAMESPACE\fP
T}	T{
\fBMONGOC_ERROR_NAMESPACE_INVALID\fP
T}	T{
You tried to create a collection with an invalid name.
T}
_
T{
\fBMONGOC_ERROR_COMMAND\fP
T}	T{
\fBMONGOC_ERROR_COMMAND_INVALID_ARG\fP
T}	T{
Many functions set this error code when passed bad parameters. Print the error message for details.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_PROTOCOL_BAD_WIRE_VERSION\fP
T}	T{
You tried to use a command option the server does not support.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_DUPLICATE_KEY\fP
T}	T{
An insert or update failed because because of a duplicate \fB_id\fP or other unique\-index violation.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_MAX_TIME_MS_EXPIRED\fP
T}	T{
The operation failed because maxTimeMS expired.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_SERVER_SELECTION_INVALID_ID\fP
T}	T{
The \fBserverId\fP option for an operation conflicts with the pinned server for that operation\(aqs client session (denoted by the \fBsessionId\fP option).
T}
_
T{
\fBMONGOC_ERROR_COMMAND\fP
T}	T{
\fI\%Error code from server\fP\&.
T}	T{
\fI\%Error API Version 1\fP: Server error from a command. The server error message is in \fBmessage\fP\&.
T}
_
T{
\fBMONGOC_ERROR_SERVER\fP
T}	T{
\fI\%Error code from server\fP\&.
T}	T{
\fI\%Error API Version 2\fP: Server error from a command. The server error message is in \fBmessage\fP\&.
T}
_
T{
\fBMONGOC_ERROR_COLLECTION\fP
T}	T{
\fBMONGOC_ERROR_COLLECTION_INSERT_FAILED\fP, \fBMONGOC_ERROR_COLLECTION_UPDATE_FAILED\fP, \fBMONGOC_ERROR_COLLECTION_DELETE_FAILED\fP\&.
T}	T{
Invalid or empty input to \fBmongoc_collection_insert_one\fP, \fBmongoc_collection_insert_bulk\fP, \fBmongoc_collection_update_one\fP, \fBmongoc_collection_update_many\fP, \fBmongoc_collection_replace_one\fP, \fBmongoc_collection_delete_one\fP, or \fBmongoc_collection_delete_many\fP\&.
T}
_
T{
\fBMONGOC_ERROR_COLLECTION\fP
T}	T{
\fI\%Error code from server\fP\&.
T}	T{
\fI\%Error API Version 1\fP: Server error from \fBmongoc_collection_insert_one\fP, \fBmongoc_collection_insert_bulk\fP, \fBmongoc_collection_update_one\fP, \fBmongoc_collection_update_many\fP, \fBmongoc_collection_replace_one\fP,
T}
_
T{
\fBMONGOC_ERROR_SERVER\fP
T}	T{
\fI\%Error code from server\fP\&.
T}	T{
\fI\%Error API Version 2\fP: Server error from \fBmongoc_collection_insert_one\fP, \fBmongoc_collection_insert_bulk\fP, \fBmongoc_collection_update_one\fP, \fBmongoc_collection_update_many\fP, \fBmongoc_collection_replace_one\fP,
T}
_
T{
\fBMONGOC_ERROR_GRIDFS\fP
T}	T{
\fBMONGOC_ERROR_GRIDFS_CHUNK_MISSING\fP
T}	T{
The GridFS file is missing a document in its \fBchunks\fP collection.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_GRIDFS_CORRUPT\fP
T}	T{
A data inconsistency was detected in GridFS.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_GRIDFS_INVALID_FILENAME\fP
T}	T{
You passed a NULL filename to \fBmongoc_gridfs_remove_by_filename\fP\&.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_GRIDFS_PROTOCOL_ERROR\fP
T}	T{
You called \fBmongoc_gridfs_file_set_id\fP after \fBmongoc_gridfs_file_save\fP, or tried to write on a closed GridFS stream.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_GRIDFS_BUCKET_FILE_NOT_FOUND\fP
T}	T{
A GridFS file is missing from \fBfiles\fP collection.
T}
_
T{
T}	T{
\fBMONGOC_ERROR_GRIDFS_BUCKET_STREAM\fP
T}	T{
An error occurred on a stream created from a GridFS operation like \fBmongoc_gridfs_bucket_upload_from_stream\fP\&.
T}
_
T{
\fBMONGOC_ERROR_SCRAM\fP
T}	T{
\fBMONGOC_ERROR_SCRAM_PROTOCOL_ERROR\fP
T}	T{
Failure in SCRAM\-SHA\-1 authentication.
T}
_
T{
\fBMONGOC_ERROR_SERVER_SELECTION\fP
T}	T{
\fBMONGOC_ERROR_SERVER_SELECTION_FAILURE\fP
T}	T{
No replica set member or mongos is available, or none matches your read preference, or you supplied an invalid \fBmongoc_read_prefs_t\fP\&.
T}
_
T{
\fBMONGOC_ERROR_WRITE_CONCERN\fP
T}	T{
\fI\%Error code from server\fP\&.
T}	T{
There was a write concern error or timeout from the server.
T}
_
T{
\fBMONGOC_ERROR_TRANSACTION\fP
T}	T{
\fBMONGOC_ERROR_TRANSACTION_INVALID\fP
T}	T{
You attempted to start a transaction when one is already in progress, or commit or abort when there is no transaction.
T}
_
T{
\fBMONGOC_ERROR_CLIENT_SIDE_ENCRYPTION\fP
T}	T{
Error code produced by libmongocrypt.
T}	T{
An error occurred in the library responsible for Client Side Encryption
T}
_
.TE
.SS Error Labels
.sp
In some cases your application must make decisions based on what category of error the driver has returned, but these categories do not correspond perfectly to an error domain or code. In such cases, error \fIlabels\fP provide a reliable way to determine how your application should respond to an error.
.sp
Any C Driver function that has a \fI\%bson_t\fP out\-parameter named \fBreply\fP may include error labels to the reply, in the form of a BSON field named "errorLabels" containing an array of strings:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{ "errorLabels": [ "TransientTransactionError" ] }
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Use \fBmongoc_error_has_label\fP to test if a reply contains a specific label. See \fBmongoc_client_session_start_transaction\fP for example code that demonstrates the use of error labels in application logic.
.sp
The following error labels are currently defined. Future versions of MongoDB may introduce new labels.
.SS TransientTransactionError
.sp
Within a multi\-document transaction, certain errors can leave the transaction in an unknown or aborted state. These include write conflicts, primary stepdowns, and network errors. In response, the application should abort the transaction and try the same sequence of operations again in a new transaction.
.SS UnknownTransactionCommitResult
.sp
When \fBmongoc_client_session_commit_transaction\fP encounters a network error or certain server errors, it is not known whether the transaction was committed. Applications should attempt to commit the transaction again until: the commit succeeds, the commit fails with an error \fInot\fP labeled "UnknownTransactionCommitResult", or the application chooses to give up.
.SS Setting the Error API Version
.sp
The driver\(aqs error reporting began with a design flaw: when the error \fIdomain\fP is \fBMONGOC_ERROR_COLLECTION\fP, \fBMONGOC_ERROR_QUERY\fP, or \fBMONGOC_ERROR_COMMAND\fP, the error \fIcode\fP might originate from the server or the driver. An application cannot always know where an error originated, and therefore cannot tell what the code means.
.sp
For example, if \fBmongoc_collection_update_one\fP sets the error\(aqs domain to \fBMONGOC_ERROR_COLLECTION\fP and its code to 24, the application cannot know whether 24 is the generic driver error code \fBMONGOC_ERROR_COLLECTION_UPDATE_FAILED\fP or the specific server error code "LockTimeout".
.sp
To fix this flaw while preserving backward compatibility, the C Driver 1.4 introduces "Error API Versions". Version 1, the default Error API Version, maintains the flawed behavior. Version 2 adds a new error domain, \fBMONGOC_ERROR_SERVER\fP\&. In Version 2, error codes originating on the server always have error domain \fBMONGOC_ERROR_SERVER\fP or \fBMONGOC_ERROR_WRITE_CONCERN\fP\&. When the driver uses Version 2 the application can always determine the origin and meaning of error codes. New applications should use Version 2, and existing applications should be updated to use Version 2 as well.
.TS
center;
|l|l|l|.
_
T{
Error Source
T}	T{
API Version 1
T}	T{
API Version 2
T}
_
T{
\fBmongoc_cursor_error\fP
T}	T{
\fBMONGOC_ERROR_QUERY\fP
T}	T{
\fBMONGOC_ERROR_SERVER\fP
T}
_
T{
\fBmongoc_client_command_with_opts\fP,
\fBmongoc_database_command_with_opts\fP, and
other command functions
T}	T{
\fBMONGOC_ERROR_QUERY\fP
T}	T{
\fBMONGOC_ERROR_SERVER\fP
T}
_
T{
\fBmongoc_collection_count_with_opts\fP
\fBmongoc_client_get_database_names_with_opts\fP,
and other command helper functions
T}	T{
\fBMONGOC_ERROR_QUERY\fP
T}	T{
\fBMONGOC_ERROR_SERVER\fP
T}
_
T{
\fBmongoc_collection_insert_one\fP
\fBmongoc_collection_insert_bulk\fP
\fBmongoc_collection_update_one\fP
\fBmongoc_collection_update_many\fP
\fBmongoc_collection_replace_one\fP
\fBmongoc_collection_delete_one\fP
\fBmongoc_collection_delete_many\fP
T}	T{
\fBMONGOC_ERROR_COMMAND\fP
T}	T{
\fBMONGOC_ERROR_SERVER\fP
T}
_
T{
\fBmongoc_bulk_operation_execute\fP
T}	T{
\fBMONGOC_ERROR_COMMAND\fP
T}	T{
\fBMONGOC_ERROR_SERVER\fP
T}
_
T{
Write\-concern timeout
T}	T{
\fBMONGOC_ERROR_WRITE_CONCERN\fP
T}	T{
\fBMONGOC_ERROR_WRITE_CONCERN\fP
T}
_
.TE
.sp
The Error API Versions are defined with \fBMONGOC_ERROR_API_VERSION_LEGACY\fP and \fBMONGOC_ERROR_API_VERSION_2\fP\&. Set the version with \fBmongoc_client_set_error_api\fP or \fBmongoc_client_pool_set_error_api\fP\&.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fI\%MongoDB Server Error Codes\fP
.fi
.sp
.UNINDENT
.UNINDENT
.SS Object Lifecycle
.sp
This page documents the order of creation and destruction for libmongoc\(aqs main struct types.
.SS Clients and pools
.sp
Call \fBmongoc_init()\fP once, before calling any other libmongoc functions, and call \fBmongoc_cleanup()\fP once before your program exits.
.sp
A program that uses libmongoc from multiple threads should create a \fBmongoc_client_pool_t\fP with \fBmongoc_client_pool_new()\fP\&. Each thread acquires a \fBmongoc_client_t\fP from the pool with \fBmongoc_client_pool_pop()\fP and returns it with \fBmongoc_client_pool_push()\fP when the thread is finished using it. To destroy the pool, first return all clients, then call \fBmongoc_client_pool_destroy()\fP\&.
.sp
If your program uses libmongoc from only one thread, create a \fBmongoc_client_t\fP directly with \fBmongoc_client_new()\fP or \fBmongoc_client_new_from_uri()\fP\&. Destroy it with \fBmongoc_client_destroy()\fP\&.
.SS Databases, collections, and related objects
.sp
You can create a \fBmongoc_database_t\fP or \fBmongoc_collection_t\fP from a \fBmongoc_client_t\fP, and create a \fBmongoc_cursor_t\fP or \fBmongoc_bulk_operation_t\fP from a \fBmongoc_collection_t\fP\&.
.sp
Each of these objects must be destroyed before the client they were created from, but their lifetimes are otherwise independent.
.SS GridFS objects
.sp
You can create a \fBmongoc_gridfs_t\fP from a \fBmongoc_client_t\fP, create a \fBmongoc_gridfs_file_t\fP or \fBmongoc_gridfs_file_list_t\fP from a \fBmongoc_gridfs_t\fP, create a \fBmongoc_gridfs_file_t\fP from a \fBmongoc_gridfs_file_list_t\fP, and create a \fBmongoc_stream_t\fP from a \fBmongoc_gridfs_file_t\fP\&.
.sp
Each of these objects depends on the object it was created from. Always destroy GridFS objects in the reverse of the order they were created. The sole exception is that a \fBmongoc_gridfs_file_t\fP need not be destroyed before the \fBmongoc_gridfs_file_list_t\fP it was created from.
.SS GridFS bucket objects
.sp
Create \fBmongoc_gridfs_bucket_t\fP with a \fBmongoc_database_t\fP derived from a \fBmongoc_client_t\fP\&. The \fBmongoc_database_t\fP is independent from the \fBmongoc_gridfs_bucket_t\fP\&. But the \fBmongoc_client_t\fP must outlive the \fBmongoc_gridfs_bucket_t\fP\&.
.sp
A \fBmongoc_stream_t\fP may be created from the \fBmongoc_gridfs_bucket_t\fP\&. The \fBmongoc_gridfs_bucket_t\fP must outlive the \fBmongoc_stream_t\fP\&.
.SS Sessions
.sp
Start a session with \fBmongoc_client_start_session\fP, use the session for a sequence of operations and multi\-document transactions, then free it with \fBmongoc_client_session_destroy()\fP\&. Any \fBmongoc_cursor_t\fP or \fBmongoc_change_stream_t\fP using a session must be destroyed before the session, and a session must be destroyed before the \fBmongoc_client_t\fP it came from.
.sp
By default, sessions are \fI\%causally consistent\fP\&. To disable causal consistency, before starting a session create a \fBmongoc_session_opt_t\fP with \fBmongoc_session_opts_new()\fP and call \fBmongoc_session_opts_set_causal_consistency()\fP, then free the struct with \fBmongoc_session_opts_destroy\fP\&.
.sp
Unacknowledged writes are prohibited with sessions.
.sp
A \fBmongoc_client_session_t\fP must be used by only one thread at a time. Due to session pooling, \fBmongoc_client_start_session\fP may return a session that has been idle for some time and is about to be closed after its idle timeout. Use the session within one minute of acquiring it to refresh the session and avoid a timeout.
.SS Client Side Encryption
.sp
When configuring a \fBmongoc_client_t\fP for automatic encryption via \fBmongoc_client_enable_auto_encryption()\fP, if a separate key vault client is set in the options (via \fBmongoc_auto_encryption_opts_set_keyvault_client()\fP) the key vault client must outlive the encrypted client.
.sp
When configuring a \fBmongoc_client_pool_t\fP for automatic encryption via \fBmongoc_client_pool_enable_auto_encryption()\fP, if a separate key vault client pool is set in the options (via \fBmongoc_auto_encryption_opts_set_keyvault_client_pool()\fP) the key vault client pool must outlive the encrypted client pool.
.sp
When creating a \fBmongoc_client_encryption_t\fP, the configured key vault client (set via \fBmongoc_client_encryption_opts_set_keyvault_client()\fP) must outlive the \fBmongoc_client_encryption_t\fP\&.
.SS GridFS
.sp
The C driver includes two APIs for GridFS.
.sp
The older API consists of \fBmongoc_gridfs_t\fP and its derivatives. It contains deprecated API, does not support read preferences, and is not recommended in new applications. It does not conform to the \fI\%MongoDB GridFS specification\fP\&.
.sp
The newer API consists of \fBmongoc_gridfs_bucket_t\fP and allows uploading/downloading through derived \fBmongoc_stream_t\fP objects. It conforms to the \fI\%MongoDB GridFS specification\fP\&.
.sp
There is not always a straightforward upgrade path from an application built with \fBmongoc_gridfs_t\fP to \fBmongoc_gridfs_bucket_t\fP (e.g. a \fBmongoc_gridfs_file_t\fP provides functions to seek but \fBmongoc_stream_t\fP does not). But users are encouraged to upgrade when possible.
.SS mongoc_auto_encryption_opts_t
.sp
Options for enabling automatic encryption and decryption for \fI\%Client\-Side Field Level Encryption\fP\&.
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_auto_encryption_opts_t mongoc_auto_encryption_opts_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
The guide for Using Client\-Side Field Level Encryption
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_bulk_operation_t
.sp
Bulk Write Operations
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_bulk_operation_t mongoc_bulk_operation_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The opaque type \fBmongoc_bulk_operation_t\fP provides an abstraction for submitting multiple write operations as a single batch.
.sp
After adding all of the write operations to the \fBmongoc_bulk_operation_t\fP, call \fBmongoc_bulk_operation_execute()\fP to execute the operation.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
It is only valid to call \fBmongoc_bulk_operation_execute()\fP once. The \fBmongoc_bulk_operation_t\fP must be destroyed afterwards.
.UNINDENT
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fBBulk Write Operations\fP
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_change_stream_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

typedef struct _mongoc_change_stream_t mongoc_change_stream_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_change_stream_t\fP is a handle to a change stream. A collection
change stream can be obtained using \fBmongoc_collection_watch\fP\&.
.sp
It is recommended to use a \fBmongoc_change_stream_t\fP and its functions instead of a raw aggregation with a \fB$changeStream\fP stage. For more information see the \fI\%MongoDB Manual Entry on Change Streams\fP\&.
.SS Example
.sp
example\-collection\-watch.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

int
main ()
{
   bson_t empty = BSON_INITIALIZER;
   const bson_t *doc;
   bson_t *to_insert = BCON_NEW ("x", BCON_INT32 (1));
   const bson_t *err_doc;
   bson_error_t error;
   const char *uri_string;
   mongoc_uri_t *uri;
   mongoc_client_t *client;
   mongoc_collection_t *coll;
   mongoc_change_stream_t *stream;
   mongoc_write_concern_t *wc = mongoc_write_concern_new ();
   bson_t opts = BSON_INITIALIZER;
   bool r;

   mongoc_init ();

   uri_string = "mongodb://"
                "localhost:27017,localhost:27018,localhost:"
                "27019/db?replicaSet=rs0";

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   coll = mongoc_client_get_collection (client, "db", "coll");
   stream = mongoc_collection_watch (coll, &empty, NULL);

   mongoc_write_concern_set_wmajority (wc, 10000);
   mongoc_write_concern_append (wc, &opts);
   r = mongoc_collection_insert_one (coll, to_insert, &opts, NULL, &error);
   if (!r) {
      fprintf (stderr, "Error: %s\en", error.message);
      return EXIT_FAILURE;
   }

   while (mongoc_change_stream_next (stream, &doc)) {
      char *as_json = bson_as_relaxed_extended_json (doc, NULL);
      fprintf (stderr, "Got document: %s\en", as_json);
      bson_free (as_json);
   }

   if (mongoc_change_stream_error_document (stream, &error, &err_doc)) {
      if (!bson_empty (err_doc)) {
         fprintf (stderr,
                  "Server Error: %s\en",
                  bson_as_relaxed_extended_json (err_doc, NULL));
      } else {
         fprintf (stderr, "Client Error: %s\en", error.message);
      }
      return EXIT_FAILURE;
   }

   bson_destroy (to_insert);
   mongoc_write_concern_destroy (wc);
   bson_destroy (&opts);
   mongoc_change_stream_destroy (stream);
   mongoc_collection_destroy (coll);
   mongoc_uri_destroy (uri);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Starting and Resuming
.sp
All \fBwatch\fP functions accept several options to indicate where a change stream should start returning changes from: \fBresumeAfter\fP, \fBstartAfter\fP, and \fBstartAtOperationTime\fP\&.
.sp
All changes returned by \fBmongoc_change_stream_next\fP include a resume token in the \fB_id\fP field. MongoDB 4.2 also includes an additional resume token in each "aggregate" and "getMore" command response, which points to the end of that response\(aqs batch. The current token is automatically cached by libmongoc. In the event of an error, libmongoc attempts to recreate the change stream starting where it left off by passing the cached resume token. libmongoc only attempts to resume once, but client applications can access the cached resume token with \fBmongoc_change_stream_get_resume_token\fP and use it for their own resume logic by passing it as either the \fBresumeAfter\fP or \fBstartAfter\fP option.
.sp
Additionally, change streams can start returning changes at an operation time by using the \fBstartAtOperationTime\fP field. This can be the timestamp returned in the \fBoperationTime\fP field of a command reply.
.sp
\fBresumeAfter\fP, \fBstartAfter\fP, and \fBstartAtOperationTime\fP are mutually exclusive options. Setting more than one will result in a server error.
.sp
The following example implements custom resuming logic, persisting the resume token in a file.
.sp
example\-resume.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

/* An example implementation of custom resume logic in a change stream.
* example\-resume starts a client\-wide change stream and persists the resume
* token in a file "resume\-token.json". On restart, if "resume\-token.json"
* exists, the change stream starts watching after the persisted resume token.
*
* This behavior allows a user to exit example\-resume, and restart it later
* without missing any change events.
*/
#include <unistd.h>

static const char *RESUME_TOKEN_PATH = "resume\-token.json";

static bool
_save_resume_token (const bson_t *doc)
{
   FILE *file_stream;
   bson_iter_t iter;
   bson_t resume_token_doc;
   char *as_json = NULL;
   size_t as_json_len;
   ssize_t r, n_written;
   const bson_value_t *resume_token;

   if (!bson_iter_init_find (&iter, doc, "_id")) {
      fprintf (stderr, "reply does not contain operationTime.");
      return false;
   }
   resume_token = bson_iter_value (&iter);
   /* store the resume token in a document, { resumeAfter: <resume token> }
    * which we can later append easily. */
   file_stream = fopen (RESUME_TOKEN_PATH, "w+");
   if (!file_stream) {
      fprintf (stderr, "failed to open %s for writing\en", RESUME_TOKEN_PATH);
      return false;
   }
   bson_init (&resume_token_doc);
   BSON_APPEND_VALUE (&resume_token_doc, "resumeAfter", resume_token);
   as_json = bson_as_canonical_extended_json (&resume_token_doc, &as_json_len);
   bson_destroy (&resume_token_doc);
   n_written = 0;
   while (n_written < as_json_len) {
      r = fwrite ((void *) (as_json + n_written),
                  sizeof (char),
                  as_json_len \- n_written,
                  file_stream);
      if (r == \-1) {
         fprintf (stderr, "failed to write to %s\en", RESUME_TOKEN_PATH);
         bson_free (as_json);
         fclose (file_stream);
         return false;
      }
      n_written += r;
   }

   bson_free (as_json);
   fclose (file_stream);
   return true;
}

bool
_load_resume_token (bson_t *opts)
{
   bson_error_t error;
   bson_json_reader_t *reader;
   bson_t doc;

   /* if the file does not exist, skip. */
   if (\-1 == access (RESUME_TOKEN_PATH, R_OK)) {
      return true;
   }
   reader = bson_json_reader_new_from_file (RESUME_TOKEN_PATH, &error);
   if (!reader) {
      fprintf (stderr,
               "failed to open %s for reading: %s\en",
               RESUME_TOKEN_PATH,
               error.message);
      return false;
   }

   bson_init (&doc);
   if (\-1 == bson_json_reader_read (reader, &doc, &error)) {
      fprintf (stderr, "failed to read doc from %s\en", RESUME_TOKEN_PATH);
      bson_destroy (&doc);
      bson_json_reader_destroy (reader);
      return false;
   }

   printf ("found cached resume token in %s, resuming change stream.\en",
           RESUME_TOKEN_PATH);

   bson_concat (opts, &doc);
   bson_destroy (&doc);
   bson_json_reader_destroy (reader);
   return true;
}

int
main ()
{
   int exit_code = EXIT_FAILURE;
   const char *uri_string;
   mongoc_uri_t *uri = NULL;
   bson_error_t error;
   mongoc_client_t *client = NULL;
   bson_t pipeline = BSON_INITIALIZER;
   bson_t opts = BSON_INITIALIZER;
   mongoc_change_stream_t *stream = NULL;
   const bson_t *doc;

   const int max_time = 30; /* max amount of time, in seconds, that
                               mongoc_change_stream_next can block. */

   mongoc_init ();
   uri_string = "mongodb://localhost:27017/db?replicaSet=rs0";
   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      goto cleanup;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      goto cleanup;
   }

   if (!_load_resume_token (&opts)) {
      goto cleanup;
   }
   BSON_APPEND_INT64 (&opts, "maxAwaitTimeMS", max_time * 1000);

   printf ("listening for changes on the client (max %d seconds).\en", max_time);
   stream = mongoc_client_watch (client, &pipeline, &opts);

   while (mongoc_change_stream_next (stream, &doc)) {
      char *as_json;

      as_json = bson_as_canonical_extended_json (doc, NULL);
      printf ("change received: %s\en", as_json);
      bson_free (as_json);
      if (!_save_resume_token (doc)) {
         goto cleanup;
      }
   }

   exit_code = EXIT_SUCCESS;

cleanup:
   mongoc_uri_destroy (uri);
   bson_destroy (&pipeline);
   bson_destroy (&opts);
   mongoc_change_stream_destroy (stream);
   mongoc_client_destroy (client);
   mongoc_cleanup ();
   return exit_code;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The following example shows using \fBstartAtOperationTime\fP to synchronize a change stream with another operation.
.sp
example\-start\-at\-optime.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* An example of starting a change stream with startAtOperationTime. */
#include <mongoc/mongoc.h>

int
main ()
{
   int exit_code = EXIT_FAILURE;
   const char *uri_string;
   mongoc_uri_t *uri = NULL;
   bson_error_t error;
   mongoc_client_t *client = NULL;
   mongoc_collection_t *coll = NULL;
   bson_t pipeline = BSON_INITIALIZER;
   bson_t opts = BSON_INITIALIZER;
   mongoc_change_stream_t *stream = NULL;
   bson_iter_t iter;
   const bson_t *doc;
   bson_value_t cached_operation_time = {0};
   int i;
   bool r;

   mongoc_init ();
   uri_string = "mongodb://localhost:27017/db?replicaSet=rs0";
   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      goto cleanup;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      goto cleanup;
   }

   /* insert five documents. */
   coll = mongoc_client_get_collection (client, "db", "coll");
   for (i = 0; i < 5; i++) {
      bson_t reply;
      bson_t *insert_cmd = BCON_NEW ("insert",
                                     "coll",
                                     "documents",
                                     "[",
                                     "{",
                                     "x",
                                     BCON_INT64 (i),
                                     "}",
                                     "]");

      r = mongoc_collection_write_command_with_opts (
         coll, insert_cmd, NULL, &reply, &error);
      bson_destroy (insert_cmd);
      if (!r) {
         bson_destroy (&reply);
         fprintf (stderr, "failed to insert: %s\en", error.message);
         goto cleanup;
      }
      if (i == 0) {
         /* cache the operation time in the first reply. */
         if (bson_iter_init_find (&iter, &reply, "operationTime")) {
            bson_value_copy (bson_iter_value (&iter), &cached_operation_time);
         } else {
            fprintf (stderr, "reply does not contain operationTime.");
            bson_destroy (&reply);
            goto cleanup;
         }
      }
      bson_destroy (&reply);
   }

   /* start a change stream at the first returned operationTime. */
   BSON_APPEND_VALUE (&opts, "startAtOperationTime", &cached_operation_time);
   stream = mongoc_collection_watch (coll, &pipeline, &opts);

   /* since the change stream started at the operation time of the first
    * insert, the five inserts are returned. */
   printf ("listening for changes on db.coll:\en");
   while (mongoc_change_stream_next (stream, &doc)) {
      char *as_json;

      as_json = bson_as_canonical_extended_json (doc, NULL);
      printf ("change received: %s\en", as_json);
      bson_free (as_json);
   }

   exit_code = EXIT_SUCCESS;

cleanup:
   mongoc_uri_destroy (uri);
   bson_destroy (&pipeline);
   bson_destroy (&opts);
   if (cached_operation_time.value_type) {
      bson_value_destroy (&cached_operation_time);
   }
   mongoc_change_stream_destroy (stream);
   mongoc_collection_destroy (coll);
   mongoc_client_destroy (client);
   mongoc_cleanup ();
   return exit_code;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_client_encryption_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_client_encryption_t mongoc_client_encryption_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_client_encryption_t\fP provides utility functions for Client\-Side Field Level Encryption. See the guide for Using Client\-Side Field Level Encryption\&.
.SS Thread Safety
.sp
\fBmongoc_client_encryption_t\fP is NOT thread\-safe and should only be used in the same thread as the \fBmongoc_client_t\fP that is configured via \fBmongoc_client_encryption_opts_set_keyvault_client()\fP\&.
.SS Lifecycle
.sp
The key vault client, configured via \fBmongoc_client_encryption_opts_set_keyvault_client()\fP, must outlive the \fBmongoc_client_encryption_t\fP\&.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fBmongoc_client_enable_auto_encryption()\fP
.fi
.sp
.nf
\fBmongoc_client_pool_enable_auto_encryption()\fP
.fi
.sp
.nf
The guide for Using Client\-Side Field Level Encryption for libmongoc
.fi
.sp
.nf
The MongoDB Manual for \fI\%Client\-Side Field Level Encryption\fP
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_client_encryption_datakey_opts_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_client_encryption_datakey_opts_t mongoc_client_encryption_datakey_opts_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Used to set options for \fBmongoc_client_encryption_create_datakey()\fP\&.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fBmongoc_client_encryption_create_datakey()\fP
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_client_encryption_encrypt_opts_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_client_encryption_encrypt_opts_t mongoc_client_encryption_encrypt_opts_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Used to set options for \fBmongoc_client_encryption_encrypt()\fP\&.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fBmongoc_client_encryption_encrypt()\fP
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_client_encryption_opts_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_client_encryption_opts_t mongoc_client_encryption_opts_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Used to set options for \fBmongoc_client_encryption_new()\fP\&.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fBmongoc_client_encryption_new()\fP
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_client_pool_t
.sp
A connection pool for multi\-threaded programs. See connection\-pooling\&.
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_client_pool_t mongoc_client_pool_t
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_client_pool_t\fP is the basis for multi\-threading in the MongoDB C driver. Since \fBmongoc_client_t\fP structures are not thread\-safe, this structure is used to retrieve a new \fBmongoc_client_t\fP for a given thread. This structure \fIis thread\-safe\fP, except for its destructor method, \fBmongoc_client_pool_destroy\fP, which \fIis not thread\-safe\fP and must only be called from one thread.
.SS Example
.sp
example\-pool.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* gcc example\-pool.c \-o example\-pool $(pkg\-config \-\-cflags \-\-libs
 * libmongoc\-1.0) */

/* ./example\-pool [CONNECTION_STRING] */

#include <mongoc/mongoc.h>
#include <pthread.h>
#include <stdio.h>

static pthread_mutex_t mutex;
static bool in_shutdown = false;

static void *
worker (void *data)
{
   mongoc_client_pool_t *pool = data;
   mongoc_client_t *client;
   bson_t ping = BSON_INITIALIZER;
   bson_error_t error;
   bool r;

   BSON_APPEND_INT32 (&ping, "ping", 1);

   while (true) {
      client = mongoc_client_pool_pop (pool);
      /* Do something with client. If you are writing an HTTP server, you
       * probably only want to hold onto the client for the portion of the
       * request performing database queries.
       */
      r = mongoc_client_command_simple (
         client, "admin", &ping, NULL, NULL, &error);

      if (!r) {
         fprintf (stderr, "%s\en", error.message);
      }

      mongoc_client_pool_push (pool, client);

      pthread_mutex_lock (&mutex);
      if (in_shutdown || !r) {
         pthread_mutex_unlock (&mutex);
         break;
      }

      pthread_mutex_unlock (&mutex);
   }

   bson_destroy (&ping);
   return NULL;
}

int
main (int argc, char *argv[])
{
   const char *uri_string = "mongodb://127.0.0.1/?appname=pool\-example";
   mongoc_uri_t *uri;
   bson_error_t error;
   mongoc_client_pool_t *pool;
   pthread_t threads[10];
   unsigned i;
   void *ret;

   pthread_mutex_init (&mutex, NULL);
   mongoc_init ();

   if (argc > 1) {
      uri_string = argv[1];
   }

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   pool = mongoc_client_pool_new (uri);
   mongoc_client_pool_set_error_api (pool, 2);

   for (i = 0; i < 10; i++) {
      pthread_create (&threads[i], NULL, worker, pool);
   }

   sleep (10);
   pthread_mutex_lock (&mutex);
   in_shutdown = true;
   pthread_mutex_unlock (&mutex);

   for (i = 0; i < 10; i++) {
      pthread_join (threads[i], &ret);
   }

   mongoc_client_pool_destroy (pool);
   mongoc_uri_destroy (uri);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_client_session_t
.sp
Use a session for a sequence of operations, optionally with causal consistency. See \fI\%the MongoDB Manual Entry for Causal Consistency\fP\&.
.SS Synopsis
.sp
Start a session with \fBmongoc_client_start_session\fP, use the session for a sequence of operations and multi\-document transactions, then free it with \fBmongoc_client_session_destroy()\fP\&. Any \fBmongoc_cursor_t\fP or \fBmongoc_change_stream_t\fP using a session must be destroyed before the session, and a session must be destroyed before the \fBmongoc_client_t\fP it came from.
.sp
By default, sessions are \fI\%causally consistent\fP\&. To disable causal consistency, before starting a session create a \fBmongoc_session_opt_t\fP with \fBmongoc_session_opts_new()\fP and call \fBmongoc_session_opts_set_causal_consistency()\fP, then free the struct with \fBmongoc_session_opts_destroy\fP\&.
.sp
Unacknowledged writes are prohibited with sessions.
.sp
A \fBmongoc_client_session_t\fP must be used by only one thread at a time. Due to session pooling, \fBmongoc_client_start_session\fP may return a session that has been idle for some time and is about to be closed after its idle timeout. Use the session within one minute of acquiring it to refresh the session and avoid a timeout.
.SS Example
.sp
example\-session.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* gcc example\-session.c \-o example\-session \e
 *     $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0) */

/* ./example\-session [CONNECTION_STRING] */

#include <stdio.h>
#include <mongoc/mongoc.h>


int
main (int argc, char *argv[])
{
   int exit_code = EXIT_FAILURE;

   mongoc_client_t *client = NULL;
   const char *uri_string = "mongodb://127.0.0.1/?appname=session\-example";
   mongoc_uri_t *uri = NULL;
   mongoc_client_session_t *client_session = NULL;
   mongoc_collection_t *collection = NULL;
   bson_error_t error;
   bson_t *selector = NULL;
   bson_t *update = NULL;
   bson_t *update_opts = NULL;
   bson_t *find_opts = NULL;
   mongoc_read_prefs_t *secondary = NULL;
   mongoc_cursor_t *cursor = NULL;
   const bson_t *doc;
   char *str;
   bool r;

   mongoc_init ();

   if (argc > 1) {
      uri_string = argv[1];
   }

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      goto done;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      goto done;
   }

   mongoc_client_set_error_api (client, 2);

   /* pass NULL for options \- by default the session is causally consistent */
   client_session = mongoc_client_start_session (client, NULL, &error);
   if (!client_session) {
      fprintf (stderr, "Failed to start session: %s\en", error.message);
      goto done;
   }

   collection = mongoc_client_get_collection (client, "test", "collection");
   selector = BCON_NEW ("_id", BCON_INT32 (1));
   update = BCON_NEW ("$inc", "{", "x", BCON_INT32 (1), "}");
   update_opts = bson_new ();
   if (!mongoc_client_session_append (client_session, update_opts, &error)) {
      fprintf (stderr, "Could not add session to opts: %s\en", error.message);
      goto done;
   }

   r = mongoc_collection_update_one (
      collection, selector, update, update_opts, NULL /* reply */, &error);

   if (!r) {
      fprintf (stderr, "Update failed: %s\en", error.message);
      goto done;
   }

   bson_destroy (selector);
   selector = BCON_NEW ("_id", BCON_INT32 (1));
   secondary = mongoc_read_prefs_new (MONGOC_READ_SECONDARY);

   find_opts = BCON_NEW ("maxTimeMS", BCON_INT32 (2000));
   if (!mongoc_client_session_append (client_session, find_opts, &error)) {
      fprintf (stderr, "Could not add session to opts: %s\en", error.message);
      goto done;
   };

   /* read from secondary. since we\(aqre in a causally consistent session, the
    * data is guaranteed to reflect the update we did on the primary. the query
    * blocks waiting for the secondary to catch up, if necessary, or times out
    * and fails after 2000 ms.
    */
   cursor = mongoc_collection_find_with_opts (
      collection, selector, find_opts, secondary);

   while (mongoc_cursor_next (cursor, &doc)) {
      str = bson_as_json (doc, NULL);
      fprintf (stdout, "%s\en", str);
      bson_free (str);
   }

   if (mongoc_cursor_error (cursor, &error)) {
      fprintf (stderr, "Cursor Failure: %s\en", error.message);
      goto done;
   }

   exit_code = EXIT_SUCCESS;

done:
   if (find_opts) {
      bson_destroy (find_opts);
   }
   if (update) {
      bson_destroy (update);
   }
   if (selector) {
      bson_destroy (selector);
   }
   if (update_opts) {
      bson_destroy (update_opts);
   }
   if (secondary) {
      mongoc_read_prefs_destroy (secondary);
   }
   /* destroy cursor, collection, session before the client they came from */
   if (cursor) {
      mongoc_cursor_destroy (cursor);
   }
   if (collection) {
      mongoc_collection_destroy (collection);
   }
   if (client_session) {
      mongoc_client_session_destroy (client_session);
   }
   if (uri) {
      mongoc_uri_destroy (uri);
   }
   if (client) {
      mongoc_client_destroy (client);
   }

   mongoc_cleanup ();

   return exit_code;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_client_session_with_transaction_cb_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef bool (*mongoc_client_session_with_transaction_cb_t) (
   mongoc_client_session_t *session,
   void *ctx,
   bson_t **reply,
   bson_error_t *error);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Provide this callback to \fBmongoc_client_session_with_transaction\fP\&. The callback should run a sequence of operations meant to be contained within a transaction.  The callback should not attempt to start or commit transactions.
.SS Parameters
.INDENT 0.0
.IP \(bu 2
\fBsession\fP: A \fBmongoc_client_session_t\fP\&.
.IP \(bu 2
\fBctx\fP: A \fBvoid*\fP set to the the user\-provided \fBctx\fP passed to \fBmongoc_client_session_with_transaction\fP\&.
.IP \(bu 2
\fBreply\fP: An optional location for a \fI\%bson_t\fP or \fBNULL\fP\&. The callback should set this if it runs any operations against the server and receives replies.
.IP \(bu 2
\fBerror\fP: A \fI\%bson_error_t\fP\&. The callback should set this if it receives any errors while running operations against the server.
.UNINDENT
.SS Return
.sp
Returns \fBtrue\fP for success and \fBfalse\fP on failure. If \fBcb\fP returns \fBfalse\fP then it should also set \fBerror\fP\&.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fBmongoc_client_session_with_transaction\fP
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_client_t
.sp
A single\-threaded MongoDB connection. See connection\-pooling\&.
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_client_t mongoc_client_t;

typedef mongoc_stream_t *(*mongoc_stream_initiator_t) (
   const mongoc_uri_t *uri,
   const mongoc_host_list_t *host,
   void *user_data,
   bson_error_t *error);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_client_t\fP is an opaque type that provides access to a MongoDB server,
replica set, or sharded cluster. It maintains management of underlying sockets
and routing to individual nodes based on \fBmongoc_read_prefs_t\fP or \fBmongoc_write_concern_t\fP\&.
.SS Streams
.sp
The underlying transport for a given client can be customized, wrapped or replaced by any implementation that fulfills \fBmongoc_stream_t\fP\&. A custom transport can be set with \fBmongoc_client_set_stream_initiator()\fP\&.
.SS Thread Safety
.sp
\fBmongoc_client_t\fP is \fINOT\fP thread\-safe and should only be used from one thread at a time. When used in multi\-threaded scenarios, it is recommended that you use the thread\-safe \fBmongoc_client_pool_t\fP to retrieve a \fBmongoc_client_t\fP for your thread.
.SS Example
.sp
example\-client.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* gcc example\-client.c \-o example\-client $(pkg\-config \-\-cflags \-\-libs
 * libmongoc\-1.0) */

/* ./example\-client [CONNECTION_STRING [COLLECTION_NAME]] */

#include <mongoc/mongoc.h>
#include <stdio.h>
#include <stdlib.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   mongoc_cursor_t *cursor;
   bson_error_t error;
   const bson_t *doc;
   const char *collection_name = "test";
   bson_t query;
   char *str;
   const char *uri_string = "mongodb://127.0.0.1/?appname=client\-example";
   mongoc_uri_t *uri;

   mongoc_init ();
   if (argc > 1) {
      uri_string = argv[1];
   }

   if (argc > 2) {
      collection_name = argv[2];
   }

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);

   bson_init (&query);
   collection = mongoc_client_get_collection (client, "test", collection_name);
   cursor = mongoc_collection_find_with_opts (
      collection,
      &query,
      NULL,  /* additional options */
      NULL); /* read prefs, NULL for default */

   while (mongoc_cursor_next (cursor, &doc)) {
      str = bson_as_canonical_extended_json (doc, NULL);
      fprintf (stdout, "%s\en", str);
      bson_free (str);
   }

   if (mongoc_cursor_error (cursor, &error)) {
      fprintf (stderr, "Cursor Failure: %s\en", error.message);
      return EXIT_FAILURE;
   }

   bson_destroy (&query);
   mongoc_cursor_destroy (cursor);
   mongoc_collection_destroy (collection);
   mongoc_uri_destroy (uri);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_collection_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_collection_t mongoc_collection_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_collection_t\fP provides access to a MongoDB collection.  This handle is useful for actions for most CRUD operations, I.e. insert, update, delete, find, etc.
.SS Read Preferences and Write Concerns
.sp
Read preferences and write concerns are inherited from the parent client. They can be overridden by set_* commands if so desired.
.SS mongoc_cursor_t
.sp
Client\-side cursor abstraction
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_cursor_t mongoc_cursor_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_cursor_t\fP provides access to a MongoDB query cursor.
It wraps up the wire protocol negotiation required to initiate a query and retrieve an unknown number of documents.
.sp
Common cursor operations include:
.INDENT 0.0
.IP \(bu 2
Determine which host we\(aqve connected to with \fBmongoc_cursor_get_host()\fP\&.
.IP \(bu 2
Retrieve more records with repeated calls to \fBmongoc_cursor_next()\fP\&.
.IP \(bu 2
Clone a query to repeat execution at a later point with \fBmongoc_cursor_clone()\fP\&.
.IP \(bu 2
Test for errors with \fBmongoc_cursor_error()\fP\&.
.UNINDENT
.sp
Cursors are lazy, meaning that no connection is established and no network traffic occurs until the first call to \fBmongoc_cursor_next()\fP\&.
.SS Thread Safety
.sp
\fBmongoc_cursor_t\fP is \fINOT\fP thread safe. It may only be used from within the thread in which it was created.
.SS Example
.sp
Query MongoDB and iterate results
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* gcc example\-client.c \-o example\-client $(pkg\-config \-\-cflags \-\-libs
 * libmongoc\-1.0) */

/* ./example\-client [CONNECTION_STRING [COLLECTION_NAME]] */

#include <mongoc/mongoc.h>
#include <stdio.h>
#include <stdlib.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   mongoc_cursor_t *cursor;
   bson_error_t error;
   const bson_t *doc;
   const char *collection_name = "test";
   bson_t query;
   char *str;
   const char *uri_string = "mongodb://127.0.0.1/?appname=client\-example";
   mongoc_uri_t *uri;

   mongoc_init ();
   if (argc > 1) {
      uri_string = argv[1];
   }

   if (argc > 2) {
      collection_name = argv[2];
   }

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);

   bson_init (&query);
   collection = mongoc_client_get_collection (client, "test", collection_name);
   cursor = mongoc_collection_find_with_opts (
      collection,
      &query,
      NULL,  /* additional options */
      NULL); /* read prefs, NULL for default */

   while (mongoc_cursor_next (cursor, &doc)) {
      str = bson_as_canonical_extended_json (doc, NULL);
      fprintf (stdout, "%s\en", str);
      bson_free (str);
   }

   if (mongoc_cursor_error (cursor, &error)) {
      fprintf (stderr, "Cursor Failure: %s\en", error.message);
      return EXIT_FAILURE;
   }

   bson_destroy (&query);
   mongoc_cursor_destroy (cursor);
   mongoc_collection_destroy (collection);
   mongoc_uri_destroy (uri);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_database_t
.sp
MongoDB Database Abstraction
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_database_t mongoc_database_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_database_t\fP provides access to a MongoDB database. This handle is useful for actions a particular database object. It \fIis not\fP a container for \fBmongoc_collection_t\fP structures.
.sp
Read preferences and write concerns are inherited from the parent client. They can be overridden with \fBmongoc_database_set_read_prefs()\fP and \fBmongoc_database_set_write_concern()\fP\&.
.SS Examples
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

int
main (int argc, char *argv[])
{
   mongoc_database_t *database;
   mongoc_client_t *client;

   mongoc_init ();

   client = mongoc_client_new ("mongodb://localhost/");
   database = mongoc_client_get_database (client, "test");

   mongoc_database_destroy (database);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_delete_flags_t
.sp
Flags for deletion operations
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef enum {
   MONGOC_DELETE_NONE = 0,
   MONGOC_DELETE_SINGLE_REMOVE = 1 << 0,
} mongoc_delete_flags_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Deprecated
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
These flags are deprecated and should not be used in new code.
.UNINDENT
.UNINDENT
.sp
Please use \fBmongoc_collection_delete_one()\fP or \fBmongoc_collection_delete_many()\fP instead.
.SS mongoc_find_and_modify_opts_t
.sp
find_and_modify abstraction
.SS Synopsis
.sp
\fBmongoc_find_and_modify_opts_t\fP is a builder interface to construct a \fI\%find_and_modify\fP command.
.sp
It was created to be able to accommodate new arguments to the MongoDB find_and_modify command.
.sp
As of MongoDB 3.2, the \fBmongoc_write_concern_t\fP specified on the \fBmongoc_collection_t\fP will be used, if any.
.SS Example
.sp
flags.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void
fam_flags (mongoc_collection_t *collection)
{
   mongoc_find_and_modify_opts_t *opts;
   bson_t reply;
   bson_error_t error;
   bson_t query = BSON_INITIALIZER;
   bson_t *update;
   bool success;


   /* Find Zlatan Ibrahimovic, the striker */
   BSON_APPEND_UTF8 (&query, "firstname", "Zlatan");
   BSON_APPEND_UTF8 (&query, "lastname", "Ibrahimovic");
   BSON_APPEND_UTF8 (&query, "profession", "Football player");
   BSON_APPEND_INT32 (&query, "age", 34);
   BSON_APPEND_INT32 (
      &query, "goals", (16 + 35 + 23 + 57 + 16 + 14 + 28 + 84) + (1 + 6 + 62));

   /* Add his football position */
   update = BCON_NEW ("$set", "{", "position", BCON_UTF8 ("striker"), "}");

   opts = mongoc_find_and_modify_opts_new ();

   mongoc_find_and_modify_opts_set_update (opts, update);

   /* Create the document if it didn\(aqt exist, and return the updated document */
   mongoc_find_and_modify_opts_set_flags (
      opts, MONGOC_FIND_AND_MODIFY_UPSERT | MONGOC_FIND_AND_MODIFY_RETURN_NEW);

   success = mongoc_collection_find_and_modify_with_opts (
      collection, &query, opts, &reply, &error);

   if (success) {
      char *str;

      str = bson_as_canonical_extended_json (&reply, NULL);
      printf ("%s\en", str);
      bson_free (str);
   } else {
      fprintf (
         stderr, "Got error: \e"%s\e" on line %d\en", error.message, __LINE__);
   }

   bson_destroy (&reply);
   bson_destroy (update);
   bson_destroy (&query);
   mongoc_find_and_modify_opts_destroy (opts);
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
bypass.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void
fam_bypass (mongoc_collection_t *collection)
{
   mongoc_find_and_modify_opts_t *opts;
   bson_t reply;
   bson_t *update;
   bson_error_t error;
   bson_t query = BSON_INITIALIZER;
   bool success;


   /* Find Zlatan Ibrahimovic, the striker */
   BSON_APPEND_UTF8 (&query, "firstname", "Zlatan");
   BSON_APPEND_UTF8 (&query, "lastname", "Ibrahimovic");
   BSON_APPEND_UTF8 (&query, "profession", "Football player");

   /* Bump his age */
   update = BCON_NEW ("$inc", "{", "age", BCON_INT32 (1), "}");

   opts = mongoc_find_and_modify_opts_new ();
   mongoc_find_and_modify_opts_set_update (opts, update);
   /* He can still play, even though he is pretty old. */
   mongoc_find_and_modify_opts_set_bypass_document_validation (opts, true);

   success = mongoc_collection_find_and_modify_with_opts (
      collection, &query, opts, &reply, &error);

   if (success) {
      char *str;

      str = bson_as_canonical_extended_json (&reply, NULL);
      printf ("%s\en", str);
      bson_free (str);
   } else {
      fprintf (
         stderr, "Got error: \e"%s\e" on line %d\en", error.message, __LINE__);
   }

   bson_destroy (&reply);
   bson_destroy (update);
   bson_destroy (&query);
   mongoc_find_and_modify_opts_destroy (opts);
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
update.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void
fam_update (mongoc_collection_t *collection)
{
   mongoc_find_and_modify_opts_t *opts;
   bson_t *update;
   bson_t reply;
   bson_error_t error;
   bson_t query = BSON_INITIALIZER;
   bool success;


   /* Find Zlatan Ibrahimovic */
   BSON_APPEND_UTF8 (&query, "firstname", "Zlatan");
   BSON_APPEND_UTF8 (&query, "lastname", "Ibrahimovic");

   /* Make him a book author */
   update = BCON_NEW ("$set", "{", "author", BCON_BOOL (true), "}");

   opts = mongoc_find_and_modify_opts_new ();
   /* Note that the document returned is the _previous_ version of the document
    * To fetch the modified new version, use
    * mongoc_find_and_modify_opts_set_flags (opts,
    * MONGOC_FIND_AND_MODIFY_RETURN_NEW);
    */
   mongoc_find_and_modify_opts_set_update (opts, update);

   success = mongoc_collection_find_and_modify_with_opts (
      collection, &query, opts, &reply, &error);

   if (success) {
      char *str;

      str = bson_as_canonical_extended_json (&reply, NULL);
      printf ("%s\en", str);
      bson_free (str);
   } else {
      fprintf (
         stderr, "Got error: \e"%s\e" on line %d\en", error.message, __LINE__);
   }

   bson_destroy (&reply);
   bson_destroy (update);
   bson_destroy (&query);
   mongoc_find_and_modify_opts_destroy (opts);
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
fields.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void
fam_fields (mongoc_collection_t *collection)
{
   mongoc_find_and_modify_opts_t *opts;
   bson_t fields = BSON_INITIALIZER;
   bson_t *update;
   bson_t reply;
   bson_error_t error;
   bson_t query = BSON_INITIALIZER;
   bool success;


   /* Find Zlatan Ibrahimovic */
   BSON_APPEND_UTF8 (&query, "lastname", "Ibrahimovic");
   BSON_APPEND_UTF8 (&query, "firstname", "Zlatan");

   /* Return his goal tally */
   BSON_APPEND_INT32 (&fields, "goals", 1);

   /* Bump his goal tally */
   update = BCON_NEW ("$inc", "{", "goals", BCON_INT32 (1), "}");

   opts = mongoc_find_and_modify_opts_new ();
   mongoc_find_and_modify_opts_set_update (opts, update);
   mongoc_find_and_modify_opts_set_fields (opts, &fields);
   /* Return the new tally */
   mongoc_find_and_modify_opts_set_flags (opts,
                                          MONGOC_FIND_AND_MODIFY_RETURN_NEW);

   success = mongoc_collection_find_and_modify_with_opts (
      collection, &query, opts, &reply, &error);

   if (success) {
      char *str;

      str = bson_as_canonical_extended_json (&reply, NULL);
      printf ("%s\en", str);
      bson_free (str);
   } else {
      fprintf (
         stderr, "Got error: \e"%s\e" on line %d\en", error.message, __LINE__);
   }

   bson_destroy (&reply);
   bson_destroy (update);
   bson_destroy (&fields);
   bson_destroy (&query);
   mongoc_find_and_modify_opts_destroy (opts);
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
sort.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void
fam_sort (mongoc_collection_t *collection)
{
   mongoc_find_and_modify_opts_t *opts;
   bson_t *update;
   bson_t sort = BSON_INITIALIZER;
   bson_t reply;
   bson_error_t error;
   bson_t query = BSON_INITIALIZER;
   bool success;


   /* Find all users with the lastname Ibrahimovic */
   BSON_APPEND_UTF8 (&query, "lastname", "Ibrahimovic");

   /* Sort by age (descending) */
   BSON_APPEND_INT32 (&sort, "age", \-1);

   /* Bump his goal tally */
   update = BCON_NEW ("$set", "{", "oldest", BCON_BOOL (true), "}");

   opts = mongoc_find_and_modify_opts_new ();
   mongoc_find_and_modify_opts_set_update (opts, update);
   mongoc_find_and_modify_opts_set_sort (opts, &sort);

   success = mongoc_collection_find_and_modify_with_opts (
      collection, &query, opts, &reply, &error);

   if (success) {
      char *str;

      str = bson_as_canonical_extended_json (&reply, NULL);
      printf ("%s\en", str);
      bson_free (str);
   } else {
      fprintf (
         stderr, "Got error: \e"%s\e" on line %d\en", error.message, __LINE__);
   }

   bson_destroy (&reply);
   bson_destroy (update);
   bson_destroy (&sort);
   bson_destroy (&query);
   mongoc_find_and_modify_opts_destroy (opts);
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
opts.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void
fam_opts (mongoc_collection_t *collection)
{
   mongoc_find_and_modify_opts_t *opts;
   bson_t reply;
   bson_t *update;
   bson_error_t error;
   bson_t query = BSON_INITIALIZER;
   mongoc_write_concern_t *wc;
   bson_t extra = BSON_INITIALIZER;
   bool success;


   /* Find Zlatan Ibrahimovic, the striker */
   BSON_APPEND_UTF8 (&query, "firstname", "Zlatan");
   BSON_APPEND_UTF8 (&query, "lastname", "Ibrahimovic");
   BSON_APPEND_UTF8 (&query, "profession", "Football player");

   /* Bump his age */
   update = BCON_NEW ("$inc", "{", "age", BCON_INT32 (1), "}");

   opts = mongoc_find_and_modify_opts_new ();
   mongoc_find_and_modify_opts_set_update (opts, update);

   /* Abort if the operation takes too long. */
   mongoc_find_and_modify_opts_set_max_time_ms (opts, 100);

   /* Set write concern w: 2 */
   wc = mongoc_write_concern_new ();
   mongoc_write_concern_set_w (wc, 2);
   mongoc_write_concern_append (wc, &extra);

   /* Some future findAndModify option the driver doesn\(aqt support conveniently
    */
   BSON_APPEND_INT32 (&extra, "futureOption", 42);
   mongoc_find_and_modify_opts_append (opts, &extra);

   success = mongoc_collection_find_and_modify_with_opts (
      collection, &query, opts, &reply, &error);

   if (success) {
      char *str;

      str = bson_as_canonical_extended_json (&reply, NULL);
      printf ("%s\en", str);
      bson_free (str);
   } else {
      fprintf (
         stderr, "Got error: \e"%s\e" on line %d\en", error.message, __LINE__);
   }

   bson_destroy (&reply);
   bson_destroy (&extra);
   bson_destroy (update);
   bson_destroy (&query);
   mongoc_write_concern_destroy (wc);
   mongoc_find_and_modify_opts_destroy (opts);
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
fam.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int
main (void)
{
   mongoc_collection_t *collection;
   mongoc_database_t *database;
   mongoc_client_t *client;
   const char *uri_string =
      "mongodb://localhost:27017/admin?appname=find\-and\-modify\-opts\-example";
   mongoc_uri_t *uri;
   bson_error_t error;
   bson_t *options;

   mongoc_init ();

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   database = mongoc_client_get_database (client, "databaseName");

   options = BCON_NEW ("validator",
                       "{",
                       "age",
                       "{",
                       "$lte",
                       BCON_INT32 (34),
                       "}",
                       "}",
                       "validationAction",
                       BCON_UTF8 ("error"),
                       "validationLevel",
                       BCON_UTF8 ("moderate"));

   collection = mongoc_database_create_collection (
      database, "collectionName", options, &error);
   if (!collection) {
      fprintf (
         stderr, "Got error: \e"%s\e" on line %d\en", error.message, __LINE__);
      return EXIT_FAILURE;
   }

   fam_flags (collection);
   fam_bypass (collection);
   fam_update (collection);
   fam_fields (collection);
   fam_opts (collection);
   fam_sort (collection);

   mongoc_collection_drop (collection, NULL);
   bson_destroy (options);
   mongoc_uri_destroy (uri);
   mongoc_database_destroy (database);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);

   mongoc_cleanup ();
   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Outputs:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "lastErrorObject": {
        "updatedExisting": false,
        "n": 1,
        "upserted": {
            "$oid": "56562a99d13e6d86239c7b00"
        }
    },
    "value": {
        "_id": {
            "$oid": "56562a99d13e6d86239c7b00"
        },
        "age": 34,
        "firstname": "Zlatan",
        "goals": 342,
        "lastname": "Ibrahimovic",
        "profession": "Football player",
        "position": "striker"
    },
    "ok": 1
}
{
    "lastErrorObject": {
        "updatedExisting": true,
        "n": 1
    },
    "value": {
        "_id": {
            "$oid": "56562a99d13e6d86239c7b00"
        },
        "age": 34,
        "firstname": "Zlatan",
        "goals": 342,
        "lastname": "Ibrahimovic",
        "profession": "Football player",
        "position": "striker"
    },
    "ok": 1
}
{
    "lastErrorObject": {
        "updatedExisting": true,
        "n": 1
    },
    "value": {
        "_id": {
            "$oid": "56562a99d13e6d86239c7b00"
        },
        "age": 35,
        "firstname": "Zlatan",
        "goals": 342,
        "lastname": "Ibrahimovic",
        "profession": "Football player",
        "position": "striker"
    },
    "ok": 1
}
{
    "lastErrorObject": {
        "updatedExisting": true,
        "n": 1
    },
    "value": {
        "_id": {
            "$oid": "56562a99d13e6d86239c7b00"
        },
        "goals": 343
    },
    "ok": 1
}
{
    "lastErrorObject": {
        "updatedExisting": true,
        "n": 1
    },
    "value": {
        "_id": {
            "$oid": "56562a99d13e6d86239c7b00"
        },
        "age": 35,
        "firstname": "Zlatan",
        "goals": 343,
        "lastname": "Ibrahimovic",
        "profession": "Football player",
        "position": "striker",
        "author": true
    },
    "ok": 1
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_gridfs_file_list_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

typedef struct _mongoc_gridfs_file_list_t mongoc_gridfs_file_list_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
\fBmongoc_gridfs_file_list_t\fP provides a gridfs file list abstraction.  It provides iteration and basic marshalling on top of a regular \fBmongoc_collection_find_with_opts()\fP style query. In interface, it\(aqs styled after \fBmongoc_cursor_t\fP\&.
.SS Example
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongoc_gridfs_file_list_t *list;
mongoc_gridfs_file_t *file;

list = mongoc_gridfs_find (gridfs, query);

while ((file = mongoc_gridfs_file_list_next (list))) {
   do_something (file);

   mongoc_gridfs_file_destroy (file);
}

mongoc_gridfs_file_list_destroy (list);
.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_gridfs_file_opt_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct {
   const char *md5;
   const char *filename;
   const char *content_type;
   const bson_t *aliases;
   const bson_t *metadata;
   uint32_t chunk_size;
} mongoc_gridfs_file_opt_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
This structure contains options that can be set on a \fBmongoc_gridfs_file_t\fP\&. It can be used by various functions when creating a new gridfs file.
.SS mongoc_gridfs_file_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_gridfs_file_t mongoc_gridfs_file_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
This structure provides a MongoDB GridFS file abstraction. It provides several APIs.
.INDENT 0.0
.IP \(bu 2
readv, writev, seek, and tell.
.IP \(bu 2
General file metadata such as filename and length.
.IP \(bu 2
GridFS metadata such as md5, filename, content_type, aliases, metadata, chunk_size, and upload_date.
.UNINDENT
.SS Thread Safety
.sp
This structure is NOT thread\-safe and should only be used from one thread at a time.
.SS Related
.INDENT 0.0
.IP \(bu 2
\fBmongoc_client_t\fP
.IP \(bu 2
\fBmongoc_gridfs_t\fP
.IP \(bu 2
\fBmongoc_gridfs_file_list_t\fP
.IP \(bu 2
\fBmongoc_gridfs_file_opt_t\fP
.UNINDENT
.SS mongoc_gridfs_bucket_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

typedef struct _mongoc_gridfs_bucket_t mongoc_gridfs_bucket_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
\fBmongoc_gridfs_bucket_t\fP provides a spec\-compliant MongoDB GridFS implementation, superseding \fBmongoc_gridfs_t\fP\&. See the \fI\%GridFS MongoDB documentation\fP\&.
.SS Thread Safety
.sp
\fBmongoc_gridfs_bucket_t\fP is NOT thread\-safe and should only be used in the same thread as the owning \fBmongoc_client_t\fP\&.
.SS Lifecycle
.sp
It is an error to free a \fBmongoc_gridfs_bucket_t\fP before freeing all derived instances of \fBmongoc_stream_t\fP\&. The owning \fBmongoc_client_t\fP must outlive the \fBmongoc_gridfs_bucket_t\fP\&.
.SS Example
.sp
example\-gridfs\-bucket.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <stdio.h>
#include <stdlib.h>

#include <mongoc/mongoc.h>

int
main (int argc, char *argv[])
{
   const char *uri_string =
      "mongodb://localhost:27017/?appname=new\-gridfs\-example";
   mongoc_client_t *client;
   mongoc_database_t *db;
   mongoc_stream_t *file_stream;
   mongoc_gridfs_bucket_t *bucket;
   mongoc_cursor_t *cursor;
   bson_t filter;
   bool res;
   bson_value_t file_id;
   bson_error_t error;
   const bson_t *doc;
   char *str;
   mongoc_init ();

   if (argc != 3) {
      fprintf (stderr, "usage: %s SOURCE_FILE_PATH FILE_COPY_PATH\en", argv[0]);
      return EXIT_FAILURE;
   }

   /* 1. Make a bucket. */
   client = mongoc_client_new (uri_string);
   db = mongoc_client_get_database (client, "test");
   bucket = mongoc_gridfs_bucket_new (db, NULL, NULL, &error);
   if (!bucket) {
      printf ("Error creating gridfs bucket: %s\en", error.message);
      return EXIT_FAILURE;
   }

   /* 2. Insert a file.  */
   file_stream = mongoc_stream_file_new_for_path (argv[1], O_RDONLY, 0);
   res = mongoc_gridfs_bucket_upload_from_stream (
      bucket, "my\-file", file_stream, NULL, &file_id, &error);
   if (!res) {
      printf ("Error uploading file: %s\en", error.message);
      return EXIT_FAILURE;
   }

   mongoc_stream_close (file_stream);
   mongoc_stream_destroy (file_stream);

   /* 3. Download the file in GridFS to a local file. */
   file_stream = mongoc_stream_file_new_for_path (argv[2], O_CREAT | O_RDWR, 0);
   if (!file_stream) {
      perror ("Error opening file stream");
      return EXIT_FAILURE;
   }

   res = mongoc_gridfs_bucket_download_to_stream (
      bucket, &file_id, file_stream, &error);
   if (!res) {
      printf ("Error downloading file to stream: %s\en", error.message);
      return EXIT_FAILURE;
   }
   mongoc_stream_close (file_stream);
   mongoc_stream_destroy (file_stream);

   /* 4. List what files are available in GridFS. */
   bson_init (&filter);
   cursor = mongoc_gridfs_bucket_find (bucket, &filter, NULL);

   while (mongoc_cursor_next (cursor, &doc)) {
      str = bson_as_canonical_extended_json (doc, NULL);
      printf ("%s\en", str);
      bson_free (str);
   }

   /* 5. Delete the file that we added. */
   res = mongoc_gridfs_bucket_delete_by_id (bucket, &file_id, &error);
   if (!res) {
      printf ("Error deleting the file: %s\en", error.message);
      return EXIT_FAILURE;
   }

   /* 6. Cleanup. */
   mongoc_stream_close (file_stream);
   mongoc_stream_destroy (file_stream);
   mongoc_cursor_destroy (cursor);
   bson_destroy (&filter);
   mongoc_gridfs_bucket_destroy (bucket);
   mongoc_database_destroy (db);
   mongoc_client_destroy (client);
   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
The \fI\%MongoDB GridFS specification\fP\&.
.fi
.sp
.nf
The non spec\-compliant \fBmongoc_gridfs_t\fP\&.
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_gridfs_t
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
This GridFS implementation does not conform to the \fI\%MongoDB GridFS specification\fP\&. For a spec compliant implementation, use \fBmongoc_gridfs_bucket_t\fP\&.
.UNINDENT
.UNINDENT
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

typedef struct _mongoc_gridfs_t mongoc_gridfs_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
\fBmongoc_gridfs_t\fP provides a MongoDB gridfs implementation. The system as a whole is made up of \fBgridfs\fP objects, which contain \fBgridfs_files\fP and \fBgridfs_file_lists\fP\&.  Essentially, a basic file system API.
.sp
There are extensive caveats about the kind of use cases gridfs is practical for. In particular, any writing after initial file creation is likely to both break any concurrent readers and be quite expensive. That said, this implementation does allow for arbitrary writes to existing gridfs object, just use them with caution.
.sp
mongoc_gridfs also integrates tightly with the \fBmongoc_stream_t\fP abstraction, which provides some convenient wrapping for file creation and reading/writing.  It can be used without, but its worth looking to see if your problem can fit that model.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
\fBmongoc_gridfs_t\fP does not support read preferences. In a replica set, GridFS queries are always routed to the primary.
.UNINDENT
.UNINDENT
.SS Thread Safety
.sp
\fBmongoc_gridfs_t\fP is NOT thread\-safe and should only be used in the same thread as the owning \fBmongoc_client_t\fP\&.
.SS Lifecycle
.sp
It is an error to free a \fBmongoc_gridfs_t\fP before freeing all related instances of \fBmongoc_gridfs_file_t\fP and \fBmongoc_gridfs_file_list_t\fP\&.
.SS Example
.sp
example\-gridfs.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <assert.h>
#include <mongoc/mongoc.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

int
main (int argc, char *argv[])
{
   mongoc_gridfs_t *gridfs;
   mongoc_gridfs_file_t *file;
   mongoc_gridfs_file_list_t *list;
   mongoc_gridfs_file_opt_t opt = {0};
   mongoc_client_t *client;
   const char *uri_string = "mongodb://127.0.0.1:27017/?appname=gridfs\-example";
   mongoc_uri_t *uri;
   mongoc_stream_t *stream;
   bson_t filter;
   bson_t opts;
   bson_t child;
   bson_error_t error;
   ssize_t r;
   char buf[4096];
   mongoc_iovec_t iov;
   const char *filename;
   const char *command;
   bson_value_t id;

   if (argc < 2) {
      fprintf (stderr, "usage \- %s command ...\en", argv[0]);
      return EXIT_FAILURE;
   }

   mongoc_init ();

   iov.iov_base = (void *) buf;
   iov.iov_len = sizeof buf;

   /* connect to localhost client */
   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   assert (client);
   mongoc_client_set_error_api (client, 2);

   /* grab a gridfs handle in test prefixed by fs */
   gridfs = mongoc_client_get_gridfs (client, "test", "fs", &error);
   assert (gridfs);

   command = argv[1];
   filename = argv[2];

   if (strcmp (command, "read") == 0) {
      if (argc != 3) {
         fprintf (stderr, "usage \- %s read filename\en", argv[0]);
         return EXIT_FAILURE;
      }
      file = mongoc_gridfs_find_one_by_filename (gridfs, filename, &error);
      assert (file);

      stream = mongoc_stream_gridfs_new (file);
      assert (stream);

      for (;;) {
         r = mongoc_stream_readv (stream, &iov, 1, \-1, 0);

         assert (r >= 0);

         if (r == 0) {
            break;
         }

         if (fwrite (iov.iov_base, 1, r, stdout) != r) {
            MONGOC_ERROR ("Failed to write to stdout. Exiting.\en");
            exit (1);
         }
      }

      mongoc_stream_destroy (stream);
      mongoc_gridfs_file_destroy (file);
   } else if (strcmp (command, "list") == 0) {
      bson_init (&filter);

      bson_init (&opts);
      bson_append_document_begin (&opts, "sort", \-1, &child);
      BSON_APPEND_INT32 (&child, "filename", 1);
      bson_append_document_end (&opts, &child);

      list = mongoc_gridfs_find_with_opts (gridfs, &filter, &opts);

      bson_destroy (&filter);
      bson_destroy (&opts);

      while ((file = mongoc_gridfs_file_list_next (list))) {
         const char *name = mongoc_gridfs_file_get_filename (file);
         printf ("%s\en", name ? name : "?");

         mongoc_gridfs_file_destroy (file);
      }

      mongoc_gridfs_file_list_destroy (list);
   } else if (strcmp (command, "write") == 0) {
      if (argc != 4) {
         fprintf (stderr, "usage \- %s write filename input_file\en", argv[0]);
         return EXIT_FAILURE;
      }

      stream = mongoc_stream_file_new_for_path (argv[3], O_RDONLY, 0);
      assert (stream);

      opt.filename = filename;

      /* the driver generates a file_id for you */
      file = mongoc_gridfs_create_file_from_stream (gridfs, stream, &opt);
      assert (file);

      id.value_type = BSON_TYPE_INT32;
      id.value.v_int32 = 1;

      /* optional: the following method specifies a file_id of any
         BSON type */
      if (!mongoc_gridfs_file_set_id (file, &id, &error)) {
         fprintf (stderr, "%s\en", error.message);
         return EXIT_FAILURE;
      }

      if (!mongoc_gridfs_file_save (file)) {
         mongoc_gridfs_file_error (file, &error);
         fprintf (stderr, "Could not save: %s\en", error.message);
         return EXIT_FAILURE;
      }

      mongoc_gridfs_file_destroy (file);
   } else {
      fprintf (stderr, "Unknown command");
      return EXIT_FAILURE;
   }

   mongoc_gridfs_destroy (gridfs);
   mongoc_uri_destroy (uri);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
The \fI\%MongoDB GridFS specification\fP\&.
.fi
.sp
.nf
The spec\-compliant \fBmongoc_gridfs_bucket_t\fP\&.
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_host_list_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct {
   mongoc_host_list_t *next;
   char host[BSON_HOST_NAME_MAX + 1];
   char host_and_port[BSON_HOST_NAME_MAX + 7];
   uint16_t port;
   int family;
   void *padding[4];
} mongoc_host_list_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
The host and port of a MongoDB server. Can be part of a linked list: for example the return value of \fBmongoc_uri_get_hosts\fP when multiple hosts are provided in the MongoDB URI.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fBmongoc_uri_get_hosts\fP and \fBmongoc_cursor_get_host\fP\&.
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_index_opt_geo_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

typedef struct {
   uint8_t twod_sphere_version;
   uint8_t twod_bits_precision;
   double twod_location_min;
   double twod_location_max;
   double haystack_bucket_size;
   uint8_t *padding[32];
} mongoc_index_opt_geo_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
This structure contains the options that may be used for tuning a GEO index.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
mongoc_index_opt_t
.fi
.sp
.nf
mongoc_index_opt_wt_t
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_index_opt_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

typedef struct {
   bool is_initialized;
   bool background;
   bool unique;
   const char *name;
   bool drop_dups;
   bool sparse;
   int32_t expire_after_seconds;
   int32_t v;
   const bson_t *weights;
   const char *default_language;
   const char *language_override;
   mongoc_index_opt_geo_t *geo_options;
   mongoc_index_opt_storage_t *storage_options;
   const bson_t *partial_filter_expression;
   const bson_t *collation;
   void *padding[4];
} mongoc_index_opt_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Deprecated
.sp
This structure is deprecated and should not be used in new code. See create\-indexes\&.
.SS Description
.sp
This structure contains the options that may be used for tuning a specific index.
.sp
See the \fI\%createIndexes documentations\fP in the MongoDB manual for descriptions of individual options.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
dropDups is deprecated as of MongoDB version 3.0.0.  This option is silently ignored by the server and unique index builds using this option will fail if a duplicate value is detected.
.UNINDENT
.UNINDENT
.SS Example
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
   bson_t keys;
   bson_error_t error;
   mongoc_index_opt_t opt;
   mongoc_index_opt_geo_t geo_opt;

   mongoc_index_opt_init (&opt);
   mongoc_index_opt_geo_init (&geo_opt);

   bson_init (&keys);
   BSON_APPEND_UTF8 (&keys, "location", "2d");

   geo_opt.twod_location_min = \-123;
   geo_opt.twod_location_max = +123;
   geo_opt.twod_bits_precision = 30;
   opt.geo_options = &geo_opt;

   collection = mongoc_client_get_collection (client, "test", "geo_test");
   if (mongoc_collection_create_index (collection, &keys, &opt, &error)) {
      /* Successfully created the geo index */
   }
   bson_destroy (&keys);
   mongoc_collection_destroy (&collection);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
mongoc_index_opt_geo_t
.fi
.sp
.nf
mongoc_index_opt_wt_t
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_index_opt_wt_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

typedef struct {
   mongoc_index_opt_storage_t base;
   const char *config_str;
   void *padding[8];
} mongoc_index_opt_wt_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
This structure contains the options that may be used for tuning a WiredTiger specific index.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
mongoc_index_opt_t
.fi
.sp
.nf
mongoc_index_opt_geo_t
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_insert_flags_t
.sp
Flags for insert operations
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef enum {
   MONGOC_INSERT_NONE = 0,
   MONGOC_INSERT_CONTINUE_ON_ERROR = 1 << 0,
} mongoc_insert_flags_t;

#define MONGOC_INSERT_NO_VALIDATE (1U << 31)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
These flags correspond to the MongoDB wire protocol. They may be bitwise or\(aqd together. They may modify how an insert happens on the MongoDB server.
.SS Flag Values
.TS
center;
|l|l|.
_
T{
MONGOC_INSERT_NONE
T}	T{
Specify no insert flags.
T}
_
T{
MONGOC_INSERT_CONTINUE_ON_ERROR
T}	T{
Continue inserting documents from the insertion set even if one insert fails.
T}
_
T{
MONGOC_INSERT_NO_VALIDATE
T}	T{
Do not validate insertion documents before performing an insert. Validation can be expensive, so this can save some time if you know your documents are already valid.
T}
_
.TE
.SS mongoc_iovec_t
.SS Synopsis
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

#ifdef _WIN32
typedef struct {
   u_long iov_len;
   char *iov_base;
} mongoc_iovec_t;
#else
typedef struct iovec mongoc_iovec_t;
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBmongoc_iovec_t\fP structure is a portability abstraction for consumers of the \fBmongoc_stream_t\fP interfaces. It allows for scatter/gather I/O through the socket subsystem.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
When writing portable code, beware of the ordering of \fBiov_len\fP and \fBiov_base\fP as they are different on various platforms. Therefore, you should not use C initializers for initialization.
.UNINDENT
.UNINDENT
.SS mongoc_matcher_t
.sp
Client\-side document matching abstraction
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_matcher_t mongoc_matcher_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_matcher_t\fP provides a reduced\-interface for client\-side matching of BSON documents.
.sp
It can perform the basics such as $in, $nin, $eq, $neq, $gt, $gte, $lt, and $lte.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
\fBmongoc_matcher_t\fP does not currently support the full spectrum of query operations that the MongoDB server supports.
.UNINDENT
.UNINDENT
.SS Deprecated
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
\fBmongoc_matcher_t\fP is deprecated and will be removed in version 2.0.
.UNINDENT
.UNINDENT
.SS Example
.sp
Filter a sequence of BSON documents from STDIN based on a query
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <bson/bson.h>
#include <mongoc/mongoc.h>
#include <stdio.h>

int
main (int argc, char *argv[])
{
   mongoc_matcher_t *matcher;
   bson_reader_t *reader;
   const bson_t *bson;
   bson_t *spec;
   char *str;
   int fd;

   mongoc_init ();

#ifdef _WIN32
   fd = fileno (stdin);
#else
   fd = STDIN_FILENO;
#endif

   reader = bson_reader_new_from_fd (fd, false);

   spec = BCON_NEW ("hello", "world");
   matcher = mongoc_matcher_new (spec, NULL);

   while ((bson = bson_reader_read (reader, NULL))) {
      if (mongoc_matcher_match (matcher, bson)) {
         str = bson_as_canonical_extended_json (bson, NULL);
         printf ("%s\en", str);
         bson_free (str);
      }
   }

   bson_reader_destroy (reader);
   bson_destroy (spec);

   mongoc_cleanup ();

   return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_optional_t
.sp
A struct to store optional boolean values.
.SS Synopsis
.sp
Used to specify optional boolean flags, which may remain unset.
.sp
This is used within \fBmongoc_server_api_t\fP to track whether a flag was explicitly set.
.SS mongoc_query_flags_t
.sp
Flags for query operations
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef enum {
   MONGOC_QUERY_NONE = 0,
   MONGOC_QUERY_TAILABLE_CURSOR = 1 << 1,
   MONGOC_QUERY_SECONDARY_OK = 1 << 2,
   MONGOC_QUERY_OPLOG_REPLAY = 1 << 3,
   MONGOC_QUERY_NO_CURSOR_TIMEOUT = 1 << 4,
   MONGOC_QUERY_AWAIT_DATA = 1 << 5,
   MONGOC_QUERY_EXHAUST = 1 << 6,
   MONGOC_QUERY_PARTIAL = 1 << 7,
} mongoc_query_flags_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
These flags correspond to the MongoDB wire protocol. They may be bitwise or\(aqd together. They may modify how a query is performed in the MongoDB server.
.SS Flag Values
.TS
center;
|l|l|.
_
T{
MONGOC_QUERY_NONE
T}	T{
Specify no query flags.
T}
_
T{
MONGOC_QUERY_TAILABLE_CURSOR
T}	T{
Cursor will not be closed when the last data is retrieved. You can resume this cursor later.
T}
_
T{
MONGOC_QUERY_SECONDARY_OK
T}	T{
Allow query of replica set secondaries.
T}
_
T{
MONGOC_QUERY_OPLOG_REPLAY
T}	T{
Used internally by MongoDB.
T}
_
T{
MONGOC_QUERY_NO_CURSOR_TIMEOUT
T}	T{
The server normally times out an idle cursor after an inactivity period (10 minutes). This prevents that.
T}
_
T{
MONGOC_QUERY_AWAIT_DATA
T}	T{
Use with MONGOC_QUERY_TAILABLE_CURSOR. Block rather than returning no data. After a period, time out.
T}
_
T{
MONGOC_QUERY_EXHAUST
T}	T{
Stream the data down full blast in multiple "reply" packets. Faster when you are pulling down a lot of data and you know you want to retrieve it all.
Only applies to cursors created from a find operation (i.e. \fBmongoc_collection_find()\fP).
T}
_
T{
MONGOC_QUERY_PARTIAL
T}	T{
Get partial results from mongos if some shards are down (instead of throwing an error).
T}
_
.TE
.SS mongoc_rand
.sp
MongoDB Random Number Generator
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void
mongoc_rand_add (const void *buf, int num, double entropy);

void
mongoc_rand_seed (const void *buf, int num);

int
mongoc_rand_status (void);
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
The \fBmongoc_rand\fP family of functions provide access to the low level randomness primitives used by the MongoDB C Driver.  In particular, they control the creation of cryptographically strong pseudo\-random bytes required by some security mechanisms.
.sp
While we can usually pull enough entropy from the environment, you may be required to seed the PRNG manually depending on your OS, hardware and other entropy consumers running on the same system.
.SS Entropy
.sp
\fBmongoc_rand_add\fP and \fBmongoc_rand_seed\fP allow the user to directly provide entropy.  They differ insofar as \fBmongoc_rand_seed\fP requires that each bit provided is fully random.  \fBmongoc_rand_add\fP allows the user to specify the degree of randomness in the provided bytes as well.
.SS Status
.sp
The \fBmongoc_rand_status\fP function allows the user to check the status of the mongoc PRNG.  This can be used to guarantee sufficient entropy at program startup, rather than waiting for runtime errors to occur.
.SS mongoc_read_concern_t
.sp
Read Concern abstraction
.SS Synopsis
.sp
New in MongoDB 3.2.
.sp
The \fBmongoc_read_concern_t\fP allows clients to choose a level of isolation for their reads. The default, MONGOC_READ_CONCERN_LEVEL_LOCAL, is right for the great majority of applications.
.sp
You can specify a read concern on connection objects, database objects, or collection objects.
.sp
See \fI\%readConcern\fP on the MongoDB website for more information.
.sp
Read Concern is only sent to MongoDB when it has explicitly been set by \fBmongoc_read_concern_set_level\fP to anything other than NULL.
.SS Read Concern Levels
.TS
center;
|l|l|l|.
_
T{
Macro
T}	T{
Description
T}	T{
First MongoDB version
T}
_
T{
MONGOC_READ_CONCERN_LEVEL_LOCAL
T}	T{
Level "local", the default.
T}	T{
3.2
T}
_
T{
MONGOC_READ_CONCERN_LEVEL_MAJORITY
T}	T{
Level "majority".
T}	T{
3.2
T}
_
T{
MONGOC_READ_CONCERN_LEVEL_LINEARIZABLE
T}	T{
Level "linearizable".
T}	T{
3.4
T}
_
T{
MONGOC_READ_CONCERN_LEVEL_AVAILABLE
T}	T{
Level "available".
T}	T{
3.6
T}
_
T{
MONGOC_READ_CONCERN_LEVEL_SNAPSHOT
T}	T{
Level "snapshot".
T}	T{
4.0
T}
_
.TE
.sp
For the sake of compatibility with future versions of MongoDB, \fBmongoc_read_concern_set_level\fP allows any string, not just this list of known read concern levels.
.sp
See \fI\%Read Concern Levels\fP in the MongoDB manual for more information about the individual read concern levels.
.SS mongoc_read_mode_t
.sp
Read Preference Modes
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef enum {
   MONGOC_READ_PRIMARY = (1 << 0),
   MONGOC_READ_SECONDARY = (1 << 1),
   MONGOC_READ_PRIMARY_PREFERRED = (1 << 2) | MONGOC_READ_PRIMARY,
   MONGOC_READ_SECONDARY_PREFERRED = (1 << 2) | MONGOC_READ_SECONDARY,
   MONGOC_READ_NEAREST = (1 << 3) | MONGOC_READ_SECONDARY,
} mongoc_read_mode_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
This enum describes how reads should be dispatched. The default is MONGOC_READ_PRIMARY.
.sp
Please see the MongoDB website for a description of \fI\%Read Preferences\fP\&.
.SS mongoc_read_prefs_t
.sp
A read preference abstraction
.SS Synopsis
.sp
\fBmongoc_read_prefs_t\fP provides an abstraction on top of the MongoDB connection read preferences. It allows for hinting to the driver which nodes in a replica set should be accessed first and how.
.sp
You can specify a read preference mode on connection objects, database objects, collection objects, or per\-operation.  Generally, it makes the most sense to stick with the global default mode, \fBMONGOC_READ_PRIMARY\fP\&.  All of the other modes come with caveats that won\(aqt be covered in great detail here.
.SS Read Modes
.TS
center;
|l|l|.
_
T{
MONGOC_READ_PRIMARY
T}	T{
Default mode. All operations read from the current replica set primary.
T}
_
T{
MONGOC_READ_SECONDARY
T}	T{
All operations read from among the nearest secondary members of the replica set.
T}
_
T{
MONGOC_READ_PRIMARY_PREFERRED
T}	T{
In most situations, operations read from the primary but if it is unavailable, operations read from secondary members.
T}
_
T{
MONGOC_READ_SECONDARY_PREFERRED
T}	T{
In most situations, operations read from among the nearest secondary members, but if no secondaries are available, operations read from the primary.
T}
_
T{
MONGOC_READ_NEAREST
T}	T{
Operations read from among the nearest members of the replica set, irrespective of the member\(aqs type.
T}
_
.TE
.SS Tag Sets
.sp
Tag sets allow you to specify custom read preferences and write concerns so that your application can target operations to specific members.
.sp
Custom read preferences and write concerns evaluate tags sets in different ways: read preferences consider the value of a tag when selecting a member to read from, while write concerns ignore the value of a tag when selecting a member, except to consider whether or not the value is unique.
.sp
You can specify tag sets with the following read preference modes:
.INDENT 0.0
.IP \(bu 2
primaryPreferred
.IP \(bu 2
secondary
.IP \(bu 2
secondaryPreferred
.IP \(bu 2
nearest
.UNINDENT
.sp
Tags are not compatible with \fBMONGOC_READ_PRIMARY\fP and, in general, only apply when selecting a secondary member of a set for a read operation. However, the nearest read mode, when combined with a tag set, will select the nearest member that matches the specified tag set, which may be a primary or secondary.
.sp
Tag sets are represented as a comma\-separated list of colon\-separated key\-value
pairs when provided as a connection string, e.g. \fIdc:ny,rack:1\fP\&.
.sp
To specify a list of tag sets, using multiple readPreferenceTags, e.g.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
readPreferenceTags=dc:ny,rack:1;readPreferenceTags=dc:ny;readPreferenceTags=
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note the empty value for the last one, which means "match any secondary as a last resort".
.sp
Order matters when using multiple readPreferenceTags.
.sp
Tag Sets can also be configured using \fBmongoc_read_prefs_set_tags\fP\&.
.sp
All interfaces use the same member selection logic to choose the member to which to direct read operations, basing the choice on read preference mode and tag sets.
.SS Max Staleness
.sp
When connected to replica set running MongoDB 3.4 or later, the driver estimates the staleness of each secondary based on lastWriteDate values provided in server hello responses.
.sp
Max Staleness is the maximum replication lag in seconds (wall clock time) that a secondary can suffer and still be eligible for reads. The default is \fBMONGOC_NO_MAX_STALENESS\fP, which disables staleness checks. Otherwise, it must be a positive integer at least \fBMONGOC_SMALLEST_MAX_STALENESS_SECONDS\fP (90 seconds).
.sp
Max Staleness is also supported by sharded clusters of replica sets if all servers run MongoDB 3.4 or later.
.SS Hedged Reads
.sp
When connecting to a sharded cluster running MongoDB 4.4 or later, reads can be sent in parallel to the two "best" hosts.  Once one result returns, any other outstanding operations that were part of the hedged read are cancelled.
.sp
When the read preference mode is \fBMONGOC_READ_NEAREST\fP and the sharded cluster is running MongoDB 4.4 or later, hedged reads are enabled by default.  Additionally, hedged reads may be explicitly enabled or disabled by calling \fBmongoc_read_prefs_set_hedge\fP with a BSON document, e.g.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
   enabled: true
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Appropriate values for the \fBenabled\fP key are \fBtrue\fP or \fBfalse\fP\&.
.SS mongoc_remove_flags_t
.sp
Flags for deletion operations
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef enum {
   MONGOC_REMOVE_NONE = 0,
   MONGOC_REMOVE_SINGLE_REMOVE = 1 << 0,
} mongoc_remove_flags_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
These flags correspond to the MongoDB wire protocol. They may be bitwise or\(aqd together. They may change the number of documents that are removed during a remove command.
.SS Flag Values
.TS
center;
|l|l|.
_
T{
MONGOC_REMOVE_NONE
T}	T{
Specify no removal flags. All matching documents will be removed.
T}
_
T{
MONGOC_REMOVE_SINGLE_REMOVE
T}	T{
Only remove the first matching document from the selector.
T}
_
.TE
.SS mongoc_reply_flags_t
.sp
Flags from server replies
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef enum {
   MONGOC_REPLY_NONE = 0,
   MONGOC_REPLY_CURSOR_NOT_FOUND = 1 << 0,
   MONGOC_REPLY_QUERY_FAILURE = 1 << 1,
   MONGOC_REPLY_SHARD_CONFIG_STALE = 1 << 2,
   MONGOC_REPLY_AWAIT_CAPABLE = 1 << 3,
} mongoc_reply_flags_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
These flags correspond to the wire protocol. They may be bitwise or\(aqd together.
.SS Flag Values
.TS
center;
|l|l|.
_
T{
MONGOC_REPLY_NONE
T}	T{
No flags set.
T}
_
T{
MONGOC_REPLY_CURSOR_NOT_FOUND
T}	T{
No matching cursor was found on the server.
T}
_
T{
MONGOC_REPLY_QUERY_FAILURE
T}	T{
The query failed or was invalid. Error document has been provided.
T}
_
T{
MONGOC_REPLY_SHARD_CONFIG_STALE
T}	T{
Shard config is stale.
T}
_
T{
MONGOC_REPLY_AWAIT_CAPABLE
T}	T{
If the returned cursor is capable of MONGOC_QUERY_AWAIT_DATA.
T}
_
.TE
.SS mongoc_server_api_t
.sp
A versioned API to use for connections.
.SS Synopsis
.sp
Used to specify which version of the MongoDB server\(aqs API to use for driver connections.
.sp
The server API type takes a \fBmongoc_server_api_version_t\fP\&. It can optionally be strict about the list of allowed commands in that API version, and can also optionally provide errors for deprecated commands in that API version.
.sp
A \fBmongoc_server_api_t\fP can be set on a client, and will then be sent to MongoDB for most commands run using that client.
.SS mongoc_server_api_version_t
.sp
A representation of server API version numbers.
.SS Synopsis
.sp
Used to specify which version of the MongoDB server\(aqs API to use for driver connections.
.SS Supported API Versions
.sp
The driver currently supports the following MongoDB API versions:
.TS
center;
|l|l|.
_
T{
Enum value
T}	T{
MongoDB version string
T}
_
T{
MONGOC_SERVER_API_V1
T}	T{
"1"
T}
_
.TE
.SS mongoc_server_description_t
.sp
Server description
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>
typedef struct _mongoc_server_description_t mongoc_server_description_t
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_server_description_t\fP holds information about a mongod or mongos the driver is connected to.
.SS Lifecycle
.sp
Clean up a \fBmongoc_server_description_t\fP with \fBmongoc_server_description_destroy()\fP when necessary.
.sp
Applications receive a temporary reference to a \fBmongoc_server_description_t\fP as a parameter to an SDAM Monitoring callback that must not be destroyed. See
Introduction to Application Performance Monitoring\&.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
\fBmongoc_client_get_server_descriptions()\fP\&.
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_session_opt_t
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

typedef struct _mongoc_session_opt_t mongoc_session_opt_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Synopsis
.sp
Start a session with \fBmongoc_client_start_session\fP, use the session for a sequence of operations and multi\-document transactions, then free it with \fBmongoc_client_session_destroy()\fP\&. Any \fBmongoc_cursor_t\fP or \fBmongoc_change_stream_t\fP using a session must be destroyed before the session, and a session must be destroyed before the \fBmongoc_client_t\fP it came from.
.sp
By default, sessions are \fI\%causally consistent\fP\&. To disable causal consistency, before starting a session create a \fBmongoc_session_opt_t\fP with \fBmongoc_session_opts_new()\fP and call \fBmongoc_session_opts_set_causal_consistency()\fP, then free the struct with \fBmongoc_session_opts_destroy\fP\&.
.sp
Unacknowledged writes are prohibited with sessions.
.sp
A \fBmongoc_client_session_t\fP must be used by only one thread at a time. Due to session pooling, \fBmongoc_client_start_session\fP may return a session that has been idle for some time and is about to be closed after its idle timeout. Use the session within one minute of acquiring it to refresh the session and avoid a timeout.
.sp
See the example code for \fBmongoc_session_opts_set_causal_consistency\fP\&.
.SS mongoc_socket_t
.sp
Portable socket abstraction
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

typedef struct _mongoc_socket_t mongoc_socket_t
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Synopsis
.sp
This structure provides a socket abstraction that is friendlier for portability than BSD sockets directly. Inconsistencies between Linux, various BSDs, Solaris, and Windows are handled here.
.SS mongoc_ssl_opt_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct {
   const char *pem_file;
   const char *pem_pwd;
   const char *ca_file;
   const char *ca_dir;
   const char *crl_file;
   bool weak_cert_validation;
   bool allow_invalid_hostname;
   void *internal;
   void *padding[6];
} mongoc_ssl_opt_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
This structure is used to set the TLS options for a \fBmongoc_client_t\fP or \fBmongoc_client_pool_t\fP\&.
.sp
Beginning in version 1.2.0, once a pool or client has any TLS options set, all connections use TLS, even if \fBssl=true\fP is omitted from the MongoDB URI. Before, TLS options were ignored unless \fBtls=true\fP was included in the URI.
.sp
As of 1.4.0, the \fBmongoc_client_pool_set_ssl_opts\fP and \fBmongoc_client_set_ssl_opts\fP will not only shallow copy the struct, but will also copy the \fBconst char*\fP\&. It is therefore no longer needed to make sure the values remain valid after setting them.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
configuring_tls
.fi
.sp
.nf
mongoc_client_set_ssl_opts
.fi
.sp
.nf
mongoc_client_pool_set_ssl_opts
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_stream_buffered_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_stream_buffered_t mongoc_stream_buffered_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
\fBmongoc_stream_buffered_t\fP should be considered a subclass of \fBmongoc_stream_t\fP\&. It performs buffering on an underlying stream.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
mongoc_stream_buffered_new()
.fi
.sp
.nf
mongoc_stream_destroy()
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_stream_file_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_stream_file_t mongoc_stream_file_t
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_stream_file_t\fP is a \fBmongoc_stream_t\fP subclass for working with standard UNIX style file\-descriptors.
.SS mongoc_stream_socket_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_stream_socket_t mongoc_stream_socket_t
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_stream_socket_t\fP should be considered a subclass of \fBmongoc_stream_t\fP that works upon socket streams.
.SS mongoc_stream_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_stream_t mongoc_stream_t
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_stream_t\fP provides a generic streaming IO abstraction based on a struct of pointers interface. The idea is to allow wrappers, perhaps other language drivers, to easily shim their IO system on top of \fBmongoc_stream_t\fP\&.
.sp
The API for the stream abstraction is currently private and non\-extensible.
.SS Stream Types
.sp
There are a number of built in stream types that come with mongoc. The default configuration is a buffered unix stream. If TLS is in use, that in turn is wrapped in a tls stream.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.nf
mongoc_stream_buffered_t
.fi
.sp
.nf
mongoc_stream_file_t
.fi
.sp
.nf
mongoc_stream_socket_t
.fi
.sp
.nf
mongoc_stream_tls_t
.fi
.sp
.UNINDENT
.UNINDENT
.SS mongoc_stream_tls_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_stream_tls_t mongoc_stream_tls_t
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_stream_tls_t\fP is a \fBmongoc_stream_t\fP subclass for working with TLS streams.
.SS mongoc_topology_description_t
.sp
Status of MongoDB Servers
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_topology_description_t mongoc_topology_description_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_topology_description_t\fP is an opaque type representing the driver\(aqs knowledge of the MongoDB server or servers it is connected to.
Its API conforms to the \fI\%SDAM Monitoring Specification\fP\&.
.sp
Applications receive a temporary reference to a \fBmongoc_topology_description_t\fP as a parameter to an SDAM Monitoring callback that must not be destroyed. See Introduction to Application Performance Monitoring\&.
.SS mongoc_transaction_opt_t
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

typedef struct _mongoc_transaction_opt_t mongoc_transaction_opt_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Synopsis
.sp
Options for starting a multi\-document transaction.
.sp
When a session is first created with \fBmongoc_client_start_session\fP, it inherits from the client the read concern, write concern, and read preference with which to start transactions. Each of these fields can be overridden independently. Create a \fBmongoc_transaction_opt_t\fP with \fBmongoc_transaction_opts_new\fP, and pass a non\-NULL option to any of the \fBmongoc_transaction_opt_t\fP setter functions:
.INDENT 0.0
.IP \(bu 2
\fBmongoc_transaction_opts_set_read_concern\fP
.IP \(bu 2
\fBmongoc_transaction_opts_set_write_concern\fP
.IP \(bu 2
\fBmongoc_transaction_opts_set_read_prefs\fP
.UNINDENT
.sp
Pass the resulting transaction options to \fBmongoc_client_session_start_transaction\fP\&. Each field set in the transaction options overrides the inherited client configuration.
.SS Example
.sp
example\-transaction.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* gcc example\-transaction.c \-o example\-transaction \e
 *     $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0) */

/* ./example\-transaction [CONNECTION_STRING] */

#include <stdio.h>
#include <mongoc/mongoc.h>


int
main (int argc, char *argv[])
{
   int exit_code = EXIT_FAILURE;

   mongoc_client_t *client = NULL;
   mongoc_database_t *database = NULL;
   mongoc_collection_t *collection = NULL;
   mongoc_client_session_t *session = NULL;
   mongoc_session_opt_t *session_opts = NULL;
   mongoc_transaction_opt_t *default_txn_opts = NULL;
   mongoc_transaction_opt_t *txn_opts = NULL;
   mongoc_read_concern_t *read_concern = NULL;
   mongoc_write_concern_t *write_concern = NULL;
   const char *uri_string = "mongodb://127.0.0.1/?appname=transaction\-example";
   mongoc_uri_t *uri;
   bson_error_t error;
   bson_t *doc = NULL;
   bson_t *insert_opts = NULL;
   int32_t i;
   int64_t start;
   bson_t reply = BSON_INITIALIZER;
   char *reply_json;
   bool r;

   mongoc_init ();

   if (argc > 1) {
      uri_string = argv[1];
   }

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      MONGOC_ERROR ("failed to parse URI: %s\en"
                    "error message:       %s\en",
                    uri_string,
                    error.message);
      goto done;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      goto done;
   }

   mongoc_client_set_error_api (client, 2);
   database = mongoc_client_get_database (client, "example\-transaction");

   /* inserting into a nonexistent collection normally creates it, but a
    * collection can\(aqt be created in a transaction; create it now */
   collection =
      mongoc_database_create_collection (database, "collection", NULL, &error);

   if (!collection) {
      /* code 48 is NamespaceExists, see error_codes.err in mongodb source */
      if (error.code == 48) {
         collection = mongoc_database_get_collection (database, "collection");
      } else {
         MONGOC_ERROR ("Failed to create collection: %s", error.message);
         goto done;
      }
   }

   /* a transaction\(aqs read preferences, read concern, and write concern can be
    * set on the client, on the default transaction options, or when starting
    * the transaction. for the sake of this example, set read concern on the
    * default transaction options. */
   default_txn_opts = mongoc_transaction_opts_new ();
   read_concern = mongoc_read_concern_new ();
   mongoc_read_concern_set_level (read_concern, "snapshot");
   mongoc_transaction_opts_set_read_concern (default_txn_opts, read_concern);
   session_opts = mongoc_session_opts_new ();
   mongoc_session_opts_set_default_transaction_opts (session_opts,
                                                     default_txn_opts);

   session = mongoc_client_start_session (client, session_opts, &error);
   if (!session) {
      MONGOC_ERROR ("Failed to start session: %s", error.message);
      goto done;
   }

   /* in this example, set write concern when starting the transaction */
   txn_opts = mongoc_transaction_opts_new ();
   write_concern = mongoc_write_concern_new ();
   mongoc_write_concern_set_wmajority (write_concern, 1000 /* wtimeout */);
   mongoc_transaction_opts_set_write_concern (txn_opts, write_concern);

   insert_opts = bson_new ();
   if (!mongoc_client_session_append (session, insert_opts, &error)) {
      MONGOC_ERROR ("Could not add session to opts: %s", error.message);
      goto done;
   }

retry_transaction:
   r = mongoc_client_session_start_transaction (session, txn_opts, &error);
   if (!r) {
      MONGOC_ERROR ("Failed to start transaction: %s", error.message);
      goto done;
   }

   /* insert two documents \- on error, retry the whole transaction */
   for (i = 0; i < 2; i++) {
      doc = BCON_NEW ("_id", BCON_INT32 (i));
      bson_destroy (&reply);
      r = mongoc_collection_insert_one (
         collection, doc, insert_opts, &reply, &error);

      bson_destroy (doc);

      if (!r) {
         MONGOC_ERROR ("Insert failed: %s", error.message);
         mongoc_client_session_abort_transaction (session, NULL);

         /* a network error, primary failover, or other temporary error in a
          * transaction includes {"errorLabels": ["TransientTransactionError"]},
          * meaning that trying the entire transaction again may succeed
          */
         if (mongoc_error_has_label (&reply, "TransientTransactionError")) {
            goto retry_transaction;
         }

         goto done;
      }

      reply_json = bson_as_json (&reply, NULL);
      printf ("%s\en", reply_json);
      bson_free (reply_json);
   }

   /* in case of transient errors, retry for 5 seconds to commit transaction */
   start = bson_get_monotonic_time ();
   while (bson_get_monotonic_time () \- start < 5 * 1000 * 1000) {
      bson_destroy (&reply);
      r = mongoc_client_session_commit_transaction (session, &reply, &error);
      if (r) {
         /* success */
         break;
      } else {
         MONGOC_ERROR ("Warning: commit failed: %s", error.message);
         if (mongoc_error_has_label (&reply, "TransientTransactionError")) {
            goto retry_transaction;
         } else if (mongoc_error_has_label (&reply,
                                            "UnknownTransactionCommitResult")) {
            /* try again to commit */
            continue;
         }

         /* unrecoverable error trying to commit */
         break;
      }
   }

   exit_code = EXIT_SUCCESS;

done:
   bson_destroy (&reply);
   bson_destroy (insert_opts);
   mongoc_write_concern_destroy (write_concern);
   mongoc_read_concern_destroy (read_concern);
   mongoc_transaction_opts_destroy (txn_opts);
   mongoc_transaction_opts_destroy (default_txn_opts);
   mongoc_client_session_destroy (session);
   mongoc_collection_destroy (collection);
   mongoc_database_destroy (database);
   mongoc_uri_destroy (uri);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return exit_code;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_transaction_state_t
.sp
Constants for transaction states
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef enum {
  MONGOC_TRANSACTION_NONE = 0,
  MONGOC_TRANSACTION_STARTING = 1,
  MONGOC_TRANSACTION_IN_PROGRESS = 2,
  MONGOC_TRANSACTION_COMMITTED = 3,
  MONGOC_TRANSACTION_ABORTED = 4,
} mongoc_transaction_state_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
These constants describe the current transaction state of a session.
.SS Flag Values
.TS
center;
|l|l|.
_
T{
MONGOC_TRANSACTION_NONE
T}	T{
There is no transaction in progress.
T}
_
T{
MONGOC_TRANSACTION_STARTING
T}	T{
A transaction has been started, but no operation has been sent to the server.
T}
_
T{
MONGOC_TRANSACTION_IN_PROGRESS
T}	T{
A transaction is in progress.
T}
_
T{
MONGOC_TRANSACTION_COMMITTED
T}	T{
The transaction was committed.
T}
_
T{
MONGOC_TRANSACTION_ABORTED
T}	T{
The transaction was aborted.
T}
_
.TE
.SS mongoc_update_flags_t
.sp
Flags for update operations
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef enum {
   MONGOC_UPDATE_NONE = 0,
   MONGOC_UPDATE_UPSERT = 1 << 0,
   MONGOC_UPDATE_MULTI_UPDATE = 1 << 1,
} mongoc_update_flags_t;

#define MONGOC_UPDATE_NO_VALIDATE (1U << 31)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
These flags correspond to the MongoDB wire protocol. They may be bitwise or\(aqd together. The allow for modifying the way an update is performed in the MongoDB server.
.SS Flag Values
.TS
center;
|l|l|.
_
T{
MONGOC_UPDATE_NONE
T}	T{
No update flags set.
T}
_
T{
MONGOC_UPDATE_UPSERT
T}	T{
If an upsert should be performed.
T}
_
T{
MONGOC_UPDATE_MULTI_UPDATE
T}	T{
If more than a single matching document should be updated. By default only the first document is updated.
T}
_
T{
MONGOC_UPDATE_NO_VALIDATE
T}	T{
Do not perform client side BSON validations when performing an update. This is useful if you already know your BSON documents are valid.
T}
_
.TE
.SS mongoc_uri_t
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_uri_t mongoc_uri_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Description
.sp
\fBmongoc_uri_t\fP provides an abstraction on top of the MongoDB connection URI format. It provides standardized parsing as well as convenience methods for extracting useful information such as replica hosts or authorization information.
.sp
See \fI\%Connection String URI Reference\fP on the MongoDB website for more information.
.SS Format
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongodb[+srv]://                             <1>
   [username:password@]                      <2>
   host1                                     <3>
   [:port1]                                  <4>
   [,host2[:port2],...[,hostN[:portN]]]      <5>
   [/[database]                              <6>
   [?options]]                               <7>
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 1. 3
"mongodb" is the specifier of the MongoDB protocol. Use "mongodb+srv" with a single service name in place of "host1" to specify the initial list of servers with an SRV record.
.IP 2. 3
An optional username and password.
.IP 3. 3
The only required part of the uri.  This specifies either a hostname, IPv4 address, IPv6 address enclosed in "[" and "]", or UNIX domain socket.
.IP 4. 3
An optional port number.  Defaults to :27017.
.IP 5. 3
Extra optional hosts and ports.  You would specify multiple hosts, for example, for connections to replica sets.
.IP 6. 3
The name of the database to authenticate if the connection string includes authentication credentials.  If /database is not specified and the connection string includes credentials, defaults to the \(aqadmin\(aq database.
.IP 7. 3
Connection specific options.
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Option names are case\-insensitive. Do not repeat the same option (e.g. "mongodb://localhost/db?opt=value1&OPT=value2") since this may have unexpected results.
.UNINDENT
.UNINDENT
.sp
The MongoDB C Driver exposes constants for each supported connection option. These constants make it easier to discover connection options, but their string values can be used as well.
.sp
For example, the following calls are equal.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
uri = mongoc_uri_new ("mongodb://localhost/?" MONGOC_URI_APPNAME "=applicationName");
uri = mongoc_uri_new ("mongodb://localhost/?appname=applicationName");
uri = mongoc_uri_new ("mongodb://localhost/?appName=applicationName");
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Replica Set Example
.sp
To describe a connection to a replica set named \(aqtest\(aq with the following mongod hosts:
.INDENT 0.0
.IP \(bu 2
\fBdb1.example.com\fP on port \fB27017\fP
.IP \(bu 2
\fBdb2.example.com\fP on port \fB2500\fP
.UNINDENT
.sp
You would use a connection string that resembles the following.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
mongodb://db1.example.com,db2.example.com:2500/?replicaSet=test
.ft P
.fi
.UNINDENT
.UNINDENT
.SS SRV Example
.sp
If you have configured an \fI\%SRV record\fP with a name like "_mongodb._tcp.server.example.com" whose records are a list of one or more MongoDB server hostnames, use a connection string like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
uri = mongoc_uri_new ("mongodb+srv://server.example.com/?replicaSet=rs&appName=applicationName");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The driver prefixes the service name with "_mongodb._tcp.", then performs a DNS SRV query to resolve the service name to one or more hostnames. If this query succeeds, the driver performs a DNS TXT query on the service name (without the "_mongodb._tcp" prefix) for additional URI options configured as TXT records.
.sp
On Unix, the MongoDB C Driver relies on libresolv to look up SRV and TXT records. If libresolv is unavailable, then using a "mongodb+srv" URI will cause an error. If your libresolv lacks \fBres_nsearch\fP then the driver will fall back to \fBres_search\fP, which is not thread\-safe.
.SS IPv4 and IPv6
.sp
If connecting to a hostname that has both IPv4 and IPv6 DNS records, the behavior follows \fI\%RFC\-6555\fP\&. A connection to the IPv6 address is attempted first. If IPv6 fails, then a connection is attempted to the IPv4 address. If the connection attempt to IPv6 does not complete within 250ms, then IPv4 is tried in parallel. Whichever succeeds connection first cancels the other. The successful DNS result is cached for 10 minutes.
.sp
As a consequence, attempts to connect to a mongod only listening on IPv4 may be delayed if there are both A (IPv4) and AAAA (IPv6) DNS records associated with the host.
.sp
To avoid a delay, configure hostnames to match the MongoDB configuration. That is, only create an A record if the mongod is only listening on IPv4.
.SS Connection Options
.TS
center;
|l|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Default
T}	T{
Description
T}
_
T{
MONGOC_URI_RETRYREADS
T}	T{
retryreads
T}	T{
true
T}	T{
If "true" and the server is a MongoDB 3.6+ standalone, replica set, or sharded cluster, the driver safely retries a read that failed due to a network error or replica set failover.
T}
_
T{
MONGOC_URI_RETRYWRITES
T}	T{
retrywrites
T}	T{
true if driver built w/ TLS
T}	T{
If "true" and the server is a MongoDB 3.6+ replica set or sharded cluster, the driver safely retries a write that failed due to a network error or replica set failover. Only inserts, updates of single documents, or deletes of single
documents are retried.
T}
_
T{
MONGOC_URI_APPNAME
T}	T{
appname
T}	T{
Empty (no appname)
T}	T{
The client application name. This value is used by MongoDB when it logs connection information and profile information, such as slow queries.
T}
_
T{
MONGOC_URI_TLS
T}	T{
tls
T}	T{
Empty (not set, same as false)
T}	T{
{true|false}, indicating if TLS must be used. (See also \fBmongoc_client_set_ssl_opts\fP and \fBmongoc_client_pool_set_ssl_opts\fP\&.)
T}
_
T{
MONGOC_URI_COMPRESSORS
T}	T{
compressors
T}	T{
Empty (no compressors)
T}	T{
Comma separated list of compressors, if any, to use to compress the wire protocol messages. Snappy, zlib, and zstd are optional build time dependencies, and enable the "snappy", "zlib", and "zstd" values respectively.
T}
_
T{
MONGOC_URI_CONNECTTIMEOUTMS
T}	T{
connecttimeoutms
T}	T{
10,000 ms (10 seconds)
T}	T{
This setting applies to new server connections. It is also used as the socket timeout for server discovery and monitoring operations.
T}
_
T{
MONGOC_URI_SOCKETTIMEOUTMS
T}	T{
sockettimeoutms
T}	T{
300,000 ms (5 minutes)
T}	T{
The time in milliseconds to attempt to send or receive on a socket before the attempt times out.
T}
_
T{
MONGOC_URI_REPLICASET
T}	T{
replicaset
T}	T{
Empty (no replicaset)
T}	T{
The name of the Replica Set that the driver should connect to.
T}
_
T{
MONGOC_URI_ZLIBCOMPRESSIONLEVEL
T}	T{
zlibcompressionlevel
T}	T{
\-1
T}	T{
When the MONGOC_URI_COMPRESSORS includes "zlib" this options configures the zlib compression level, when the zlib compressor is used to compress client data.
T}
_
T{
MONGOC_URI_LOADBALANCED
T}	T{
loadbalanced
T}	T{
false
T}	T{
If true, this indicates the driver is connecting to a MongoDB cluster behind a load balancer.
T}
_
T{
MONGOC_URI_SRVMAXHOSTS
T}	T{
srvmaxhosts
T}	T{
0
T}	T{
If zero, the number of hosts in DNS results is unlimited. If greater than zero, the number of hosts in DNS results is limited to being less than or equal to the given value.
T}
_
.TE
.sp
Setting any of the *timeoutMS options above to \fB0\fP will be interpreted as "use the default value".
.SS Authentication Options
.TS
center;
|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Description
T}
_
T{
MONGOC_URI_AUTHMECHANISM
T}	T{
authmechanism
T}	T{
Specifies the mechanism to use when authenticating as the provided user. See Authentication for supported values.
T}
_
T{
MONGOC_URI_AUTHMECHANISMPROPERTIES
T}	T{
authmechanismproperties
T}	T{
Certain authentication mechanisms have additional options that can be configured. These options should be provided as comma separated option_key:option_value pair and provided as authMechanismProperties. Specifying the same option_key multiple times has undefined behavior.
T}
_
T{
MONGOC_URI_AUTHSOURCE
T}	T{
authsource
T}	T{
The authSource defines the database that should be used to authenticate to. It is unnecessary to provide this option the database name is the same as the database used in the URI.
T}
_
.TE
.SS Mechanism Properties
.TS
center;
|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Description
T}
_
T{
MONGOC_URI_CANONICALIZEHOSTNAME
T}	T{
canonicalizehostname
T}	T{
Use the canonical hostname of the service, rather than its configured alias, when authenticating with Cyrus\-SASL Kerberos.
T}
_
T{
MONGOC_URI_GSSAPISERVICENAME
T}	T{
gssapiservicename
T}	T{
Use alternative service name. The default is \fBmongodb\fP\&.
T}
_
.TE
.SS TLS Options
.TS
center;
|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Description
T}
_
T{
MONGOC_URI_TLS
T}	T{
tls
T}	T{
{true|false}, indicating if TLS must be used.
T}
_
T{
MONGOC_URI_TLSCERTIFICATEKEYFILE
T}	T{
tlscertificatekeyfile
T}	T{
Path to PEM formatted Private Key, with its Public Certificate concatenated at the end.
T}
_
T{
MONGOC_URI_TLSCERTIFICATEKEYFILEPASSWORD
T}	T{
tlscertificatekeypassword
T}	T{
The password, if any, to use to unlock encrypted Private Key.
T}
_
T{
MONGOC_URI_TLSCAFILE
T}	T{
tlscafile
T}	T{
One, or a bundle of, Certificate Authorities whom should be considered to be trusted.
T}
_
T{
MONGOC_URI_TLSALLOWINVALIDCERTIFICATES
T}	T{
tlsallowinvalidcertificates
T}	T{
Accept and ignore certificate verification errors (e.g. untrusted issuer, expired, etc.)
T}
_
T{
MONGOC_URI_TLSALLOWINVALIDHOSTNAMES
T}	T{
tlsallowinvalidhostnames
T}	T{
Ignore hostname verification of the certificate (e.g. Man In The Middle, using valid certificate, but issued for another hostname)
T}
_
T{
MONGOC_URI_TLSINSECURE
T}	T{
tlsinsecure
T}	T{
{true|false}, indicating if insecure TLS options should be used. Currently this implies MONGOC_URI_TLSALLOWINVALIDCERTIFICATES and MONGOC_URI_TLSALLOWINVALIDHOSTNAMES.
T}
_
T{
MONGOC_URI_TLSDISABLECERTIFICATEREVOCATIONCHECK
T}	T{
tlsdisablecertificaterevocationcheck
T}	T{
{true|false}, indicates if revocation checking (CRL / OCSP) should be disabled.
T}
_
T{
MONGOC_URI_TLSDISABLEOCSPENDPOINTCHECK
T}	T{
tlsdisableocspendpointcheck
T}	T{
{true|false}, indicates if OCSP responder endpoints should not be requested when an OCSP response is not stapled.
T}
_
.TE
.sp
See configuring_tls for details about these options and about building libmongoc with TLS support.
.SS Deprecated SSL Options
.sp
The following options have been deprecated and may be removed from future releases of libmongoc.
.TS
center;
|l|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Deprecated For
T}	T{
Key
T}
_
T{
MONGOC_URI_SSL
T}	T{
ssl
T}	T{
MONGOC_URI_TLS
T}	T{
tls
T}
_
T{
MONGOC_URI_SSLCLIENTCERTIFICATEKEYFILE
T}	T{
sslclientcertificatekeyfile
T}	T{
MONGOC_URI_TLSCERTIFICATEKEYFILE
T}	T{
tlscertificatekeyfile
T}
_
T{
MONGOC_URI_SSLCLIENTCERTIFICATEKEYPASSWORD
T}	T{
sslclientcertificatekeypassword
T}	T{
MONGOC_URI_TLSCERTIFICATEKEYFILEPASSWORD
T}	T{
tlscertificatekeypassword
T}
_
T{
MONGOC_URI_SSLCERTIFICATEAUTHORITYFILE
T}	T{
sslcertificateauthorityfile
T}	T{
MONGOC_URI_TLSCAFILE
T}	T{
tlscafile
T}
_
T{
MONGOC_URI_SSLALLOWINVALIDCERTIFICATES
T}	T{
sslallowinvalidcertificates
T}	T{
MONGOC_URI_TLSALLOWINVALIDCERTIFICATES
T}	T{
tlsallowinvalidcertificates
T}
_
T{
MONGOC_URI_SSLALLOWINVALIDHOSTNAMES
T}	T{
sslallowinvalidhostnames
T}	T{
MONGOC_URI_TLSALLOWINVALIDHOSTNAMES
T}	T{
tlsallowinvalidhostnames
T}
_
.TE
.SS Server Discovery, Monitoring, and Selection Options
.sp
Clients in a \fBmongoc_client_pool_t\fP share a topology scanner that runs on a background thread. The thread wakes every \fBheartbeatFrequencyMS\fP (default 10 seconds) to scan all MongoDB servers in parallel. Whenever an application operation requires a server that is not known\-\-for example, if there is no known primary and your application attempts an insert\-\-the thread rescans all servers every half\-second. In this situation the pooled client waits up to \fBserverSelectionTimeoutMS\fP (default 30 seconds) for the thread to find a server suitable for the operation, then returns an error with domain \fBMONGOC_ERROR_SERVER_SELECTION\fP\&.
.sp
Technically, the total time an operation may wait while a pooled client scans the topology is controlled both by \fBserverSelectionTimeoutMS\fP and \fBconnectTimeoutMS\fP\&. The longest wait occurs if the last scan begins just at the end of the selection timeout, and a slow or down server requires the full connection timeout before the client gives up.
.sp
A non\-pooled client is single\-threaded. Every \fBheartbeatFrequencyMS\fP, it blocks the next application operation while it does a parallel scan. This scan takes as long as needed to check the slowest server: roughly \fBconnectTimeoutMS\fP\&. Therefore the default \fBheartbeatFrequencyMS\fP for single\-threaded clients is greater than for pooled clients: 60 seconds.
.sp
By default, single\-threaded (non\-pooled) clients scan only once when an operation requires a server that is not known. If you attempt an insert and there is no known primary, the client checks all servers once trying to find it, then succeeds or returns an error with domain \fBMONGOC_ERROR_SERVER_SELECTION\fP\&. But if you set \fBserverSelectionTryOnce\fP to "false", the single\-threaded client loops, checking all servers every half\-second, until \fBserverSelectionTimeoutMS\fP\&.
.sp
The total time an operation may wait for a single\-threaded client to scan the topology is determined by \fBconnectTimeoutMS\fP in the try\-once case, or \fBserverSelectionTimeoutMS\fP and \fBconnectTimeoutMS\fP if \fBserverSelectionTryOnce\fP is set "false".
.TS
center;
|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Description
T}
_
T{
MONGOC_URI_HEARTBEATFREQUENCYMS
T}	T{
heartbeatfrequencyms
T}	T{
The interval between server monitoring checks. Defaults to 10,000ms (10 seconds) in pooled (multi\-threaded) mode, 60,000ms (60 seconds) in non\-pooled mode (single\-threaded).
T}
_
T{
MONGOC_URI_SERVERSELECTIONTIMEOUTMS
T}	T{
serverselectiontimeoutms
T}	T{
A timeout in milliseconds to block for server selection before throwing an exception. The default is 30,0000ms (30 seconds).
T}
_
T{
MONGOC_URI_SERVERSELECTIONTRYONCE
T}	T{
serverselectiontryonce
T}	T{
If "true", the driver scans the topology exactly once after server selection fails, then either selects a server or returns an error. If it is false, then the driver repeatedly searches for a suitable server for up to \fBserverSelectionTimeoutMS\fP milliseconds (pausing a half second between attempts). The default for \fBserverSelectionTryOnce\fP is "false" for pooled clients, otherwise "true". Pooled clients ignore serverSelectionTryOnce; they signal the thread to rescan the topology every half\-second until serverSelectionTimeoutMS expires.
T}
_
T{
MONGOC_URI_SOCKETCHECKINTERVALMS
T}	T{
socketcheckintervalms
T}	T{
Only applies to single threaded clients. If a socket has not been used within this time, its connection is checked with a quick "hello" call before it is used again. Defaults to 5,000ms (5 seconds).
T}
_
T{
MONGOC_URI_DIRECTCONNECTION
T}	T{
directconnection
T}	T{
If "true", the driver connects to a single server directly and will not monitor additional servers.  If "false", the driver connects based on the presence and value of the \fBreplicaSet\fP option.
T}
_
.TE
.sp
Setting any of the *TimeoutMS options above to \fB0\fP will be interpreted as "use the default value".
.SS Connection Pool Options
.sp
These options govern the behavior of a \fBmongoc_client_pool_t\fP\&. They are ignored by a non\-pooled \fBmongoc_client_t\fP\&.
.TS
center;
|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Description
T}
_
T{
MONGOC_URI_MAXPOOLSIZE
T}	T{
maxpoolsize
T}	T{
The maximum number of clients created by a \fBmongoc_client_pool_t\fP total (both in the pool and checked out). The default value is 100. Once it is reached, \fBmongoc_client_pool_pop\fP blocks until another thread pushes a client.
T}
_
T{
MONGOC_URI_MINPOOLSIZE
T}	T{
minpoolsize
T}	T{
Deprecated. This option\(aqs behavior does not match its name, and its actual behavior will likely hurt performance.
T}
_
T{
MONGOC_URI_MAXIDLETIMEMS
T}	T{
maxidletimems
T}	T{
Not implemented.
T}
_
T{
MONGOC_URI_WAITQUEUEMULTIPLE
T}	T{
waitqueuemultiple
T}	T{
Not implemented.
T}
_
T{
MONGOC_URI_WAITQUEUETIMEOUTMS
T}	T{
waitqueuetimeoutms
T}	T{
The maximum time to wait for a client to become available from the pool.
T}
_
.TE
.SS Write Concern Options
.TS
center;
|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Description
T}
_
T{
MONGOC_URI_W
T}	T{
w
T}	T{
Determines the write concern (guarantee). Valid values:
.INDENT 0.0
.IP \(bu 2
0 = The driver will not acknowledge write operations but will pass or handle any network and socket errors that it receives to the client. If you disable write concern but enable the getLastError commands w option, w overrides the w option.
.IP \(bu 2
1 = Provides basic acknowledgement of write operations. By specifying 1, you require that a standalone mongod instance, or the primary for replica sets, acknowledge all write operations. For drivers released after the default write concern change, this is the default write concern setting.
.IP \(bu 2
majority = For replica sets, if you specify the special majority value to w option, write operations will only return successfully after a majority of the configured replica set members have acknowledged the write operation.
.IP \(bu 2
n = For replica sets, if you specify a number n greater than 1, operations with this write concern return only after n members of the set have acknowledged the write. If you set n to a number that is greater than the number of available set members or members that hold data, MongoDB will wait, potentially indefinitely, for these members to become available.
.IP \(bu 2
tags = For replica sets, you can specify a tag set to require that all members of the set that have these tags configured return confirmation of the write operation.
.UNINDENT
T}
_
T{
MONGOC_URI_WTIMEOUTMS
T}	T{
wtimeoutms
T}	T{
The time in milliseconds to wait for replication to succeed, as specified in the w option, before timing out. When wtimeoutMS is 0, write operations will never time out.
T}
_
T{
MONGOC_URI_JOURNAL
T}	T{
journal
T}	T{
Controls whether write operations will wait until the mongod acknowledges the write operations and commits the data to the on disk journal.
.INDENT 0.0
.IP \(bu 2
true  = Enables journal commit acknowledgement write concern. Equivalent to specifying the getLastError command with the j option enabled.
.IP \(bu 2
false = Does not require that mongod commit write operations to the journal before acknowledging the write operation. This is the default option for the journal parameter.
.UNINDENT
T}
_
.TE
.SS Read Concern Options
.TS
center;
|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Description
T}
_
T{
MONGOC_URI_READCONCERNLEVEL
T}	T{
readconcernlevel
T}	T{
The level of isolation for read operations. If the level is left unspecified, the server default will be used. See \fI\%readConcern in the MongoDB Manual\fP for details.
T}
_
.TE
.SS Read Preference Options
.sp
When connected to a replica set, the driver chooses which member to query using the read preference:
.INDENT 0.0
.IP 1. 3
Choose members whose type matches "readPreference".
.IP 2. 3
From these, if there are any tags sets configured, choose members matching the first tag set. If there are none, fall back to the next tag set and so on, until some members are chosen or the tag sets are exhausted.
.IP 3. 3
From the chosen servers, distribute queries randomly among the server with the fastest round\-trip times. These include the server with the fastest time and any whose round\-trip time is no more than "localThresholdMS" slower.
.UNINDENT
.TS
center;
|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Description
T}
_
T{
MONGOC_URI_READPREFERENCE
T}	T{
readpreference
T}	T{
Specifies the replica set read preference for this connection. This setting overrides any secondaryOk value. The read preference values are the following:
.INDENT 0.0
.IP \(bu 2
primary (default)
.IP \(bu 2
primaryPreferred
.IP \(bu 2
secondary
.IP \(bu 2
secondaryPreferred
.IP \(bu 2
nearest
.UNINDENT
T}
_
T{
MONGOC_URI_READPREFERENCETAGS
T}	T{
readpreferencetags
T}	T{
A representation of a tag set. See also mongoc\-read\-prefs\-tag\-sets\&.
T}
_
T{
MONGOC_URI_LOCALTHRESHOLDMS
T}	T{
localthresholdms
T}	T{
How far to distribute queries, beyond the server with the fastest round\-trip time. By default, only servers within 15ms of the fastest round\-trip time receive queries.
T}
_
T{
MONGOC_URI_MAXSTALENESSSECONDS
T}	T{
maxstalenessseconds
T}	T{
The maximum replication lag, in wall clock time, that a secondary can suffer and still be eligible. The smallest allowed value for maxStalenessSeconds is 90 seconds.
T}
_
.TE
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
When connecting to more than one mongos, libmongoc\(aqs localThresholdMS applies only to the selection of mongos servers. The threshold for selecting among replica set members in shards is controlled by the \fI\%mongos\(aqs localThreshold command line option\fP\&.
.UNINDENT
.UNINDENT
.SS Legacy Options
.sp
For historical reasons, the following options are available. They should however not be used.
.TS
center;
|l|l|l|.
_
T{
Constant
T}	T{
Key
T}	T{
Description
T}
_
T{
MONGOC_URI_SAFE
T}	T{
safe
T}	T{
{true|false} Same as w={1|0}
T}
_
.TE
.SS Version Checks
.sp
Conditional compilation based on mongoc version
.SS Description
.sp
The following preprocessor macros can be used to perform various checks based on the version of the library you are compiling against.
This may be useful if you only want to enable a feature on a certain version of the library.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mongoc/mongoc.h>

#define MONGOC_MAJOR_VERSION (x)
#define MONGOC_MINOR_VERSION (y)
#define MONGOC_MICRO_VERSION (z)
#define MONGOC_VERSION_S     "x.y.z"
#define MONGOC_VERSION_HEX   ((1 << 24) | (0 << 16) | (0 << 8) | 0)
#define MONGOC_CHECK_VERSION(major, minor, micro)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Only compile a block on MongoDB C Driver 1.1.0 and newer.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#if MONGOC_CHECK_VERSION(1, 1, 0)
static void
do_something (void)
{
}
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SS mongoc_write_concern_t
.sp
Write Concern abstraction
.SS Synopsis
.sp
\fBmongoc_write_concern_t\fP tells the driver what level of acknowledgement to await from the server. The default, MONGOC_WRITE_CONCERN_W_DEFAULT, is right for the great majority of applications.
.sp
You can specify a write concern on connection objects, database objects, collection objects, or per\-operation. Data\-modifying operations typically use the write concern of the object they operate on, and check the server response for a write concern error or write concern timeout. For example, \fBmongoc_collection_drop_index\fP uses the collection\(aqs write concern, and a write concern error or timeout in the response is considered a failure.
.sp
Exceptions to this principle are the generic command functions:
.INDENT 0.0
.IP \(bu 2
\fBmongoc_client_command\fP
.IP \(bu 2
\fBmongoc_client_command_simple\fP
.IP \(bu 2
\fBmongoc_database_command\fP
.IP \(bu 2
\fBmongoc_database_command_simple\fP
.IP \(bu 2
\fBmongoc_collection_command\fP
.IP \(bu 2
\fBmongoc_collection_command_simple\fP
.UNINDENT
.sp
These generic command functions do not automatically apply a write concern, and they do not check the server response for a write concern error or write concern timeout.
.sp
See \fI\%Write Concern\fP on the MongoDB website for more information.
.SS Write Concern Levels
.sp
Set the write concern level with \fBmongoc_write_concern_set_w\fP\&.
.TS
center;
|l|l|.
_
T{
MONGOC_WRITE_CONCERN_W_DEFAULT (1)
T}	T{
By default, writes block awaiting acknowledgement from MongoDB. Acknowledged write concern allows clients to catch network, duplicate key, and other errors.
T}
_
T{
MONGOC_WRITE_CONCERN_W_UNACKNOWLEDGED (0)
T}	T{
With this write concern, MongoDB does not acknowledge the receipt of write operation. Unacknowledged is similar to errors ignored; however, mongoc attempts to receive and handle network errors when possible.
T}
_
T{
MONGOC_WRITE_CONCERN_W_MAJORITY (majority)
T}	T{
Block until a write has been propagated to a majority of the nodes in the replica set.
T}
_
T{
n
T}	T{
Block until a write has been propagated to at least \fBn\fP nodes in the replica set.
T}
_
.TE
.SS Deprecations
.sp
The write concern \fBMONGOC_WRITE_CONCERN_W_ERRORS_IGNORED\fP (value \-1) is a deprecated synonym for \fBMONGOC_WRITE_CONCERN_W_UNACKNOWLEDGED\fP (value 0), and will be removed in the next major release.
.sp
\fBmongoc_write_concern_set_fsync\fP is deprecated.
.SS Application Performance Monitoring (APM)
.sp
The MongoDB C Driver allows you to monitor all the MongoDB operations the driver executes. This event\-notification system conforms to two MongoDB driver specs:
.INDENT 0.0
.IP \(bu 2
\fI\%Command Monitoring\fP: events related to all application operations.
.IP \(bu 2
\fI\%SDAM Monitoring\fP: events related to the driver\(aqs Server Discovery And Monitoring logic.
.UNINDENT
.sp
To receive notifications, create a \fBmongoc_apm_callbacks_t\fP with \fBmongoc_apm_callbacks_new\fP, set callbacks on it, then pass it to \fBmongoc_client_set_apm_callbacks\fP or \fBmongoc_client_pool_set_apm_callbacks\fP\&.
.SS Command\-Monitoring Example
.sp
example\-command\-monitoring.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* gcc example\-command\-monitoring.c \-o example\-command\-monitoring \e
 *     $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0) */

/* ./example\-command\-monitoring [CONNECTION_STRING] */

#include <mongoc/mongoc.h>
#include <stdio.h>


typedef struct {
   int started;
   int succeeded;
   int failed;
} stats_t;


void
command_started (const mongoc_apm_command_started_t *event)
{
   char *s;

   s = bson_as_relaxed_extended_json (
      mongoc_apm_command_started_get_command (event), NULL);
   printf ("Command %s started on %s:\en%s\en\en",
           mongoc_apm_command_started_get_command_name (event),
           mongoc_apm_command_started_get_host (event)\->host,
           s);

   ((stats_t *) mongoc_apm_command_started_get_context (event))\->started++;

   bson_free (s);
}


void
command_succeeded (const mongoc_apm_command_succeeded_t *event)
{
   char *s;

   s = bson_as_relaxed_extended_json (
      mongoc_apm_command_succeeded_get_reply (event), NULL);
   printf ("Command %s succeeded:\en%s\en\en",
           mongoc_apm_command_succeeded_get_command_name (event),
           s);

   ((stats_t *) mongoc_apm_command_succeeded_get_context (event))\->succeeded++;

   bson_free (s);
}


void
command_failed (const mongoc_apm_command_failed_t *event)
{
   bson_error_t error;

   mongoc_apm_command_failed_get_error (event, &error);
   printf ("Command %s failed:\en\e"%s\e"\en\en",
           mongoc_apm_command_failed_get_command_name (event),
           error.message);

   ((stats_t *) mongoc_apm_command_failed_get_context (event))\->failed++;
}


int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_apm_callbacks_t *callbacks;
   stats_t stats = {0};
   mongoc_collection_t *collection;
   bson_error_t error;
   const char *uri_string =
      "mongodb://127.0.0.1/?appname=cmd\-monitoring\-example";
   mongoc_uri_t *uri;
   const char *collection_name = "test";
   bson_t *docs[2];

   mongoc_init ();

   if (argc > 1) {
      uri_string = argv[1];
   }

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   callbacks = mongoc_apm_callbacks_new ();
   mongoc_apm_set_command_started_cb (callbacks, command_started);
   mongoc_apm_set_command_succeeded_cb (callbacks, command_succeeded);
   mongoc_apm_set_command_failed_cb (callbacks, command_failed);
   mongoc_client_set_apm_callbacks (
      client, callbacks, (void *) &stats /* context pointer */);

   collection = mongoc_client_get_collection (client, "test", collection_name);
   mongoc_collection_drop (collection, NULL);

   docs[0] = BCON_NEW ("_id", BCON_INT32 (0));
   docs[1] = BCON_NEW ("_id", BCON_INT32 (1));
   mongoc_collection_insert_many (
      collection, (const bson_t **) docs, 2, NULL, NULL, NULL);

   /* duplicate key error on the second insert */
   mongoc_collection_insert_one (collection, docs[0], NULL, NULL, NULL);

   mongoc_collection_destroy (collection);
   mongoc_apm_callbacks_destroy (callbacks);
   mongoc_uri_destroy (uri);
   mongoc_client_destroy (client);

   printf ("started: %d\ensucceeded: %d\enfailed: %d\en",
           stats.started,
           stats.succeeded,
           stats.failed);

   bson_destroy (docs[0]);
   bson_destroy (docs[1]);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This example program prints:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Command drop started on 127.0.0.1:
{ "drop" : "test" }

Command drop succeeded:
{ "ns" : "test.test", "nIndexesWas" : 1, "ok" : 1.0 }

Command insert started on 127.0.0.1:
{
  "insert" : "test",
  "ordered" : true,
  "documents" : [
    { "_id" : 0 }, { "_id" : 1 }
  ]
}

Command insert succeeded:
{ "n" : 2, "ok" : 1.0 }

Command insert started on 127.0.0.1:
{
  "insert" : "test",
  "ordered" : true,
  "documents" : [
    { "_id" : 0 }
  ]
}

Command insert succeeded:
{
  "n" : 0,
  "writeErrors" : [
    { "index" : 0, "code" : 11000, "errmsg" : "duplicate key" }
  ],
  "ok" : 1.0
}

started: 3
succeeded: 3
failed: 0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The output has been edited and formatted for clarity. Depending on your server configuration, messages may include metadata like database name, logical session ids, or cluster times that are not shown here.
.sp
The final "insert" command is considered successful, despite the writeError, because the server replied to the overall command with \fB"ok": 1\fP\&.
.SS SDAM Monitoring Example
.sp
example\-sdam\-monitoring.c
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* gcc example\-sdam\-monitoring.c \-o example\-sdam\-monitoring \e
 *     $(pkg\-config \-\-cflags \-\-libs libmongoc\-1.0) */

/* ./example\-sdam\-monitoring [CONNECTION_STRING] */

#include <mongoc/mongoc.h>
#include <stdio.h>


typedef struct {
   int server_changed_events;
   int server_opening_events;
   int server_closed_events;
   int topology_changed_events;
   int topology_opening_events;
   int topology_closed_events;
   int heartbeat_started_events;
   int heartbeat_succeeded_events;
   int heartbeat_failed_events;
} stats_t;


static void
server_changed (const mongoc_apm_server_changed_t *event)
{
   stats_t *context;
   const mongoc_server_description_t *prev_sd, *new_sd;

   context = (stats_t *) mongoc_apm_server_changed_get_context (event);
   context\->server_changed_events++;

   prev_sd = mongoc_apm_server_changed_get_previous_description (event);
   new_sd = mongoc_apm_server_changed_get_new_description (event);

   printf ("server changed: %s %s \-> %s\en",
           mongoc_apm_server_changed_get_host (event)\->host_and_port,
           mongoc_server_description_type (prev_sd),
           mongoc_server_description_type (new_sd));
}


static void
server_opening (const mongoc_apm_server_opening_t *event)
{
   stats_t *context;

   context = (stats_t *) mongoc_apm_server_opening_get_context (event);
   context\->server_opening_events++;

   printf ("server opening: %s\en",
           mongoc_apm_server_opening_get_host (event)\->host_and_port);
}


static void
server_closed (const mongoc_apm_server_closed_t *event)
{
   stats_t *context;

   context = (stats_t *) mongoc_apm_server_closed_get_context (event);
   context\->server_closed_events++;

   printf ("server closed: %s\en",
           mongoc_apm_server_closed_get_host (event)\->host_and_port);
}


static void
topology_changed (const mongoc_apm_topology_changed_t *event)
{
   stats_t *context;
   const mongoc_topology_description_t *prev_td;
   const mongoc_topology_description_t *new_td;
   mongoc_server_description_t **prev_sds;
   size_t n_prev_sds;
   mongoc_server_description_t **new_sds;
   size_t n_new_sds;
   size_t i;
   mongoc_read_prefs_t *prefs;

   context = (stats_t *) mongoc_apm_topology_changed_get_context (event);
   context\->topology_changed_events++;

   prev_td = mongoc_apm_topology_changed_get_previous_description (event);
   prev_sds = mongoc_topology_description_get_servers (prev_td, &n_prev_sds);
   new_td = mongoc_apm_topology_changed_get_new_description (event);
   new_sds = mongoc_topology_description_get_servers (new_td, &n_new_sds);

   printf ("topology changed: %s \-> %s\en",
           mongoc_topology_description_type (prev_td),
           mongoc_topology_description_type (new_td));

   if (n_prev_sds) {
      printf ("  previous servers:\en");
      for (i = 0; i < n_prev_sds; i++) {
         printf ("      %s %s\en",
                 mongoc_server_description_type (prev_sds[i]),
                 mongoc_server_description_host (prev_sds[i])\->host_and_port);
      }
   }

   if (n_new_sds) {
      printf ("  new servers:\en");
      for (i = 0; i < n_new_sds; i++) {
         printf ("      %s %s\en",
                 mongoc_server_description_type (new_sds[i]),
                 mongoc_server_description_host (new_sds[i])\->host_and_port);
      }
   }

   prefs = mongoc_read_prefs_new (MONGOC_READ_SECONDARY);

   /* it is safe, and unfortunately necessary, to cast away const here */
   if (mongoc_topology_description_has_readable_server (
          (mongoc_topology_description_t *) new_td, prefs)) {
      printf ("  secondary AVAILABLE\en");
   } else {
      printf ("  secondary UNAVAILABLE\en");
   }

   if (mongoc_topology_description_has_writable_server (
          (mongoc_topology_description_t *) new_td)) {
      printf ("  primary AVAILABLE\en");
   } else {
      printf ("  primary UNAVAILABLE\en");
   }

   mongoc_read_prefs_destroy (prefs);
   mongoc_server_descriptions_destroy_all (prev_sds, n_prev_sds);
   mongoc_server_descriptions_destroy_all (new_sds, n_new_sds);
}


static void
topology_opening (const mongoc_apm_topology_opening_t *event)
{
   stats_t *context;

   context = (stats_t *) mongoc_apm_topology_opening_get_context (event);
   context\->topology_opening_events++;

   printf ("topology opening\en");
}


static void
topology_closed (const mongoc_apm_topology_closed_t *event)
{
   stats_t *context;

   context = (stats_t *) mongoc_apm_topology_closed_get_context (event);
   context\->topology_closed_events++;

   printf ("topology closed\en");
}


static void
server_heartbeat_started (const mongoc_apm_server_heartbeat_started_t *event)
{
   stats_t *context;

   context =
      (stats_t *) mongoc_apm_server_heartbeat_started_get_context (event);
   context\->heartbeat_started_events++;

   printf ("%s heartbeat started\en",
           mongoc_apm_server_heartbeat_started_get_host (event)\->host_and_port);
}


static void
server_heartbeat_succeeded (
   const mongoc_apm_server_heartbeat_succeeded_t *event)
{
   stats_t *context;
   char *reply;

   context =
      (stats_t *) mongoc_apm_server_heartbeat_succeeded_get_context (event);
   context\->heartbeat_succeeded_events++;

   reply = bson_as_canonical_extended_json (
      mongoc_apm_server_heartbeat_succeeded_get_reply (event), NULL);

   printf (
      "%s heartbeat succeeded: %s\en",
      mongoc_apm_server_heartbeat_succeeded_get_host (event)\->host_and_port,
      reply);

   bson_free (reply);
}


static void
server_heartbeat_failed (const mongoc_apm_server_heartbeat_failed_t *event)
{
   stats_t *context;
   bson_error_t error;

   context = (stats_t *) mongoc_apm_server_heartbeat_failed_get_context (event);
   context\->heartbeat_failed_events++;
   mongoc_apm_server_heartbeat_failed_get_error (event, &error);

   printf ("%s heartbeat failed: %s\en",
           mongoc_apm_server_heartbeat_failed_get_host (event)\->host_and_port,
           error.message);
}


int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_apm_callbacks_t *cbs;
   stats_t stats = {0};
   const char *uri_string =
      "mongodb://127.0.0.1/?appname=sdam\-monitoring\-example";
   mongoc_uri_t *uri;
   bson_t cmd = BSON_INITIALIZER;
   bson_t reply;
   bson_error_t error;

   mongoc_init ();

   if (argc > 1) {
      uri_string = argv[1];
   }

   uri = mongoc_uri_new_with_error (uri_string, &error);
   if (!uri) {
      fprintf (stderr,
               "failed to parse URI: %s\en"
               "error message:       %s\en",
               uri_string,
               error.message);
      return EXIT_FAILURE;
   }

   client = mongoc_client_new_from_uri (uri);
   if (!client) {
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);
   cbs = mongoc_apm_callbacks_new ();
   mongoc_apm_set_server_changed_cb (cbs, server_changed);
   mongoc_apm_set_server_opening_cb (cbs, server_opening);
   mongoc_apm_set_server_closed_cb (cbs, server_closed);
   mongoc_apm_set_topology_changed_cb (cbs, topology_changed);
   mongoc_apm_set_topology_opening_cb (cbs, topology_opening);
   mongoc_apm_set_topology_closed_cb (cbs, topology_closed);
   mongoc_apm_set_server_heartbeat_started_cb (cbs, server_heartbeat_started);
   mongoc_apm_set_server_heartbeat_succeeded_cb (cbs,
                                                 server_heartbeat_succeeded);
   mongoc_apm_set_server_heartbeat_failed_cb (cbs, server_heartbeat_failed);
   mongoc_client_set_apm_callbacks (
      client, cbs, (void *) &stats /* context pointer */);

   /* the driver connects on demand to perform first operation */
   BSON_APPEND_INT32 (&cmd, "buildinfo", 1);
   mongoc_client_command_simple (client, "admin", &cmd, NULL, &reply, &error);
   mongoc_uri_destroy (uri);
   mongoc_client_destroy (client);

   printf ("Events:\en"
           "   server changed: %d\en"
           "   server opening: %d\en"
           "   server closed: %d\en"
           "   topology changed: %d\en"
           "   topology opening: %d\en"
           "   topology closed: %d\en"
           "   heartbeat started: %d\en"
           "   heartbeat succeeded: %d\en"
           "   heartbeat failed: %d\en",
           stats.server_changed_events,
           stats.server_opening_events,
           stats.server_closed_events,
           stats.topology_changed_events,
           stats.topology_opening_events,
           stats.topology_closed_events,
           stats.heartbeat_started_events,
           stats.heartbeat_succeeded_events,
           stats.heartbeat_failed_events);

   bson_destroy (&cmd);
   bson_destroy (&reply);
   mongoc_apm_callbacks_destroy (cbs);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Start a 3\-node replica set on localhost with set name "rs" and start the program:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&./example\-sdam\-monitoring "mongodb://localhost:27017,localhost:27018/?replicaSet=rs"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This example program prints something like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
topology opening
topology changed: Unknown \-> ReplicaSetNoPrimary
  secondary UNAVAILABLE
  primary UNAVAILABLE
server opening: localhost:27017
server opening: localhost:27018
localhost:27017 heartbeat started
localhost:27018 heartbeat started
localhost:27017 heartbeat succeeded: { ... reply ... }
server changed: localhost:27017 Unknown \-> RSPrimary
server opening: localhost:27019
topology changed: ReplicaSetNoPrimary \-> ReplicaSetWithPrimary
  new servers:
      RSPrimary localhost:27017
  secondary UNAVAILABLE
  primary AVAILABLE
localhost:27019 heartbeat started
localhost:27018 heartbeat succeeded: { ... reply ... }
server changed: localhost:27018 Unknown \-> RSSecondary
topology changed: ReplicaSetWithPrimary \-> ReplicaSetWithPrimary
  previous servers:
      RSPrimary localhost:27017
  new servers:
      RSPrimary localhost:27017
      RSSecondary localhost:27018
  secondary AVAILABLE
  primary AVAILABLE
localhost:27019 heartbeat succeeded: { ... reply ... }
server changed: localhost:27019 Unknown \-> RSSecondary
topology changed: ReplicaSetWithPrimary \-> ReplicaSetWithPrimary
  previous servers:
      RSPrimary localhost:27017
      RSSecondary localhost:27018
  new servers:
      RSPrimary localhost:27017
      RSSecondary localhost:27018
      RSSecondary localhost:27019
  secondary AVAILABLE
  primary AVAILABLE
topology closed

Events:
   server changed: 3
   server opening: 3
   server closed: 0
   topology changed: 4
   topology opening: 1
   topology closed: 1
   heartbeat started: 3
   heartbeat succeeded: 3
   heartbeat failed: 0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The driver connects to the mongods on ports 27017 and 27018, which were specified in the URI, and determines which is primary. It also discovers the third member, "localhost:27019", and adds it to the topology.
.SH AUTHOR
MongoDB, Inc
.SH COPYRIGHT
2017-present, MongoDB, Inc
.\" Generated by docutils manpage writer.
.
