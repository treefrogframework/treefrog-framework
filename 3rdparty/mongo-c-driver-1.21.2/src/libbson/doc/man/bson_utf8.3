.\" Man page generated from reStructuredText.
.
.TH "BSON_UTF8" "3" "Jun 07, 2022" "1.21.2" "libbson"
.SH NAME
bson_utf8 \- UTF-8
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH ENCODING
.sp
Libbson expects that you are always working with UTF\-8 encoded text. Anything else is \fBinvalid API use\fP\&.
.sp
If you should need to walk through UTF\-8 sequences, you can use the various UTF\-8 helper functions distributed with Libbson.
.SH VALIDATING A UTF-8 SEQUENCE
.sp
To validate the string contained in \fBmy_string\fP, use the following. You may pass \fB\-1\fP for the string length if you know the string is NULL\-terminated.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if (!bson_utf8_validate (my_string, \-1, false)) {
   printf ("Validation failed.\en");
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If \fBmy_string\fP has NULL bytes within the string, you must provide the string length. Use the following format. Notice the \fBtrue\fP at the end indicating \fB\e0\fP is allowed.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if (!bson_utf8_validate (my_string, my_string_len, true)) {
   printf ("Validation failed.\en");
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For more information see the API reference for \fBbson_utf8_validate()\fP\&.
.SH AUTHOR
MongoDB, Inc
.SH COPYRIGHT
2017-present, MongoDB, Inc
.\" Generated by docutils manpage writer.
.
